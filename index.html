<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeImagePDFTools - Modern UI Pro</title>
    <meta name="description" content="Free online tools for image & PDF manipulation: compress, resize, convert, crop, filter, merge, split, organize, rotate PDF, image to Base64, Base64 to image, add page numbers to PDF, add watermark to PDF, compress PDF, protect PDF, unlock PDF, view/edit PDF metadata, HTML to PDF, image color picker, image watermark, and more.">
    <meta name="keywords" content="online tools, free tools, image compressor, image resizer, image converter, JPG, PNG, WebP, image crop, rotate image, image filters, JPG to PDF, PDF to JPG, merge PDF, split PDF, organize PDF, rotate PDF, reorder PDF pages, delete PDF pages, image to base64, base64 to image, add page numbers pdf, add watermark pdf, compress pdf, pdf to word, pdf to powerpoint, pdf to excel, protect pdf, unlock pdf, pdf metadata, html to pdf, image color picker, image watermark, PDF tools, optimize photos, image preview, pdf preview, modern ui, catchy design">
    <meta name="author" content="FreeImagePDFTools">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">

    <meta property="og:title" content="FreeImagePDFTools | Free Image & PDF Tools - Enhanced!">
    <meta property="og:description" content="Free online tools for image compression, resizing, conversion, cropping, filters, JPG to PDF, PDF to JPG, PDF Merge, PDF Split, PDF Organization, PDF Rotation, Image to Base64, Base64 to Image, Add Page Numbers to PDF, Add Text Watermark to PDF, Compress PDF, Protect PDF, Unlock PDF, PDF Metadata, HTML to PDF, Image Color Picker, Image Watermark, and more. Modern & easy to use!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="YOUR_WEBSITE_URL_HERE"> <!-- Replace with your URL -->

    <style>
        /* --- MODERN UI STYLES (ENHANCED) --- */
        :root {
            --primary-color: #1abc9c; /* Teal */
            --primary-darker: #16a085;
            --secondary-color: #7f8c8d; /* Gray */
            --secondary-darker: #606f70;
            --accent-color: #e67e22; /* Orange */
            --light-bg: #f4f7f6; /* Very light grey-green */
            --content-bg: #ffffff;
            --dark-text: #2c3e50; /* Dark blue/gray */
            --light-text: #ffffff;
            --light-text-rgb: 255,255,255; /* Added for scrollbar track */
            --gray-text: #95a5a6; /* Lighter gray */
            --border-color: #ecf0f1; /* Light border */
            --success-color: #2ecc71; /* Green */
            --danger-color: #e74c3c; /* Red */
            --info-color: #3498db; /* Blue */

            /* RGB versions for rgba() usage */
            --dark-text-rgb: 44, 62, 80;
            --primary-rgb: 26, 188, 156;
            --info-rgb: 52, 152, 219;


            --header-bg-color: rgba(var(--dark-text-rgb), 0.85); /* For glassmorphism */
            --header-link-color: var(--primary-color);
            --header-link-hover: var(--light-text);

            --border-radius-sm: 0.3rem;
            --border-radius-md: 0.6rem;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 5px 15px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.1);

            --card-hover-glow: 0 0 25px rgba(var(--primary-rgb), 0.3);
            --input-focus-glow: 0 0 0 3px rgba(var(--primary-rgb), 0.25);
            --subtle-glow-primary: 0 2px 10px -2px rgba(var(--primary-rgb),0.4), 0 1px 5px -3px rgba(var(--primary-rgb),0.3);

            --font-base-size: 16px;
            --line-height-base: 1.7;
            --padding-base: 1.5rem;
            --margin-base: 1.5rem;
        }

        /* --- Base & Reset --- */
        *, *::before, *::after { box-sizing: border-box; }
        html { font-size: var(--font-base-size); scroll-behavior: smooth; }

        @keyframes subtleBackgroundAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        body {
            font-family: 'Roboto', sans-serif;
            line-height: var(--line-height-base);
            margin: 0; padding: 0;
            background: linear-gradient(-45deg, var(--light-bg), #e8f3f0, #f0f5f3, #ddeeed);
            background-size: 400% 400%;
            animation: subtleBackgroundAnimation 35s ease infinite;
            color: var(--dark-text);
            padding-top: 70px; /* Adjust based on final header height */
            font-weight: 400;
        }

        /* Custom Scrollbar (WebKit browsers) */
        ::-webkit-scrollbar { width: 10px; height: 10px;}
        ::-webkit-scrollbar-track { background: rgba(var(--dark-text-rgb), 0.05); }
        ::-webkit-scrollbar-thumb { background: var(--secondary-color); border-radius: var(--border-radius-sm); }
        ::-webkit-scrollbar-thumb:hover { background: var(--secondary-darker); }


        /* --- Header --- */
        header {
            background-color: var(--header-bg-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--light-text);
            padding: 0.8rem 0;
            position: fixed; width: 100%; top: 0; left: 0; z-index: 1000;
            box-shadow: var(--shadow-sm);
            transition: background-color 0.3s ease;
        }
        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px; margin: 0 auto; padding: 0 var(--padding-base);
            box-shadow: none;
        }
        header h1 {
            margin: 0; font-size: 1.8rem; color: var(--header-link-color); font-weight: 700;
            letter-spacing: -0.5px;
            transition: color 0.3s ease, transform 0.2s ease;
        }
        header h1 a { color: inherit; text-decoration: none; }
        header h1 a:hover { color: var(--header-link-hover); transform: scale(1.03); }
        header nav ul { list-style: none; margin: 0; padding: 0; display: flex; gap: 1.5rem; align-items: center; }
        header nav a { /* This applies to main nav links and dropdown trigger text */
            color: var(--header-link-color);
            text-decoration: none; font-weight: 500;
            transition: color 0.3s ease, transform 0.2s ease;
            padding: 0.3rem 0; /* Vertical padding for main nav links */
            position: relative;
        }
        header nav > ul > li > a:not(.dropbtn):hover { color: var(--header-link-hover); transform: translateY(-1px); } /* Hover only for direct li>a that are not dropdown triggers */
        header nav > ul > li > a:not(.dropbtn)::after { /* Underline for direct li>a that are not dropdown triggers */
            content: ''; position: absolute; bottom: 0; left: 0;
            width: 0; height: 2px;
            background-color: var(--header-link-hover);
            transition: width 0.3s ease;
        }
        header nav > ul > li > a:not(.dropbtn):hover::after,
        header nav > ul > li > a:not(.dropbtn).active-link::after { width: 100%; }

        header nav > ul > li > a.active-link { /* Active state for direct li>a */
            color: var(--header-link-hover);
            font-weight: 700;
        }
        header nav ul li.dropdown .dropbtn.active-parent-dropdown { /* Style for active dropdown parent */
             color: var(--header-link-hover);
             font-weight: 700;
        }


        /* --- Header Dropdown Menu --- */
        header nav ul li.dropdown {
            position: relative;
            display: inline-block;
        }

        header nav ul li.dropdown .dropbtn {
            display: flex; 
            align-items: center;
            padding: 0.3rem 0.5rem; 
        }
        header nav ul li.dropdown .dropbtn .arrow {
            font-size: 0.7em;
            margin-left: 5px;
            transition: transform 0.3s ease;
            display: inline-block; 
        }
        header nav ul li.dropdown:hover .dropbtn .arrow {
            transform: rotate(180deg);
        }

        header nav ul li .dropdown-content {
            display: none;
            position: absolute;
            top: 100%; 
            left: 0;   
            background-color: var(--header-bg-color); 
            min-width: 240px; 
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.3);
            z-index: 1001; 
            border-radius: 0 0 var(--border-radius-sm) var(--border-radius-sm);
            padding: 0.5rem 0;
            max-height: 70vh; 
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        /* Custom scrollbar for dropdown content */
        header nav ul li .dropdown-content::-webkit-scrollbar {
            width: 6px;
        }
        header nav ul li .dropdown-content::-webkit-scrollbar-track {
            background: rgba(var(--light-text-rgb, 255,255,255), 0.1); 
        }
        header nav ul li .dropdown-content::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 3px;
        }
        /* For Firefox */
        header nav ul li .dropdown-content {
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(var(--light-text-rgb, 255,255,255), 0.1);
        }

        header nav ul li .dropdown-content a {
            color: var(--header-link-color); 
            padding: 10px 15px;
            text-decoration: none;
            display: block;
            text-align: left;
            font-weight: 400; 
            white-space: nowrap; 
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        header nav ul li .dropdown-content a:hover {
            background-color: rgba(var(--primary-rgb), 0.2); 
            color: var(--header-link-hover); 
        }
        header nav ul li .dropdown-content a::after { 
            display: none;
        }
        header nav ul li .dropdown-content a.active-link { /* Style for active link inside dropdown */
            background-color: rgba(var(--primary-rgb), 0.3);
            color: var(--header-link-hover);
            font-weight: 500;
        }


        /* Show dropdown on hover for parent li, or focus on button, or hover on content */
        header nav ul li.dropdown:hover > .dropdown-content, 
        header nav ul li.dropdown .dropbtn:focus + .dropdown-content, 
        header nav ul li.dropdown .dropdown-content:hover 
        {
            display: block;
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }


        /* --- General Layout & Typography --- */
        .container {
            max-width: 1140px;
            margin: var(--margin-base) auto;
            padding: calc(var(--padding-base) * 1.5);
            background-color: var(--content-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--border-radius-md);
        }
        h1, h2, h3, h4 { color: var(--dark-text); margin-bottom: var(--margin-base); text-align: center; font-weight: 500; }
        h1 { font-size: 2.5rem; font-weight: 700;}
        h2 { font-size: 2rem; margin-top: calc(var(--margin-base) * 1.5); }
        h3 { font-size: 1.5rem; }
        p { color: var(--dark-text); margin-bottom: var(--margin-base); font-weight: 300; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.3s ease; }
        a:hover { color: var(--primary-darker); text-decoration: underline; }

        main > section { display: none; }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--light-text);
            padding: 0.8rem 1.8rem;
            border-radius: var(--border-radius-md);
            text-align: center; border: none; cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease;
            font-size: 1rem; line-height: 1.5; font-weight: 500;
            vertical-align: middle; text-decoration: none;
            box-shadow: var(--subtle-glow-primary);
        }
        .btn:hover {
            background-color: var(--primary-darker);
            color: var(--light-text); transform: translateY(-3px) scale(1.03);
            box-shadow: var(--shadow-md), 0 0 15px rgba(var(--primary-rgb), 0.25);
        }
        .btn:active {
            transform: translateY(-1px) scale(0.99);
            box-shadow: var(--shadow-sm);
        }
        .btn-secondary { background-color: var(--secondary-color); box-shadow: 0 2px 10px -2px rgba(127,140,141,0.4); }
        .btn-secondary:hover { background-color: var(--secondary-darker); box-shadow: var(--shadow-md), 0 0 15px rgba(127,140,141, 0.25); }
        .btn-success { background-color: var(--success-color); box-shadow: 0 2px 10px -2px rgba(46,204,113,0.4); }
        .btn-success:hover { background-color: #27ae60;  box-shadow: var(--shadow-md), 0 0 15px rgba(46,204,113, 0.25); }
        .btn:disabled {
            background-color: #bdc3c7;
            color: #7f8c8d; cursor: not-allowed; transform: none; box-shadow: none;
        }

        /* --- Forms & Inputs --- */
        .tool-controls {
            margin-bottom: calc(var(--margin-base) * 1.5);
            display: flex; flex-wrap: wrap; gap: 1.5rem;
            align-items: center; justify-content: center;
            padding: var(--padding-base);
            background-color: var(--light-bg);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        .tool-controls label { font-weight: 500; margin-right: 0.5rem; color: var(--dark-text); }

        input[type="text"], input[type="password"], input[type="number"], input[type="email"], select, textarea {
            padding: 0.8rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: 1rem; font-family: inherit;
            background-color: var(--content-bg);
            color: var(--dark-text);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            vertical-align: middle;
        }
        input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus, input[type="email"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: var(--input-focus-glow);
        }
        textarea { width: 100%; min-height: 100px; resize: vertical; }
        input[type="range"] {
            width: 100%; max-width: 300px; cursor: pointer; vertical-align: middle;
            accent-color: var(--primary-color);
        }
        select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 1rem center; background-size: 1em; padding-right: 3rem; cursor: pointer; }

        /* --- Drop Zone --- */
        .file-input-container { margin-bottom: var(--margin-base); text-align: center; }
        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius-md);
            padding: 2.5rem;
            text-align: center; cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            color: var(--gray-text);
            max-width: 550px; margin: 1.5rem auto;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 180px;
            background-color: var(--content-bg);
            position: relative; /* For pseudo-element icon */
            overflow: hidden;
        }
        .drop-zone::before { /* Upload icon */
            content: '📤'; /* Placeholder, ideally an SVG for better quality */
            font-size: 3rem;
            color: var(--primary-color);
            opacity: 0.2;
            display: block;
            margin-bottom: 0.5rem;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .drop-zone:hover::before { opacity: 0.5; transform: translateY(-3px) scale(1.05); }
        .drop-zone p { margin: 0.5rem 0; font-weight: 300; z-index: 1; position:relative; }
        .drop-zone label {
             margin-top: 1rem; color: var(--primary-color); cursor: pointer; font-weight: 500; display: inline-block; padding: 0.5rem 1rem; border: 1px solid transparent; border-radius: var(--border-radius-sm); transition: background-color 0.2s ease, color 0.2s ease; z-index: 1; position:relative;
        }
        .drop-zone label:hover { background-color: rgba(var(--primary-rgb), 0.1); color: var(--primary-darker); }
        .drop-zone.drag-over {
            background-color: rgba(var(--primary-rgb), 0.08);
            border-color: var(--primary-darker);
            border-style: solid;
            box-shadow: inset 0 0 20px rgba(var(--primary-rgb), 0.15);
        }
        .drop-zone.drag-over::before { opacity: 0.8; transform: translateY(-5px) scale(1.15); }
        input[type="file"] { display: none; }

        /* --- Info & Preview Sections --- */
        .image-info, .output-info, .file-list-display, .text-output-area, .metadata-display-area {
            margin-top: var(--margin-base);
            border-top: 1px solid var(--border-color);
            padding-top: var(--margin-base);
            display: none;
            background-color: var(--light-bg);
            padding: var(--padding-base);
            border-radius: var(--border-radius-md);
        }
        .image-info p, .output-info p, .metadata-display-area p { margin: 0.6rem 0; font-size: 0.95rem; }
        .image-info strong, .output-info strong, .metadata-display-area strong { font-weight: 500; min-width: 150px; display: inline-block;}
        .file-list-display h4 { margin-bottom: 0.8rem; font-size: 1.1rem; font-weight: 500; }
        .file-list-display ul { list-style: decimal; padding-left: 25px; text-align: left; max-height: 180px; overflow-y: auto; border: 1px solid var(--border-color); padding: 15px; border-radius: var(--border-radius-sm); background-color: var(--content-bg); margin-top: 0.5rem;}
        .file-list-display li { margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--secondary-color); }

        .image-preview, .pdf-tool-preview {
            margin-top: var(--margin-base); text-align: center; padding-top: var(--margin-base);
            border-top: 1px solid var(--border-color); display: none;
        }
         .image-preview + .image-info,
         .pdf-tool-preview + .output-info,
         .pdf-tool-preview + .image-info,
         .image-preview + .text-output-area,
         .image-preview + .output-info, /* For Base64 to Image */
         .image-preview + .metadata-display-area /* For PDF metadata */
          {
             border-top: none; padding-top: 0; margin-top: 0; border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);
         }

        .preview-comparison { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 2rem; margin-top: 1rem; }
        .preview-comparison > div {
            flex: 1 1 350px;
            max-width: 48%;
            text-align: center; min-height: 250px;
            background-color: var(--light-bg);
            padding: var(--padding-base);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        .preview-comparison .preview-label { font-weight: 500; margin-bottom: 1rem; display: block; font-size: 1.1rem; color: var(--secondary-color); }

        .image-preview img, .pdf-tool-preview img, .image-preview canvas { /* Added canvas for color picker */
            max-width: 100%; height: auto; border: 1px solid #ddd; padding: 5px;
            background-color: var(--content-bg); box-shadow: var(--shadow-sm);
            display: none; margin: 10px auto; border-radius: var(--border-radius-sm);
            vertical-align: middle;
        }
        .preview-comparison img {
            max-width: 100%; max-height: 450px; display: block; margin: 0 auto 1rem auto;
        }

        .pdf-thumbnails-container { max-height: 400px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); margin-top: 5px; min-height: 100px; background-color: var(--content-bg); }
        .pdf-thumbnails-container img { display: inline-block; max-height: 100px; max-width: 75px; margin: 5px; border: 1px solid #ccc; border-radius: var(--border-radius-sm); }
        .pdf-embed-preview { border: 1px solid var(--border-color); display: none; width: 100%; height: 500px; margin-top: 10px; background-color: var(--light-bg); border-radius: var(--border-radius-sm); }
        .preview-success-message {
            display: none;
            color: var(--success-color);
            margin-top: 15px; text-align: center; font-style: normal; font-weight: 500;
            padding: 0.8rem;
            border: 1px solid var(--success-color);
            border-radius: var(--border-radius-sm);
            background-color: #eafaf1;
            font-size: 0.95rem;
        }
        /* Placeholder message for complex tools */
        .placeholder-message {
            color: var(--info-color);
            margin-top: 15px; text-align: center; font-style: normal; font-weight: 500;
            padding: 0.8rem; border: 1px solid var(--info-color);
            border-radius: var(--border-radius-sm); background-color: #e7f3fa; /* Light blue */
            font-size: 0.95rem;
        }
        .placeholder-message.error { /* Style for more prominent API errors */
            color: var(--danger-color);
            border-color: var(--danger-color);
            background-color: #fbeae9; /* Light red */
        }


        /* --- Image Cropper Tool Section --- */
        .cropper-container { position: relative; display: inline-block; max-width: 100%; vertical-align: middle; }
        .crop-selection-overlay {
            position: absolute; border: 1px dashed var(--primary-darker);
            background-color: rgba(var(--primary-rgb), 0.2);
            box-sizing: border-box; display: none;
        }

        /* --- Homepage --- */
        #homepage-section .hero {
            text-align: center; margin-bottom: calc(var(--margin-base) * 2);
            padding: 4rem 2rem; /* Increased padding */
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-darker) 70%, #117a65 100%); /* Deeper gradient */
            color: var(--light-text);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden;
        }
        #homepage-section .hero::before { /* Subtle pattern overlay */
            content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.03) 75%, rgba(255,255,255,0.03)),
                linear-gradient(-45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 75%, rgba(255,255,255,0.03) 75%, rgba(255,255,255,0.03));
            background-size: 25px 25px; opacity: 0.8; z-index: 0;
        }
        #homepage-section .hero > * { position: relative; z-index: 1; } /* Ensure content is above overlay */

        #homepage-section .hero h2 { color: var(--light-text); margin-top: 0; font-size: 2.8rem; font-weight: 700; text-shadow: 1px 1px 3px rgba(0,0,0,0.15); }
        #homepage-section .hero p { font-size: 1.3rem; opacity: 0.95; font-weight: 300; max-width: 700px; margin-left: auto; margin-right: auto; }
        #homepage-section .hero .btn {
            background-color: var(--light-text); color: var(--primary-darker); font-weight: 700; margin-top: 1.5rem;
            transform: scale(1.05); padding: 1rem 2.2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #homepage-section .hero .btn:hover {
            background-color: #f8f9fa; color: var(--primary-color);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25), 0 0 10px rgba(var(--primary-rgb),0.2);
        }

        #homepage-section .tools-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem; margin-top: calc(var(--margin-base) * 1.5);
        }
        #homepage-section .tool-card {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            padding: calc(var(--padding-base) * 1.2);
            text-align: center; background-color: var(--content-bg);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex; flex-direction: column; justify-content: space-between;
            box-shadow: var(--shadow-md);
        }
        #homepage-section .tool-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-lg), var(--card-hover-glow);
        }
        .tool-card .icon-container {
            font-size: 4rem; margin-bottom: 1.2rem; line-height: 1;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
            display: inline-block; /* Important for background-clip to work properly */
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Playful bounce */
        }
        #homepage-section .tool-card:hover .icon-container {
            transform: scale(1.15) rotate(-8deg);
        }
        #homepage-section .tool-card h3 { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.3rem; font-weight: 700; }
        #homepage-section .tool-card h3 a { color: var(--dark-text); text-decoration: none; }
        #homepage-section .tool-card h3 a:hover { color: var(--primary-color); text-decoration: none;}
        #homepage-section .tool-card p { font-size: 0.9rem; color: var(--secondary-color); flex-grow: 1; margin-bottom: 1.5rem; font-weight: 300; }
        #homepage-section .tool-card .tool-link { margin-top: auto; display: block; }

        /* --- Other Sections (About, Contact, Privacy) --- */
        #about-section p, #privacy-section p { text-align: left; font-weight: 400; }
        #contact-section form { max-width: 600px; margin: 0 auto; display: flex; flex-direction: column; gap: 1.2rem; }
        #contact-section label { font-weight: 500; margin-bottom: 0.3rem; display: block; }
        #contact-section input[type="text"], #contact-section input[type="email"], #contact-section textarea { width: 100%; }
        #contact-section textarea { min-height: 150px; resize: vertical; }
        #contact-section button[type="submit"] { align-self: center; margin-top: 0.5rem; }

        /* --- Footer --- */
        footer {
            margin-top: calc(var(--margin-base) * 2); padding: 2.5rem var(--padding-base);
            background-color: var(--dark-text); color: var(--light-bg); text-align: center;
            border-top: 3px solid var(--primary-color);
        }
        footer p { margin: 0.5rem 0; font-size: 0.9rem; opacity: 0.8; font-weight: 300; }
        footer a { color: var(--primary-color); }
        footer a:hover { color: var(--header-link-hover); text-decoration: underline; }

        /* --- Ads Placeholder --- */
        .ad-container {
            width: 100%; margin: 2.5rem auto; text-align: center;
            background-color: rgba(var(--dark-text-rgb),0.03); padding: 1.5rem;
            border: 1px dashed var(--gray-text);
            min-height: 90px; display: flex; justify-content: center; align-items: center;
            font-size: 0.9rem; color: var(--gray-text); border-radius: var(--border-radius-sm);
        }

        /* Processing Message with Spinner */
        .processing-message {
            display: none; /* Toggled to 'flex' by JS */
            text-align: center;
            margin: 1rem 0;
            color: var(--info-color);
            font-style: italic;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }
        .processing-message::before { /* Spinner */
            content: "";
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(var(--info-rgb), 0.3);
            border-radius: 50%;
            border-top-color: var(--info-color);
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Organize PDF Tool Specific Styles --- */
        #organizePageThumbnails .page-thumbnail-item {
            position: relative;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: 5px;
            margin: 5px;
            background-color: var(--content-bg);
            cursor: grab;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s ease-out, opacity 0.2s ease-out;
            user-select: none;
            text-align: center;
            width: 110px;
        }
        #organizePageThumbnails .page-thumbnail-item img {
            max-width: 100px;
            max-height: 140px;
            display: block;
            margin-bottom: 5px;
            pointer-events: none;
        }
        #organizePageThumbnails .page-thumbnail-item .page-number-display {
            font-size: 0.8em;
            color: var(--secondary-color);
        }
        #organizePageThumbnails .page-thumbnail-item .delete-page-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            z-index: 10;
            transition: background-color 0.2s ease;
        }
        #organizePageThumbnails .page-thumbnail-item .delete-page-btn:hover {
            background-color: #c0392b;
        }
        #organizePageThumbnails .page-thumbnail-item.marked-for-deletion {
            border-color: var(--danger-color);
            opacity: 0.6;
        }
        #organizePageThumbnails .page-thumbnail-item.marked-for-deletion img {
            filter: grayscale(50%) opacity(0.7);
        }
        #organizePageThumbnails .page-thumbnail-item.dragging {
            opacity: 0.7;
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
            cursor: grabbing;
            border-style: dashed;
            border-color: var(--primary-color);
        }

        /* --- Rotate PDF Tool Specific Styles --- */
        .rotate-pdf-controls .rotate-icon {
            display: inline-block;
            font-style: normal;
            margin-right: 5px;
            font-size: 1.1em;
            line-height: 1;
            vertical-align: -1px;
        }

        /* --- Image to Base64 & Base64 to Image --- */
        .base64-output-textarea {
            width: 100%;
            min-height: 150px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            resize: vertical;
            margin-bottom: 1rem;
            word-break: break-all;
        }
        .copy-btn-container {
            text-align: right;
            margin-top: -0.5rem; /* Pull it up slightly */
            margin-bottom: 1rem;
        }
        /* PDF Page Numbers / Watermark / Compress PDF*/
        .pdf-customization-controls { /* Shared class for new PDF tools controls if needed */
             /* display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; */
        }
        .pdf-customization-controls .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem; /* Add some spacing between groups */
        }
        .pdf-customization-controls input[type="number"],
        .pdf-customization-controls input[type="text"],
        .pdf-customization-controls input[type="password"] {
            width: auto; /* Don't take full width in flex */
            max-width: 120px;
        }
        .pdf-customization-controls input[type="color"] {
             width: 50px; height: 35px; padding: 2px; border-radius: var(--border-radius-sm);
        }

        /* PDF Metadata Editor Specific Styles */
        .metadata-entry {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem 1rem;
            margin-bottom: 0.8rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
        }
        .metadata-entry:last-child { border-bottom: none; }
        .metadata-entry label {
            flex-basis: 120px; /* Fixed width for labels */
            font-weight: 500;
            color: var(--dark-text);
            margin-right:0; /* Reset from generic tool-controls label */
        }
        .metadata-entry input[type="text"], .metadata-entry span {
            flex-grow: 1;
            max-width: 400px;
        }
        .metadata-entry span { /* For non-editable fields */
            padding: 0.8rem 0; /* Match input padding for alignment */
            color: var(--secondary-darker);
            word-break: break-word;
        }

        /* Image Color Picker Specific Styles */
        #colorPickerCanvasContainer {
            position: relative;
            max-width: 600px; /* Or adjust as needed */
            margin: 1rem auto;
            border: 1px solid var(--border-color);
            cursor: crosshair;
        }
        #colorPickerCanvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        .color-picker-output {
            margin-top: 1rem;
            text-align: center;
            font-size: 1.1rem;
        }
        .color-picker-output .color-preview-box {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 1px solid var(--dark-text);
            margin-right: 10px;
            vertical-align: middle;
            border-radius: var(--border-radius-sm);
        }
        .color-picker-output span {
            display: block;
            margin-top: 0.5rem;
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) { 
             header nav ul {
                 gap: 0.8rem; 
            }
             header nav ul li .dropdown-content {
                min-width: 200px; 
            }
        }

        @media (max-width: 768px) {
            body { padding-top: 110px; } 
            html { font-size: 15px; }
            .container { padding: var(--padding-base); margin: var(--padding-base); }
            h1 { font-size: 2rem; } h2 { font-size: 1.7rem; }
            #homepage-section .hero h2 { font-size: 2.2rem; }
            #homepage-section .hero p { font-size: 1.1rem; }

            header .container { flex-direction: column; align-items: center; gap: 0.8rem; padding-top: 0.5rem; padding-bottom: 0.5rem; }
            header h1 { text-align: center; }
            header nav ul {
                flex-direction: row; 
                flex-wrap: wrap;    
                justify-content: center;
                gap: 0.5rem 1rem; 
            }
             header nav ul li.dropdown .dropdown-content {
                 left: 50%;
                 transform: translateX(-50%) translateY(10px); 
            }
            header nav ul li.dropdown:hover > .dropdown-content,
            header nav ul li.dropdown .dropbtn:focus + .dropdown-content,
            header nav ul li.dropdown .dropdown-content:hover {
                 transform: translateX(-50%) translateY(0);
            }


            .tool-controls { flex-direction: column; align-items: stretch; gap: 1rem; padding: 1rem; }
            .tool-controls label { margin-bottom: 0.5rem; margin-right: 0; }
            input[type="range"] { max-width: none; }
            .dimension-inputs, .crop-inputs, .split-controls { flex-direction: column; align-items: stretch; }
            .dimension-inputs input[type="number"], .crop-inputs input[type="number"], .split-controls input[type="text"] { width: 100%; }
            .convert-controls select, .filter-controls select { width: 100%; }
            .rotate-flip-controls, .filter-controls, .rotate-pdf-controls, .pdf-customization-controls { flex-direction: column; align-items: stretch; }
            .rotate-flip-controls button, .filter-controls button, .rotate-pdf-controls button, .pdf-customization-controls button { width: 100%; margin-top: 0.5rem; }
            .pdf-customization-controls .control-group { flex-direction: column; align-items: stretch; }
            .pdf-customization-controls input[type="number"],
            .pdf-customization-controls input[type="text"],
            .pdf-customization-controls input[type="password"] { max-width: 100%; }


            .preview-comparison { flex-direction: column; gap: var(--margin-base); }
            .preview-comparison > div { max-width: 100%; padding: 1rem; }
            #contact-section form { padding: 0; }
            .drop-zone { padding: 1.5rem; min-height: 150px; }
            .pdf-embed-preview { height: 400px; }
            #organizePageThumbnails .page-thumbnail-item { width: 90px; }
            #organizePageThumbnails .page-thumbnail-item img { max-width: 80px; max-height: 110px; }
             .metadata-entry label { flex-basis: 100%; text-align: left; }
             .metadata-entry input[type="text"], .metadata-entry span { max-width: 100%; }
        }

    </style>

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    { "@context": "https://schema.org", "@type": "WebSite", "name": "FreeImagePDFTools", "url": "YOUR_WEBSITE_URL_HERE" }
    </script>
</head>
<body>

    <header>
        <div class="container">
            <div class="site-title"><a href="#homepage-section"><h1>FreeImagePDFTools</h1></a></div>
            <nav>
                <ul>
                    <li><a href="#homepage-section">Home</a></li>
                    <li class="dropdown">
                        <a href="javascript:void(0)" class="dropbtn">Image Tools <span class="arrow">&#9662;</span></a>
                        <div class="dropdown-content">
                            <a href="#image-compressor-section">Image Compressor</a>
                            <a href="#image-resizer-section">Image Resizer</a>
                            <a href="#image-converter-section">Image Converter</a>
                            <a href="#image-cropper-section">Image Cropper</a>
                            <a href="#image-rotate-flip-section">Rotate & Flip Image</a>
                            <a href="#image-filters-section">Image Filters</a>
                            <a href="#image-to-base64-section">Image to Base64</a>
                            <a href="#base64-to-image-section">Base64 to Image</a>
                            <a href="#image-color-picker-section">Image Color Picker</a>
                            <a href="#image-watermark-section">Image Watermark</a>
                        </div>
                    </li>
                    <li class="dropdown">
                        <a href="javascript:void(0)" class="dropbtn">PDF Tools <span class="arrow">&#9662;</span></a>
                        <div class="dropdown-content">
                            <a href="#jpg-to-pdf-section">JPG to PDF</a>
                            <a href="#pdf-to-jpg-section">PDF to JPG</a>
                            <a href="#merge-pdf-section">Merge PDF</a>
                            <a href="#split-pdf-section">Split PDF</a>
                            <a href="#organize-pdf-section">Organize PDF</a>
                            <a href="#rotate-pdf-section">Rotate PDF</a>
                            <a href="#add-page-numbers-pdf-section">Add Page Numbers to PDF</a>
                            <a href="#add-text-watermark-pdf-section">Add Text Watermark to PDF</a>
                            <a href="#compress-pdf-section">Compress PDF</a>
                            <a href="#pdf-to-word-section">PDF to Word (API)</a>
                            <a href="#pdf-to-powerpoint-section">PDF to PowerPoint (API)</a>
                            <a href="#pdf-to-excel-section">PDF to Excel (API)</a>
                            <a href="#protect-pdf-section">Protect PDF</a>
                            <a href="#unlock-pdf-section">Unlock PDF</a>
                            <a href="#pdf-metadata-section">PDF Metadata</a>
                            <a href="#html-to-pdf-section">HTML to PDF</a>
                        </div>
                    </li>
                    <li><a href="#about-section">About</a></li>
                    <li><a href="#contact-section">Contact</a></li>
                    <li><a href="#privacy-section">Privacy</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <!-- Homepage Section -->
        <section id="homepage-section" class="container" data-aos="fade-up">
            <div class="hero">
                <h2>Your Free Online Image & PDF Toolkit</h2>
                <p>Compress, resize, convert, crop, filter images, and manage PDFs with ease. Fast, free, and right in your browser.</p>
                 <a href="#image-compressor-section" class="btn">Explore Tools</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Homepage Top Ad)</p></div>
            <h3>Our Tools</h3>
            <div class="tools-grid">
                 <!-- Image Tools -->
                <div class="tool-card" data-aos="fade-up" data-aos-delay="100">
                    <div class="icon-container">🖼️</div>
                    <h3><a href="#image-compressor-section">Image Compressor</a></h3>
                    <p>Reduce JPG, PNG, WebP file sizes while preserving quality.</p>
                    <a href="#image-compressor-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="150">
                    <div class="icon-container">📐</div>
                    <h3><a href="#image-resizer-section">Image Resizer</a></h3>
                    <p>Change image dimensions by pixels or percentage easily.</p>
                    <a href="#image-resizer-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="200">
                    <div class="icon-container">🔄</div>
                    <h3><a href="#image-converter-section">Image Converter</a></h3>
                    <p>Convert images between JPG, PNG, and WebP formats.</p>
                    <a href="#image-converter-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="250">
                     <div class="icon-container">✂️</div>
                    <h3><a href="#image-cropper-section">Image Cropper</a></h3>
                    <p>Visually select and crop a specific area of your image.</p>
                    <a href="#image-cropper-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="300">
                     <div class="icon-container">↩️</div>
                    <h3><a href="#image-rotate-flip-section">Rotate & Flip Image</a></h3>
                    <p>Rotate by 90° increments or flip horizontally/vertically.</p>
                    <a href="#image-rotate-flip-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="350">
                     <div class="icon-container">✨</div>
                    <h3><a href="#image-filters-section">Image Filters</a></h3>
                    <p>Apply simple effects like Grayscale, Sepia, Invert etc.</p>
                    <a href="#image-filters-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="370">
                    <div class="icon-container">📜</div>
                    <h3><a href="#image-to-base64-section">Image to Base64</a></h3>
                    <p>Convert your images to Base64 text strings.</p>
                    <a href="#image-to-base64-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="390">
                    <div class="icon-container">🖼️📜</div>
                    <h3><a href="#base64-to-image-section">Base64 to Image</a></h3>
                    <p>Convert Base64 strings back into viewable images.</p>
                    <a href="#base64-to-image-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="395"> 
                    <div class="icon-container">🎨💧</div>
                    <h3><a href="#image-color-picker-section">Image Color Picker</a></h3>
                    <p>Pick colors from an image and get HEX/RGB values.</p>
                    <a href="#image-color-picker-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="397"> 
                    <div class="icon-container">🖼️🏞️</div>
                    <h3><a href="#image-watermark-section">Image Watermark</a></h3>
                    <p>Overlay an image (e.g., logo) onto another image.</p>
                    <a href="#image-watermark-section" class="tool-link btn">Use Tool</a>
                </div>
                 <!-- PDF Tools -->
                <div class="tool-card" data-aos="fade-up" data-aos-delay="400">
                    <div class="icon-container">🖼️📄</div>
                    <h3><a href="#jpg-to-pdf-section">JPG to PDF</a></h3>
                    <p>Combine multiple JPG images into a single PDF document.</p>
                    <a href="#jpg-to-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="450">
                    <div class="icon-container">📄🖼️</div>
                    <h3><a href="#pdf-to-jpg-section">PDF to JPG</a></h3>
                    <p>Convert each PDF page into separate JPG images (ZIP).</p>
                    <a href="#pdf-to-jpg-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="500">
                    <div class="icon-container">📄➕</div>
                    <h3><a href="#merge-pdf-section">Merge PDF</a></h3>
                    <p>Combine several PDF files into one single document.</p>
                    <a href="#merge-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="550">
                    <div class="icon-container">📄✂️</div>
                    <h3><a href="#split-pdf-section">Split PDF</a></h3>
                    <p>Extract specific pages or ranges from a PDF file.</p>
                    <a href="#split-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="600">
                    <div class="icon-container">🧩</div>
                    <h3><a href="#organize-pdf-section">Organize PDF</a></h3>
                    <p>Reorder and delete pages within your PDF document easily.</p>
                    <a href="#organize-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="650">
                    <div class="icon-container">🔃</div>
                    <h3><a href="#rotate-pdf-section">Rotate PDF</a></h3>
                    <p>Rotate all pages of a PDF document by 90° increments.</p>
                    <a href="#rotate-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="670">
                    <div class="icon-container">📄#️⃣</div>
                    <h3><a href="#add-page-numbers-pdf-section">Add Page Numbers to PDF</a></h3>
                    <p>Add page numbers to your PDF document automatically.</p>
                    <a href="#add-page-numbers-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="690">
                    <div class="icon-container">📄✍️</div>
                    <h3><a href="#add-text-watermark-pdf-section">Add Text Watermark to PDF</a></h3>
                    <p>Apply a text watermark to all pages of your PDF.</p>
                    <a href="#add-text-watermark-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="710">
                    <div class="icon-container">📄⚙️</div>
                    <h3><a href="#compress-pdf-section">Compress PDF</a></h3>
                    <p>Reduce file size while optimizing for maximal PDF quality.</p>
                    <a href="#compress-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="730">
                    <div class="icon-container">📄➡️🇼</div>
                    <h3><a href="#pdf-to-word-section">PDF to Word</a></h3>
                    <p>Easily convert your PDF files into easy to edit DOC and DOCX documents.</p>
                    <a href="#pdf-to-word-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="750">
                    <div class="icon-container">📄➡️🇵</div>
                    <h3><a href="#pdf-to-powerpoint-section">PDF to PowerPoint</a></h3>
                    <p>Turn your PDF files into easy to edit PPT and PPTX slideshows.</p>
                    <a href="#pdf-to-powerpoint-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="770">
                    <div class="icon-container">📄➡️📊</div>
                    <h3><a href="#pdf-to-excel-section">PDF to Excel</a></h3>
                    <p>Pull data straight from PDFs into Excel spreadsheets in a few clicks.</p>
                    <a href="#pdf-to-excel-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="790"> 
                    <div class="icon-container">📄🔒</div>
                    <h3><a href="#protect-pdf-section">Protect PDF (Add Password)</a></h3>
                    <p>Secure your PDF file by adding a password for opening.</p>
                    <a href="#protect-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="810"> 
                    <div class="icon-container">📄🔓</div>
                    <h3><a href="#unlock-pdf-section">Unlock PDF (Remove Password)</a></h3>
                    <p>Remove password protection if you know the current password.</p>
                    <a href="#unlock-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="830"> 
                    <div class="icon-container">📄ℹ️</div>
                    <h3><a href="#pdf-metadata-section">PDF Metadata Viewer/Editor</a></h3>
                    <p>View and edit basic metadata of your PDF documents.</p>
                    <a href="#pdf-metadata-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="850"> 
                    <div class="icon-container">📜➡️📄</div>
                    <h3><a href="#html-to-pdf-section">HTML to PDF</a></h3>
                    <p>Convert pasted HTML code into a downloadable PDF file.</p>
                    <a href="#html-to-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
            </div>
            <div class="ad-container"><p>Advertisement Area (Homepage Bottom Ad)</p></div>
        </section>

        <!-- Image Compressor Tool Section -->
        <section id="image-compressor-section" class="container" data-aos="fade-up">
            <h2>Online Image Compressor</h2>
            <p>Reduce the file size of your images without losing noticeable quality. Supports JPG, PNG, and WebP.</p>
            <div class="file-input-container">
                 <div id="compressDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="compressImageFile">Click to Upload Image</label>
                    <input type="file" id="compressImageFile" accept="image/*" aria-label="Select image file for compression">
                 </div>
            </div>
            <div class="tool-controls">
                <label for="compressionQuality">Compression Level:</label>
                <input type="range" id="compressionQuality" min="10" max="100" value="80">
                <span id="qualityValue">80%</span>
                <button id="compressNowBtn" class="btn" disabled>Compress Now</button>
            </div>
            <p id="compressProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Compressor Top Ad)</p></div>
            <div id="compressImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="originalImagePreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Compressed</span><img id="compressedImagePreview" src="" alt="Compressed Image Preview"></div>
                 </div>
            </div>
            <div id="compressImageInfo" class="image-info">
                <h3>Compression Info</h3>
                <p><strong>Filename:</strong> <span id="compressOriginalFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="compressOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="compressedSize">-</span></p>
                <p><strong>Reduction:</strong> <span id="sizeReduction">-</span></p>
            </div>
            <div class="download-section">
                 <p id="compressDownloadMessage" class="preview-success-message" style="display: none;">Your compressed image is ready!</p>
                <a id="compressDownloadLink" class="btn btn-success" style="display: none;">Download Compressed Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Compressor Bottom Ad)</p></div>
        </section>

        <!-- Image Resizer Tool Section -->
        <section id="image-resizer-section" class="container" data-aos="fade-up">
            <h2>Online Image Resizer</h2>
            <p>Easily change the dimensions of your images.</p>
            <div class="file-input-container">
                 <div id="resizeDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="resizeImageFile">Click to Upload Image</label>
                    <input type="file" id="resizeImageFile" accept="image/*" aria-label="Select image file for resizing">
                 </div>
            </div>
            <div class="tool-controls dimension-inputs">
                 <label>New Dimensions:</label>
                 <input type="number" id="resizeWidth" placeholder="Width" min="1"><span>x</span>
                 <input type="number" id="resizeHeight" placeholder="Height" min="1">
                 <button id="applyResizeBtn" class="btn" disabled>Apply Resize</button>
            </div>
            <p id="resizeProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Resizer Top Ad)</p></div>
            <div id="resizeImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="resizeOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Resized</span><img id="resizedImage" src="" alt="Resized Image Preview"></div>
                 </div>
            </div>
            <div id="resizeImageInfo" class="image-info">
                <h3>Resizer Info</h3>
                <p><strong>Filename:</strong> <span id="resizeOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalDimensions">-</span></p>
                <p><strong>New Dimensions:</strong> <span id="newDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="resizeOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="resizedSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="resizeDownloadMessage" class="preview-success-message" style="display: none;">Your resized image is ready!</p>
                <a id="resizeDownloadLink" class="btn btn-success" style="display: none;">Download Resized Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Resizer Bottom Ad)</p></div>
        </section>

        <!-- Image Converter Tool Section -->
        <section id="image-converter-section" class="container" data-aos="fade-up">
            <h2>Online Image Converter</h2>
            <p>Convert your images between popular formats like JPG, PNG, and WebP.</p>
            <div class="file-input-container">
                 <div id="convertDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="convertImageFile">Click to Upload Image</label>
                    <input type="file" id="convertImageFile" accept="image/*" aria-label="Select image file for conversion">
                 </div>
            </div>
            <div class="tool-controls convert-controls">
                 <label for="outputFormat">Convert to:</label>
                 <select id="outputFormat">
                     <option value="image/jpeg">JPG</option><option value="image/png">PNG</option><option value="image/webp">WebP</option>
                 </select>
                 <button id="applyConvertBtn" class="btn" disabled>Convert Image</button>
            </div>
            <p id="convertProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Converter Top Ad)</p></div>
            <div id="convertImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="convertOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Converted</span><img id="convertedImage" src="" alt="Converted Image Preview"></div>
                 </div>
            </div>
            <div id="convertImageInfo" class="image-info">
                <h3>Conversion Info</h3>
                <p><strong>Filename:</strong> <span id="convertOriginalFileName"></span></p>
                <p><strong>Original Format:</strong> <span id="originalFormat">-</span></p>
                <p><strong>New Format:</strong> <span id="newFormat">-</span></p>
                <p><strong>Original Size:</strong> <span id="convertOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="convertedSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="convertDownloadMessage" class="preview-success-message" style="display: none;">Your converted image is ready!</p>
                <a id="convertDownloadLink" class="btn btn-success" style="display: none;">Download Converted Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Converter Bottom Ad)</p></div>
        </section>

        <!-- Image Cropper Tool Section -->
        <section id="image-cropper-section" class="container" data-aos="fade-up">
            <h2>Online Image Cropper</h2>
            <p>Click "Select Area" and then click and drag on the image to select the crop area. Click "Crop" to process.</p>
            <div class="file-input-container">
                 <div id="cropDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="cropImageFile">Click to Upload Image</label>
                    <input type="file" id="cropImageFile" accept="image/*" aria-label="Select image file for cropping">
                 </div>
            </div>
            <div class="tool-controls">
                 <button id="selectCropAreaBtn" class="btn" disabled>Select Area</button>
                 <button id="cropAndDownloadBtn" class="btn" disabled>Crop</button>
            </div>
            <p id="cropProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Cropper Top Ad)</p></div>
            <div id="cropImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="cropper-container">
                     <img id="cropOriginalImagePreview" src="" alt="Image to Crop"><div class="crop-selection-overlay"></div>
                 </div>
                  <div class="preview-comparison" style="display: none;">
                     <div><span class="preview-label">Original</span><img id="cropCompareOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Cropped</span><img id="croppedImage" src="" alt="Cropped Image Preview"></div>
                 </div>
                 <div class="download-section">
                     <p id="cropDownloadMessage" class="preview-success-message" style="display: none;">Your cropped image is ready!</p>
                    <a id="cropDownloadLink" class="btn btn-success" style="display: none;">Download Cropped Image</a>
                </div>
            </div>
            <div id="cropImageInfo" class="image-info">
                <h3>Cropper Info</h3>
                <p><strong>Filename:</strong> <span id="cropOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="cropOriginalDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="cropOriginalSize"></span></p>
                <p><strong>Cropped Dimensions:</strong> <span id="newCropDimensions">-</span></p>
                <p><strong>Cropped Size:</strong> <span id="croppedSize">-</span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Cropper Bottom Ad)</p></div>
        </section>

        <!-- Image Rotate & Flip Tool Section -->
        <section id="image-rotate-flip-section" class="container" data-aos="fade-up">
            <h2>Online Image Rotate & Flip</h2>
            <p>Rotate your image by 90 degrees or flip it horizontally or vertically.</p>
            <div class="file-input-container">
                 <div id="rotateFlipDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="rotateFlipImageFile">Click to Upload Image</label>
                    <input type="file" id="rotateFlipImageFile" accept="image/*" aria-label="Select image file for rotate/flip">
                 </div>
            </div>
            <div class="tool-controls rotate-flip-controls">
                 <button id="rotateLeftBtn" class="btn" disabled>Rotate Left 90°</button>
                 <button id="rotateRightBtn" class="btn" disabled>Rotate Right 90°</button>
                 <button id="flipHorizontalBtn" class="btn" disabled>Flip Horizontal</button>
                 <button id="flipVerticalBtn" class="btn" disabled>Flip Vertical</button>
            </div>
            <p id="rotateFlipProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Rotate/Flip Top Ad)</p></div>
            <div id="rotateFlipImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="rotateFlipOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Result</span><img id="rotatedFlippedImage" src="" alt="Rotated/Flipped Image Preview"></div>
                 </div>
            </div>
            <div id="rotateFlipImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="rotateFlipOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalRotateFlipDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="rotateFlipOriginalSize"></span></p>
                <p><strong>New Dimensions:</strong> <span id="newRotateFlipDimensions">-</span></p>
                <p><strong>New Size:</strong> <span id="newRotateFlipSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="rotateFlipDownloadMessage" class="preview-success-message" style="display: none;">Your image is ready!</p>
                <a id="rotateFlipDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Rotate/Flip Bottom Ad)</p></div>
        </section>

        <!-- Image Filters Tool Section -->
        <section id="image-filters-section" class="container" data-aos="fade-up">
            <h2>Online Image Filters</h2>
            <p>Apply filters to your image.</p>
            <div class="file-input-container">
                 <div id="filterDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="filterImageFile">Click to Upload Image</label>
                    <input type="file" id="filterImageFile" accept="image/*" aria-label="Select image file for filtering">
                 </div>
            </div>
            <div class="tool-controls filter-controls">
                 <label for="filterType">Select Filter:</label>
                 <select id="filterType" disabled>
                     <option value="none">None</option><option value="grayscale">Grayscale</option>
                     <option value="sepia">Sepia</option><option value="invert">Invert</option>
                     <option value="red">Red Channel</option><option value="green">Green Channel</option><option value="blue">Blue Channel</option>
                 </select>
                 <button id="applyFilterBtn" class="btn" disabled>Apply Filter</button>
            </div>
            <p id="filterProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Filters Top Ad)</p></div>
            <div id="filterImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="filterOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Filtered</span><img id="filteredImage" src="" alt="Filtered Image Preview"></div>
                 </div>
                 <div class="download-section">
                     <p id="filterDownloadMessage" class="preview-success-message" style="display: none;">Your filtered image is ready!</p>
                    <a id="filterDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
                </div>
            </div>
            <div id="filterImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="filterOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalFilterDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="filterOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="newFilterSize">-</span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Filters Bottom Ad)</p></div>
        </section>

        <!-- Image to Base64 Tool Section -->
        <section id="image-to-base64-section" class="container" data-aos="fade-up">
            <h2>Image to Base64 Converter</h2>
            <p>Convert your JPG, PNG, or WebP images into a Base64 data string.</p>
            <div class="file-input-container">
                <div id="imgToBase64DropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="imgToBase64File">Click to Upload Image</label>
                    <input type="file" id="imgToBase64File" accept="image/*" aria-label="Select image file for Base64 conversion">
                </div>
            </div>
            <p id="imgToBase64ProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Image to Base64 Top Ad)</p></div>
            <div id="imgToBase64ImagePreview" class="image-preview">
                <h3>Original Image Preview</h3>
                <img id="imgToBase64OriginalPreview" src="" alt="Original Image Preview">
            </div>
            <div id="imgToBase64OutputArea" class="text-output-area">
                <h3>Base64 String:</h3>
                <textarea id="imgToBase64ResultText" class="base64-output-textarea" readonly placeholder="Base64 string will appear here..."></textarea>
                <div class="copy-btn-container">
                    <button id="copyBase64Btn" class="btn btn-secondary" disabled>Copy to Clipboard</button>
                </div>
            </div>
            <div id="imgToBase64Info" class="image-info">
                <p><strong>Filename:</strong> <span id="imgToBase64FileName"></span></p>
                <p><strong>Original Size:</strong> <span id="imgToBase64OriginalSize"></span></p>
                <p><strong>Base64 String Length:</strong> <span id="imgToBase64StringLength"></span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Image to Base64 Bottom Ad)</p></div>
        </section>

        <!-- Base64 to Image Tool Section -->
        <section id="base64-to-image-section" class="container" data-aos="fade-up">
            <h2>Base64 to Image Converter</h2>
            <p>Paste a Base64 data string (e.g., from an image) to convert it back to an image.</p>
            <div class="tool-controls">
                <textarea id="base64ToImageInput" class="base64-output-textarea" placeholder="Paste Base64 data string here (e.g., data:image/png;base64,iVBORw0KGgo...)"></textarea>
            </div>
            <div class="tool-controls">
                <label for="base64ToImageOutputFormat">Download Format:</label>
                <select id="base64ToImageOutputFormat">
                    <option value="image/png">PNG</option>
                    <option value="image/jpeg">JPG</option>
                    <option value="image/webp">WebP</option>
                </select>
                <button id="base64ToImageConvertBtn" class="btn" disabled>Convert to Image</button>
            </div>
            <p id="base64ToImageProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Base64 to Image Top Ad)</p></div>
            <div id="base64ToImagePreview" class="image-preview">
                <h3>Converted Image Preview</h3>
                <img id="base64ToImageResultPreview" src="" alt="Converted Image Preview">
            </div>
            <div id="base64ToImageOutputInfo" class="output-info">
                 <p><strong>Detected Format:</strong> <span id="base64ToImageDetectedFormat">-</span></p>
                 <p><strong>Output Dimensions:</strong> <span id="base64ToImageDimensions">-</span></p>
                 <p><strong>Output Size:</strong> <span id="base64ToImageNewSize">-</span></p>
            </div>
            <div class="download-section">
                <p id="base64ToImageDownloadMessage" class="preview-success-message" style="display: none;">Your image is ready!</p>
                <a id="base64ToImageDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Base64 to Image Bottom Ad)</p></div>
        </section>

        <!-- Image Color Picker Tool Section -->
        <section id="image-color-picker-section" class="container" data-aos="fade-up">
            <h2>Image Color Picker</h2>
            <p>Upload an image and click on it to pick a color. The HEX and RGB values will be displayed.</p>
            <div class="file-input-container">
                <div id="colorPickerDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="colorPickerImageFile">Click to Upload Image</label>
                    <input type="file" id="colorPickerImageFile" accept="image/*" aria-label="Select image for color picking">
                </div>
            </div>
            <p id="colorPickerProcessingMsg" class="processing-message">Loading image...</p>
            <div class="ad-container"><p>Advertisement Area (Color Picker Top Ad)</p></div>
            <div id="colorPickerPreviewArea" class="image-preview" style="display: none;">
                <h3>Click on the image to pick a color:</h3>
                <div id="colorPickerCanvasContainer">
                    <canvas id="colorPickerCanvas"></canvas>
                </div>
                <div id="colorPickerOutputDisplay" class="color-picker-output" style="display: none;">
                    <div class="color-preview-box" id="colorPickerPreviewBox"></div>
                    <span id="colorPickerHexValue">HEX: -</span>
                    <span id="colorPickerRgbValue">RGB: -</span>
                </div>
            </div>
            <div id="colorPickerImageInfo" class="image-info" style="display: none;">
                <p><strong>Filename:</strong> <span id="colorPickerFileName"></span></p>
                <p><strong>Dimensions:</strong> <span id="colorPickerDimensions"></span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Color Picker Bottom Ad)</p></div>
        </section>

        <!-- Image Watermark Tool Section (NEW) -->
        <section id="image-watermark-section" class="container" data-aos="fade-up">
            <h2>Image Watermark (Overlay)</h2>
            <p>Add an image watermark (e.g., your logo) to another image. Upload your main image first, then your watermark image.</p>
            
            <div class="file-input-container">
                <div id="watermarkMainImageDropZone" class="drop-zone">
                    <p>Drag & Drop your MAIN IMAGE here</p><p>or</p>
                    <label for="watermarkMainImageFile">Click to Upload Main Image</label>
                    <input type="file" id="watermarkMainImageFile" accept="image/*" aria-label="Select main image file">
                </div>
            </div>

            <div class="file-input-container" id="watermarkImageUploadContainer" style="display: none;">
                <div id="watermarkOverlayImageDropZone" class="drop-zone" style="max-width: 400px; min-height: 120px; padding: 1.5rem;">
                    <p>Drag & Drop your WATERMARK IMAGE here</p><p>or</p>
                    <label for="watermarkOverlayImageFile">Click to Upload Watermark Image</label>
                    <input type="file" id="watermarkOverlayImageFile" accept="image/png,image/jpeg,image/webp" aria-label="Select watermark image file">
                </div>
            </div>

            <div class="tool-controls pdf-customization-controls" id="watermarkControlsContainer" style="display: none;">
                <div class="control-group">
                    <label for="watermarkOpacitySlider">Opacity:</label>
                    <input type="range" id="watermarkOpacitySlider" min="0" max="1" step="0.05" value="0.5" style="max-width: 150px;">
                    <span id="watermarkOpacityValue">0.5</span>
                </div>
                <div class="control-group">
                    <label for="watermarkScaleSlider">Scale Watermark (% of main image width):</label>
                    <input type="range" id="watermarkScaleSlider" min="5" max="50" step="1" value="15" style="max-width: 150px;">
                    <span id="watermarkScaleValue">15%</span>
                </div>
                <div class="control-group">
                    <label for="watermarkPosition">Position:</label>
                    <select id="watermarkPosition">
                        <option value="bottom-right" selected>Bottom Right</option>
                        <option value="bottom-left">Bottom Left</option>
                        <option value="top-left">Top Left</option>
                        <option value="top-right">Top Right</option>
                        <option value="center">Center</option>
                        <option value="tile">Tile (Repeat)</option>
                    </select>
                </div>
                <button id="applyImageWatermarkBtn" class="btn" disabled>Apply Watermark</button>
            </div>

            <p id="imageWatermarkProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Image Watermark Top Ad)</p></div>

            <div id="imageWatermarkPreview" class="image-preview" style="display:none;">
                <h3>Preview</h3>
                <div class="preview-comparison">
                     <div><span class="preview-label">Original Main Image</span><img id="watermarkOriginalMainPreview" src="" alt="Original Main Image"></div>
                     <div><span class="preview-label">Watermarked Image</span><img id="watermarkedResultImage" src="" alt="Watermarked Result"></div>
                 </div>
            </div>
             <div id="imageWatermarkInfo" class="image-info" style="display:none;">
                <p><strong>Main Image:</strong> <span id="watermarkMainFileName"></span></p>
                <p><strong>Watermark Image:</strong> <span id="watermarkOverlayFileName"></span></p>
                <p><strong>Result Size:</strong> <span id="watermarkedResultSize">-</span></p>
            </div>
            <div class="download-section">
                <p id="imageWatermarkDownloadMessage" class="preview-success-message" style="display: none;">Your watermarked image is ready!</p>
                <a id="imageWatermarkDownloadLink" class="btn btn-success" style="display: none;">Download Watermarked Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Image Watermark Bottom Ad)</p></div>
        </section>


        <!-- JPG to PDF Tool Section -->
        <section id="jpg-to-pdf-section" class="container" data-aos="fade-up">
            <h2>JPG to PDF Converter</h2>
            <p>Convert multiple JPG images into a single PDF document.</p>
            <div class="file-input-container">
                <div id="jpgToPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your JPG images here</p><p>or</p>
                    <label for="jpgToPdfFilesInput">Click to Upload JPGs</label>
                    <input type="file" id="jpgToPdfFilesInput" accept="image/jpeg,image/jpg" multiple aria-label="Select JPG files for PDF conversion">
                </div>
            </div>
            <div id="jpgToPdfFileList" class="file-list-display">
                <h4>Selected JPG Files:</h4>
                <ul id="jpgToPdfFilesListUl"></ul>
            </div>
            <div class="tool-controls">
                <button id="convertToPdfBtn" class="btn" disabled>Convert to PDF</button>
            </div>
            <p id="jpgToPdfProcessingMsg" class="processing-message">Processing... This may take a moment for many images.</p>
            <div class="ad-container"><p>Advertisement Area (JPG to PDF Top Ad)</p></div>
             <div id="jpgToPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div>
                         <span class="preview-label">Selected JPGs</span>
                         <div id="jpgThumbnailsContainer" class="pdf-thumbnails-container"></div>
                     </div>
                     <div>
                         <span class="preview-label">Resulting PDF</span>
                          <embed id="jpgToPdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                          <p class="preview-success-message"></p>
                     </div>
                 </div>
             </div>
            <div id="jpgToPdfOutputInfo" class="output-info">
                <h3>Conversion Result</h3>
                <p><span id="jpgToPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="jpgToPdfDownloadMessage" class="preview-success-message" style="display: none;">Your PDF is ready!</p>
                <a id="jpgToPdfDownloadLink" class="btn btn-success" style="display: none;">Download PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (JPG to PDF Bottom Ad)</p></div>
        </section>

        <!-- PDF to JPG Tool Section -->
        <section id="pdf-to-jpg-section" class="container" data-aos="fade-up">
            <h2>PDF to JPG Converter</h2>
            <p>Convert each page of a PDF file into individual JPG images, downloaded as a ZIP file.</p>
            <div class="file-input-container">
                <div id="pdfToJpgDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfToJpgFileInput">Click to Upload PDF</label>
                    <input type="file" id="pdfToJpgFileInput" accept="application/pdf" aria-label="Select PDF file for JPG conversion">
                </div>
            </div>
             <div class="tool-controls">
                <button id="convertToJpgsBtn" class="btn" disabled>Convert to JPGs</button>
            </div>
            <p id="pdfToJpgProcessingMsg" class="processing-message">Processing PDF... This can take some time for large PDFs.</p>
             <div class="ad-container"><p>Advertisement Area (PDF to JPG Top Ad)</p></div>
             <div id="pdfToJpgPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                      <div>
                         <span class="preview-label">Original PDF (First Page)</span>
                         <img id="pdfOriginalFirstPagePreview" src="" alt="PDF First Page Preview">
                      </div>
                      <div>
                         <span class="preview-label">Resulting JPGs (Preview)</span>
                          <div id="pdfResultThumbnailsContainer" class="pdf-thumbnails-container"></div>
                          <p class="preview-success-message"></p>
                      </div>
                 </div>
             </div>
             <div id="pdfToJpgFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="pdfToJpgFileName"></span></p>
                <p><strong>Size:</strong> <span id="pdfToJpgFileSize"></span></p>
                <p><strong>Pages:</strong> <span id="pdfToJpgPageCount">?</span></p>
            </div>
            <div id="pdfToJpgOutputInfo" class="output-info">
                <h3>Conversion Result</h3>
                <p><span id="pdfToJpgResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="pdfToJpgDownloadMessage" class="preview-success-message" style="display: none;">Your JPG images (ZIP) are ready!</p>
                <a id="pdfToJpgDownloadLink" class="btn btn-success" style="display: none;">Download JPGs (ZIP)</a>
            </div>
             <div class="ad-container"><p>Advertisement Area (PDF to JPG Bottom Ad)</p></div>
        </section>

        <!-- Merge PDF Tool Section -->
        <section id="merge-pdf-section" class="container" data-aos="fade-up">
            <h2>Merge PDF Files</h2>
            <p>Combine multiple PDF documents into a single PDF file.</p>
            <div class="file-input-container">
                <div id="mergePdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF files here (2 or more)</p><p>or</p>
                    <label for="mergePdfFilesInput">Click to Upload PDFs</label>
                    <input type="file" id="mergePdfFilesInput" accept="application/pdf" multiple aria-label="Select PDF files to merge">
                </div>
            </div>
            <div id="mergePdfFileList" class="file-list-display">
                <h4>Selected PDF Files (Order determines merge order):</h4>
                <ul id="mergePdfFilesListUl"></ul>
                 <p style="font-size: 0.85em; margin-top: 0.5em;">(Note: Currently, reordering is not supported. Upload in desired merge order.)</p>
            </div>
            <div class="tool-controls">
                <button id="mergePdfsBtn" class="btn" disabled>Merge PDFs</button>
            </div>
            <p id="mergePdfProcessingMsg" class="processing-message">Processing... Merging PDFs can take time.</p>
            <div class="ad-container"><p>Advertisement Area (Merge PDF Top Ad)</p></div>
            <div id="mergePdfPreviewContainer" class="pdf-tool-preview">
                <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div>
                         <span class="preview-label">Selected PDFs</span>
                         <div class="pdf-thumbnails-container" style="text-align: left; min-height:50px; display:flex; align-items:center; justify-content:center;">
                             <p><i>Files listed above will be merged in order. No individual previews shown here.</i></p>
                         </div>
                     </div>
                     <div>
                         <span class="preview-label">Merged PDF Result</span>
                          <embed id="mergePdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                          <p class="preview-success-message"></p>
                     </div>
                 </div>
            </div>
            <div id="mergePdfOutputInfo" class="output-info">
                <h3>Merge Result</h3>
                <p><span id="mergePdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="mergePdfDownloadMessage" class="preview-success-message" style="display: none;">Your merged PDF is ready!</p>
                <a id="mergePdfDownloadLink" class="btn btn-success" style="display: none;">Download Merged PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Merge PDF Bottom Ad)</p></div>
        </section>

        <!-- Split PDF Tool Section -->
        <section id="split-pdf-section" class="container" data-aos="fade-up">
            <h2>Split PDF File</h2>
            <p>Extract specific pages or ranges from a PDF document into a new PDF.</p>
            <div class="file-input-container">
                <div id="splitPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="splitPdfFileInput">Click to Upload PDF</label>
                    <input type="file" id="splitPdfFileInput" accept="application/pdf" aria-label="Select PDF file to split">
                </div>
            </div>
             <div class="tool-controls split-controls">
                <label for="splitPageRange">Pages/Ranges (e.g., 1, 3-5, 8):</label>
                <input type="text" id="splitPageRange" placeholder="1, 3-5, 8" disabled>
                <button id="splitPdfBtn" class="btn" disabled>Split PDF</button>
            </div>
            <p id="splitPdfProcessingMsg" class="processing-message">Processing... Splitting PDF.</p>
             <div class="ad-container"><p>Advertisement Area (Split PDF Top Ad)</p></div>
             <div id="splitPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                      <div>
                         <span class="preview-label">Original PDF (First Page)</span>
                         <img id="splitPdfOriginalPreview" src="" alt="Original PDF Preview">
                      </div>
                      <div>
                         <span class="preview-label">Split PDF Result</span>
                         <embed id="splitPdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                         <p class="preview-success-message"></p>
                      </div>
                 </div>
             </div>
             <div id="splitPdfFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="splitPdfFileName"></span></p>
                <p><strong>Size:</strong> <span id="splitPdfFileSize"></span></p>
                <p><strong>Total Pages:</strong> <span id="splitPdfTotalPages">?</span></p>
            </div>
            <div id="splitPdfOutputInfo" class="output-info">
                <h3>Split Result</h3>
                <p><span id="splitPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="splitPdfDownloadMessage" class="preview-success-message" style="display: none;">Your split PDF is ready!</p>
                <a id="splitPdfDownloadLink" class="btn btn-success" style="display: none;">Download Split PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Split PDF Bottom Ad)</p></div>
        </section>

        <!-- Organize PDF Tool Section -->
        <section id="organize-pdf-section" class="container" data-aos="fade-up">
            <h2>Organize PDF Pages</h2>
            <p>Reorder or delete pages from your PDF document. Drag thumbnails to reorder, click 'X' to mark for deletion.</p>
            <div class="file-input-container">
                <div id="organizePdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="organizePdfFileInput">Click to Upload PDF</label>
                    <input type="file" id="organizePdfFileInput" accept="application/pdf" aria-label="Select PDF file to organize">
                </div>
            </div>
            <div class="tool-controls">
                <button id="processOrganizePdfBtn" class="btn" disabled>Apply Changes & Create PDF</button>
            </div>
            <p id="organizePdfProcessingMsg" class="processing-message">Processing PDF...</p>
            <div class="ad-container"><p>Advertisement Area (Organize PDF Top Ad)</p></div>

            <div id="organizePdfPagesContainer" class="pdf-tool-preview" style="display: none;">
                <h3>Organize Pages:</h3>
                <p style="font-size: 0.9em; color: var(--secondary-color);">Drag thumbnails to reorder. Click the 'X' to mark a page for deletion (it will turn red). Click again to unmark.</p>
                <div id="organizePageThumbnails" class="pdf-thumbnails-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; min-height: 150px; max-height: 600px; overflow-y: auto;">
                    <!-- Thumbnails will be dynamically inserted here -->
                </div>
            </div>

            <div id="organizePdfFileInfo" class="image-info" style="display:none;">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="organizePdfFileName"></span></p>
                <p><strong>Original Pages:</strong> <span id="organizePdfOriginalPageCount"></span></p>
            </div>
            <div id="organizePdfOutputInfo" class="output-info" style="display:none;">
                <h3>Result</h3>
                <p><span id="organizePdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="organizePdfDownloadMessage" class="preview-success-message" style="display: none;">Your organized PDF is ready!</p>
                <a id="organizePdfDownloadLink" class="btn btn-success" style="display: none;">Download Organized PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Organize PDF Bottom Ad)</p></div>
        </section>

        <!-- Rotate PDF Tool Section -->
        <section id="rotate-pdf-section" class="container" data-aos="fade-up">
            <h2>Rotate PDF Pages</h2>
            <p>Rotate all pages in your PDF document by 90 degrees clockwise or counter-clockwise.</p>
            <div class="file-input-container">
                <div id="rotatePdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="rotatePdfFileInput">Click to Upload PDF</label>
                    <input type="file" id="rotatePdfFileInput" accept="application/pdf" aria-label="Select PDF file to rotate">
                </div>
            </div>
            <div class="tool-controls rotate-pdf-controls">
                 <button id="rotatePdfLeftBtn" class="btn btn-secondary" disabled><i class="rotate-icon">↺</i> Rotate All Left 90°</button>
                 <button id="rotatePdfRightBtn" class="btn btn-secondary" disabled><i class="rotate-icon">↻</i> Rotate All Right 90°</button>
                 <button id="applyRotationBtn" class="btn" disabled>Apply Rotation & Download</button>
            </div>
            <p id="rotatePdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Rotate PDF Top Ad)</p></div>

            <div id="rotatePdfPreviewContainer" class="pdf-tool-preview" style="display: none;">
                 <h3>Preview (First Page - Rotated)</h3>
                 <div style="max-width: 500px; margin: auto; border: 1px solid var(--border-color); padding: 10px; background-color: var(--light-bg); border-radius: var(--border-radius-sm);">
                     <img id="rotatePdfPagePreview" src="" alt="Rotated PDF First Page Preview" style="max-width: 100%; height: auto; display: none;"> <!-- Hide initially -->
                     <p>Current Rotation: <span id="currentRotationAngleDisplay">0</span>°</p>
                 </div>
            </div>

            <div id="rotatePdfFileInfo" class="image-info" style="display:none;">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="rotatePdfFileName"></span></p>
                <p><strong>Original Pages:</strong> <span id="rotatePdfPageCount"></span></p>
                 <p><strong>Status:</strong> <span id="rotatePdfStatus">Ready</span></p>
            </div>
             <div id="rotatePdfOutputInfo" class="output-info" style="display:none;">
                <h3>Result</h3>
                <p><span id="rotatePdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="rotatePdfDownloadMessage" class="preview-success-message" style="display: none;">Your rotated PDF is ready!</p>
                <a id="rotatePdfDownloadLink" class="btn btn-success" style="display: none;">Download Rotated PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Rotate PDF Bottom Ad)</p></div>
        </section>

        <!-- Add Page Numbers to PDF Tool Section -->
        <section id="add-page-numbers-pdf-section" class="container" data-aos="fade-up">
            <h2>Add Page Numbers to PDF</h2>
            <p>Automatically add page numbers to your PDF document.</p>
            <div class="file-input-container">
                <div id="addPageNumbersPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="addPageNumbersPdfFile">Click to Upload PDF</label>
                    <input type="file" id="addPageNumbersPdfFile" accept="application/pdf" aria-label="Select PDF file to add page numbers">
                </div>
            </div>
            <div class="tool-controls pdf-customization-controls">
                <div class="control-group">
                    <label for="pageNumFontSize">Font Size:</label>
                    <input type="number" id="pageNumFontSize" value="12" min="6" max="72">
                </div>
                <div class="control-group">
                    <label for="pageNumPosition">Position:</label>
                    <select id="pageNumPosition">
                        <option value="bottom-center" selected>Bottom Center</option>
                        <option value="bottom-left">Bottom Left</option>
                        <option value="bottom-right">Bottom Right</option>
                        <option value="top-center">Top Center</option>
                        <option value="top-left">Top Left</option>
                        <option value="top-right">Top Right</option>
                    </select>
                </div>
                <button id="addPageNumbersPdfBtn" class="btn" disabled>Add Page Numbers</button>
            </div>
            <p id="addPageNumbersPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Add Page Numbers Top Ad)</p></div>

            <div id="addPageNumbersPdfPreviewContainer" class="pdf-tool-preview">
                <h3>Preview (First Page with Number)</h3>
                <embed id="addPageNumbersPdfResultEmbed" type="application/pdf" class="pdf-embed-preview">
                <p class="preview-success-message"></p>
            </div>
            <div id="addPageNumbersPdfFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="addPageNumbersPdfFileName"></span></p>
                <p><strong>Pages:</strong> <span id="addPageNumbersPdfPageCount"></span></p>
            </div>
            <div id="addPageNumbersPdfOutputInfo" class="output-info">
                <h3>Result</h3>
                <p><span id="addPageNumbersPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="addPageNumbersPdfDownloadMessage" class="preview-success-message" style="display: none;">PDF with page numbers is ready!</p>
                <a id="addPageNumbersPdfDownloadLink" class="btn btn-success" style="display: none;">Download PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Add Page Numbers Bottom Ad)</p></div>
        </section>

        <!-- Add Text Watermark to PDF Tool Section -->
        <section id="add-text-watermark-pdf-section" class="container" data-aos="fade-up">
            <h2>Add Text Watermark to PDF</h2>
            <p>Apply a text watermark to all pages of your PDF document.</p>
            <div class="file-input-container">
                <div id="addWatermarkPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="addWatermarkPdfFile">Click to Upload PDF</label>
                    <input type="file" id="addWatermarkPdfFile" accept="application/pdf" aria-label="Select PDF file to add watermark">
                </div>
            </div>
            <div class="tool-controls pdf-customization-controls">
                <div class="control-group">
                    <label for="watermarkText">Watermark Text:</label>
                    <input type="text" id="watermarkText" value="CONFIDENTIAL" placeholder="Your Text Here">
                </div>
                <div class="control-group">
                    <label for="watermarkFontSize">Font Size:</label>
                    <input type="number" id="watermarkFontSize" value="48" min="10" max="150">
                </div>
                 <div class="control-group">
                    <label for="watermarkOpacity">Opacity (0-1):</label>
                    <input type="number" id="watermarkOpacity" value="0.3" min="0.1" max="1" step="0.1">
                </div>
                <button id="addWatermarkPdfBtn" class="btn" disabled>Add Watermark</button>
            </div>
            <p id="addWatermarkPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Add Watermark Top Ad)</p></div>

            <div id="addWatermarkPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview (First Page with Watermark)</h3>
                 <embed id="addWatermarkPdfResultEmbed" type="application/pdf" class="pdf-embed-preview">
                 <p class="preview-success-message"></p>
            </div>
            <div id="addWatermarkPdfFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="addWatermarkPdfFileName"></span></p>
                <p><strong>Pages:</strong> <span id="addWatermarkPdfPageCount"></span></p>
            </div>
            <div id="addWatermarkPdfOutputInfo" class="output-info">
                <h3>Result</h3>
                <p><span id="addWatermarkPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="addWatermarkPdfDownloadMessage" class="preview-success-message" style="display: none;">PDF with watermark is ready!</p>
                <a id="addWatermarkPdfDownloadLink" class="btn btn-success" style="display: none;">Download PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Add Watermark Bottom Ad)</p></div>
        </section>

        <!-- Compress PDF Tool Section -->
        <section id="compress-pdf-section" class="container" data-aos="fade-up">
            <h2>Compress PDF</h2>
            <p>Reduce PDF file size. Results may vary based on PDF content. This tool primarily optimizes PDF structure and stream compression.</p>
            <div class="file-input-container">
                <div id="compressPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="compressPdfFile">Click to Upload PDF</label>
                    <input type="file" id="compressPdfFile" accept="application/pdf" aria-label="Select PDF file to compress">
                </div>
            </div>
            <div class="tool-controls pdf-customization-controls">
                 <div class="control-group">
                    <label for="pdfCompressionLevel">Optimization Level (0-9):</label>
                    <input type="range" id="pdfCompressionLevel" min="0" max="9" value="6" style="max-width: 200px;">
                    <span id="pdfCompressionLevelValue">6</span>
                </div>
                <button id="compressPdfBtn" class="btn" disabled>Compress PDF</button>
            </div>
            <p id="compressPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Compress PDF Top Ad)</p></div>

            <div id="compressPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview (Original First Page)</h3>
                 <embed id="compressPdfOriginalEmbed" type="application/pdf" class="pdf-embed-preview" style="max-height:300px;">
                 <p class="preview-success-message"></p>
            </div>
            <div id="compressPdfFileInfo" class="image-info">
                <h3>PDF Information:</h3>
                <p><strong>Filename:</strong> <span id="compressPdfFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="compressPdfOriginalSize"></span></p>
                <p><strong>Pages:</strong> <span id="compressPdfPageCount"></span></p>
            </div>
            <div id="compressPdfOutputInfo" class="output-info">
                <h3>Compression Result:</h3>
                <p><strong>New Size:</strong> <span id="compressedPdfNewSize">-</span></p>
                <p><strong>Reduction:</strong> <span id="compressedPdfSizeReduction">-</span></p>
            </div>
            <div class="download-section">
                <p id="compressPdfDownloadMessage" class="preview-success-message" style="display: none;">Compressed PDF is ready!</p>
                <a id="compressPdfDownloadLink" class="btn btn-success" style="display: none;">Download Compressed PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Compress PDF Bottom Ad)</p></div>
        </section>

        <!-- PDF to Word Tool Section (Using API) -->
        <section id="pdf-to-word-section" class="container" data-aos="fade-up">
            <h2>PDF to Word Converter</h2>
            <p>Easily convert your PDF files into easy to edit DOC and DOCX documents using a powerful cloud API.</p>
            <div class="file-input-container">
                <div id="pdfToWordDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfToWordFile">Click to Upload PDF</label>
                    <input type="file" id="pdfToWordFile" accept="application/pdf" aria-label="Select PDF file for Word conversion">
                </div>
            </div>
            <div class="tool-controls">
                <button id="convertToWordBtn" class="btn" disabled>Convert to Word</button>
            </div>
            <p id="pdfToWordProcessingMsg" class="processing-message">Processing...</p>
            <div id="pdfToWordFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="pdfToWordFileName"></span></p>
            </div>
            <div class="download-section" style="text-align: center; margin-top: 1rem;">
                <a id="pdfToWordDownloadLink" class="btn btn-success" style="display: none;">Download Word Document</a>
                <p id="pdfToWordDownloadMessage" class="preview-success-message" style="display:none;">Your Word document is ready!</p>
            </div>
            <div id="pdfToWordPlaceholderMessage" class="placeholder-message" style="display: none;">
                An error occurred with the conversion service. Please try again later.
            </div>
            <div class="ad-container"><p>Advertisement Area (PDF to Word Ad)</p></div>
        </section>

        <!-- PDF to PowerPoint Tool Section (API) -->
        <section id="pdf-to-powerpoint-section" class="container" data-aos="fade-up">
            <h2>PDF to PowerPoint Converter</h2>
            <p>Turn your PDF files into easy to edit PPT and PPTX slideshows (API integration).</p>
            <div class="file-input-container">
                <div id="pdfToPowerPointDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfToPowerPointFile">Click to Upload PDF</label>
                    <input type="file" id="pdfToPowerPointFile" accept="application/pdf" aria-label="Select PDF file for PowerPoint conversion">
                </div>
            </div>
            <div class="tool-controls">
                <button id="convertToPowerPointBtn" class="btn" disabled>Convert to PowerPoint</button>
            </div>
            <p id="pdfToPowerPointProcessingMsg" class="processing-message">Processing...</p>
             <div id="pdfToPowerPointFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="pdfToPowerPointFileName"></span></p>
            </div>
             <div class="download-section" style="text-align: center; margin-top: 1rem;">
                <a id="pdfToPowerPointDownloadLink" class="btn btn-success" style="display: none;">Download PowerPoint</a>
                <p id="pdfToPowerPointDownloadMessage" class="preview-success-message" style="display:none;">Your PowerPoint is ready!</p>
            </div>
            <div id="pdfToPowerPointPlaceholderMessage" class="placeholder-message" style="display: none;">
                This tool uses a cloud API for conversion.
            </div>
            <div class="ad-container"><p>Advertisement Area (PDF to PowerPoint Ad)</p></div>
        </section>

        <!-- PDF to Excel Tool Section (API) -->
        <section id="pdf-to-excel-section" class="container" data-aos="fade-up">
            <h2>PDF to Excel Converter</h2>
            <p>Pull data straight from PDFs into Excel spreadsheets in a few clicks (API integration).</p>
            <div class="file-input-container">
                <div id="pdfToExcelDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfToExcelFile">Click to Upload PDF</label>
                    <input type="file" id="pdfToExcelFile" accept="application/pdf" aria-label="Select PDF file for Excel conversion">
                </div>
            </div>
            <div class="tool-controls">
                <button id="convertToExcelBtn" class="btn" disabled>Convert to Excel</button>
            </div>
            <p id="pdfToExcelProcessingMsg" class="processing-message">Processing...</p>
            <div id="pdfToExcelFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="pdfToExcelFileName"></span></p>
            </div>
            <div class="download-section" style="text-align: center; margin-top: 1rem;">
                <a id="pdfToExcelDownloadLink" class="btn btn-success" style="display: none;">Download Excel</a>
                <p id="pdfToExcelDownloadMessage" class="preview-success-message" style="display:none;">Your Excel file is ready!</p>
            </div>
            <div id="pdfToExcelPlaceholderMessage" class="placeholder-message" style="display: none;">
                 This tool uses a cloud API for conversion.
            </div>
            <div class="ad-container"><p>Advertisement Area (PDF to Excel Ad)</p></div>
        </section>

        <!-- Protect PDF Tool Section (NEW) -->
        <section id="protect-pdf-section" class="container" data-aos="fade-up">
            <h2>Protect PDF (Add Password)</h2>
            <p>Secure your PDF file by adding a password. The same password will be used for user and owner.</p>
            <div class="file-input-container">
                <div id="protectPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="protectPdfFile">Click to Upload PDF</label>
                    <input type="file" id="protectPdfFile" accept="application/pdf" aria-label="Select PDF file to protect">
                </div>
            </div>
            <div class="tool-controls pdf-customization-controls">
                <div class="control-group">
                    <label for="protectPdfPassword">Password:</label>
                    <input type="password" id="protectPdfPassword" placeholder="Enter password" style="max-width: 200px;">
                </div>
                <button id="protectPdfBtn" class="btn" disabled>Protect PDF</button>
            </div>
            <p id="protectPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Protect PDF Top Ad)</p></div>
            <div id="protectPdfFileInfo" class="image-info" style="display:none;">
                <p><strong>Filename:</strong> <span id="protectPdfFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="protectPdfOriginalSize"></span></p>
            </div>
            <div id="protectPdfOutputInfo" class="output-info" style="display:none;">
                <p><strong>Result:</strong> <span id="protectPdfResultText"></span></p>
                <p><strong>New Size:</strong> <span id="protectPdfNewSize"></span></p>
            </div>
            <div class="download-section">
                <p id="protectPdfDownloadMessage" class="preview-success-message" style="display: none;">Protected PDF is ready!</p>
                <a id="protectPdfDownloadLink" class="btn btn-success" style="display: none;">Download Protected PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Protect PDF Bottom Ad)</p></div>
        </section>

        <!-- Unlock PDF Tool Section (NEW) -->
        <section id="unlock-pdf-section" class="container" data-aos="fade-up">
            <h2>Unlock PDF (Remove Password)</h2>
            <p>Remove password protection from a PDF file. You must provide the current password.</p>
            <div class="file-input-container">
                <div id="unlockPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="unlockPdfFile">Click to Upload PDF</label>
                    <input type="file" id="unlockPdfFile" accept="application/pdf" aria-label="Select PDF file to unlock">
                </div>
            </div>
            <div class="tool-controls pdf-customization-controls">
                <div class="control-group">
                    <label for="unlockPdfPassword">Current Password:</label>
                    <input type="password" id="unlockPdfPassword" placeholder="Enter current password" style="max-width: 200px;">
                </div>
                <button id="unlockPdfBtn" class="btn" disabled>Unlock PDF</button>
            </div>
            <p id="unlockPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Unlock PDF Top Ad)</p></div>
            <div id="unlockPdfFileInfo" class="image-info" style="display:none;">
                <p><strong>Filename:</strong> <span id="unlockPdfFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="unlockPdfOriginalSize"></span></p>
            </div>
            <div id="unlockPdfOutputInfo" class="output-info" style="display:none;">
                <p><strong>Result:</strong> <span id="unlockPdfResultText"></span></p>
                <p><strong>New Size:</strong> <span id="unlockPdfNewSize"></span></p>
            </div>
            <div class="download-section">
                <p id="unlockPdfDownloadMessage" class="preview-success-message" style="display: none;">Unlocked PDF is ready!</p>
                <a id="unlockPdfDownloadLink" class="btn btn-success" style="display: none;">Download Unlocked PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Unlock PDF Bottom Ad)</p></div>
        </section>

        <!-- PDF Metadata Viewer/Editor Tool Section (NEW) -->
        <section id="pdf-metadata-section" class="container" data-aos="fade-up">
            <h2>PDF Metadata Viewer/Editor</h2>
            <p>View and edit basic metadata properties of your PDF document.</p>
            <div class="file-input-container">
                <div id="pdfMetadataDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfMetadataFile">Click to Upload PDF</label>
                    <input type="file" id="pdfMetadataFile" accept="application/pdf" aria-label="Select PDF file for metadata">
                </div>
            </div>
            <p id="pdfMetadataProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Metadata Top Ad)</p></div>
            <div id="pdfMetadataDisplayArea" class="metadata-display-area" style="display: none;">
                <h3>PDF Metadata: <span id="pdfMetadataFileNameDisplay" style="font-weight:normal; color:var(--secondary-color)"></span></h3>
                <div class="metadata-entry">
                    <label for="metaTitle">Title:</label> <input type="text" id="metaTitle">
                </div>
                <div class="metadata-entry">
                    <label for="metaAuthor">Author:</label> <input type="text" id="metaAuthor">
                </div>
                <div class="metadata-entry">
                    <label for="metaSubject">Subject:</label> <input type="text" id="metaSubject">
                </div>
                <div class="metadata-entry">
                    <label for="metaKeywords">Keywords (comma-sep):</label> <input type="text" id="metaKeywords">
                </div>
                <div class="metadata-entry">
                    <label>Creator:</label> <span id="metaCreator">-</span>
                </div>
                <div class="metadata-entry">
                    <label>Producer:</label> <span id="metaProducer">-</span>
                </div>
                <div class="metadata-entry">
                    <label>Creation Date:</label> <span id="metaCreationDate">-</span>
                </div>
                <div class="metadata-entry">
                    <label>Modification Date:</label> <span id="metaModDate">-</span>
                </div>
                <div style="text-align:center; margin-top:1.5rem;">
                    <button id="savePdfMetadataBtn" class="btn" disabled>Save Changes to New PDF</button>
                </div>
            </div>
            <div id="pdfMetadataOutputInfo" class="output-info" style="display:none;">
                <p><strong>Result:</strong> <span id="pdfMetadataResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="pdfMetadataDownloadMessage" class="preview-success-message" style="display: none;">PDF with updated metadata is ready!</p>
                <a id="pdfMetadataDownloadLink" class="btn btn-success" style="display: none;">Download Updated PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Metadata Bottom Ad)</p></div>
        </section>

        <!-- HTML to PDF Tool Section (NEW) -->
        <section id="html-to-pdf-section" class="container" data-aos="fade-up">
            <h2>HTML to PDF Converter</h2>
            <p>Paste your HTML code into the textarea below and convert it to a PDF document. Basic HTML and CSS are supported. Complex layouts might have issues.</p>
            <div class="tool-controls" style="flex-direction: column; align-items: stretch;">
                <label for="htmlToPdfInputArea" style="margin-bottom: 0.5rem;">HTML Content:</label>
                <textarea id="htmlToPdfInputArea" placeholder="Paste your HTML code here..." style="min-height: 200px; width: 100%;"></textarea>
            </div>
            <div class="tool-controls">
                <button id="convertToPdfFromHtmlBtn" class="btn" disabled>Convert HTML to PDF</button>
            </div>
            <p id="htmlToPdfProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (HTML to PDF Top Ad)</p></div>
            <div id="htmlToPdfPreviewContainer" class="pdf-tool-preview" style="display:none;">
                <h3>Generated PDF Preview</h3>
                <embed id="htmlToPdfResultEmbed" type="application/pdf" class="pdf-embed-preview">
                <p class="preview-success-message"></p>
            </div>
            <div id="htmlToPdfOutputInfo" class="output-info" style="display:none;">
                <p><strong>Result:</strong> <span id="htmlToPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="htmlToPdfDownloadMessage" class="preview-success-message" style="display: none;">Your PDF from HTML is ready!</p>
                <a id="htmlToPdfDownloadLink" class="btn btn-success" style="display: none;">Download PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (HTML to PDF Bottom Ad)</p></div>
        </section>


        <!-- About, Contact, Privacy Sections -->
        <section id="about-section" class="container" data-aos="fade-up">
             <h2>About Us</h2>
            <p>Welcome to FreeImagePDFTools, your one-stop destination for free and easy-to-use online image and PDF tools. Our mission is to provide simple, fast, and effective tools to help you manage your digital files without needing to download complex software.</p>
            <p>We are constantly working on adding new tools and improving the existing ones based on your feedback. Whether you need to compress images for your website, resize a photo for social media, convert formats (JPG, PNG, WebP), crop, rotate, flip, apply filters, pick colors from images, add image watermarks, convert JPGs to PDF, extract JPGs from a PDF, merge multiple PDFs, split or organize a PDF, rotate a PDF, convert images to Base64, Base64 back to images, add page numbers to your PDFs, apply text watermarks, compress PDFs, protect PDFs with passwords, unlock PDFs, view/edit PDF metadata, or convert HTML to PDF – we aim to make it as straightforward as possible.</p>
            <p>Thank you for using our tools!</p>
            <div class="ad-container"><p>Advertisement Area (About Page Ad)</p></div>
        </section>
        <section id="contact-section" class="container" data-aos="fade-up">
             <h2>Contact Us</h2>
            <p>Have questions, feedback, or suggestions for new tools? We'd love to hear from you!</p>
            <form id="contactForm" action="#" method="POST">
                <div><label for="name">Name:</label><input type="text" id="name" name="name" required></div>
                <div><label for="email">Email:</label><input type="email" id="email" name="email" required></div>
                <div><label for="message">Message:</label><textarea id="message" name="message" required></textarea></div>
                <button type="submit" class="btn">Send Message</button>
            </form>
            <p style="text-align: center; margin-top: 1rem; font-size: 0.9rem;">(Note: This form is a placeholder and requires server-side integration to send emails.)</p>
            <div class="ad-container"><p>Advertisement Area (Contact Page Ad)</p></div>
        </section>
        <section id="privacy-section" class="container" data-aos="fade-up">
             <h2>Privacy Policy</h2>
            <p>Your privacy is important to us. This policy explains how we handle information on our website.</p>
            <h3>What information do we collect?</h3>
            <p>We do not collect any personally identifiable information from you unless you voluntarily provide it (e.g., via the contact form). Our tools process files entirely in your browser; your files are not uploaded to our servers unless explicitly stated for a specific API-based tool (like PDF to Word, PowerPoint, Excel which uses a third-party cloud service for conversion).</p>
            <h3>How do we use your information?</h3>
            <p>Any information you provide via the contact form is used solely to respond to your inquiry. We do not share, sell, or rent your personal information to third parties. For API-based tools, files are sent to the respective third-party service for processing and are subject to their privacy policies.</p>
            <h3>Cookies and Tracking</h3>
            <p>We may use standard website tracking technologies (like Google Analytics - if implemented) to understand how the site is used in aggregate, which helps us improve our services. These tools typically collect non-personally identifiable information such as browser type, pages visited, and time spent on the site.</p>
            <p>Advertisement partners (like Google AdSense) may use cookies to serve ads based on your visit to this and other sites. You can opt out of personalized advertising by visiting Ads Settings.</p>
            <h3>Third-Party Links</h3>
            <p>This website may contain links to other sites. We are not responsible for the privacy practices or the content of such other sites.</p>
            <h3>Your Consent</h3>
            <p>By using our site, you consent to our privacy policy.</p>
            <h3>Changes to our Privacy Policy</h3>
            <p>If we decide to change our privacy policy, we will post those changes on this page.</p>
             <p>This policy was last updated on May 10, 2024.</p>
            <div class="ad-container"><p>Advertisement Area (Privacy Page Ad)</p></div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023-2025 FreeImagePDFTools. All rights reserved.</p>
            <p><a href="#privacy-section">Privacy Policy</a>&nbsp;|&nbsp;<a href="#contact-section">Contact Us</a>&nbsp;|&nbsp;<a href="#about-section">About</a></p>
        </div>
    </footer>

    <!-- Libraries -->
     <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script> 
     <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
     <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- Main Application Script -->
    <script>
        (function() {
            AOS.init({ duration: 800, easing: 'ease-in-out', once: true, mirror: false });
			
            const CLOUDCONVERT_API_KEY = 'YOUR_API_KEY_HERE_FOR_LOCAL_TESTING_ONLY'; 


            function formatBytes(bytes, decimals = 2) {
                if (!bytes || bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = bytes < 1 ? 0 : Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            const toolState = {}; 

            let finalScaledCrop = null;
            let currentRotationAngle = 0; let currentFlipH = false; let currentFlipV = false;
            let splitPdfDocObject = null;
            let organizePdfDocObject = null;
            let organizePageData = [];
            let rotatePdfCurrentAngle = 0;


            let pdfjsLibInstance = null;
            let pdfLibInstance = null;
            let jspdfInstance = null;
            let jszipInstance = null;
            let domPurifyInstance = null; 
            let html2canvasInstance = null; 

            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            document.addEventListener('dragover', preventDefaults, false);
            document.addEventListener('drop', preventDefaults, false);

            document.addEventListener('DOMContentLoaded', () => {
                initializeLibraries();
                setupNavigation();
                initializeAllToolListeners();
                setupContactForm();
                setupBlobCleanup();
            });

            function initializeLibraries() {
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLibInstance = pdfjsLib;
                    pdfjsLibInstance.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
                    console.log("[LIB] pdf.js initialized.");
                } else { console.error("[LIB] pdfjsLib is not defined."); }

                if (typeof PDFLib !== 'undefined') {
                    pdfLibInstance = PDFLib;
                    console.log("[LIB] pdf-lib initialized.");
                } else { console.error("[LIB] PDFLib is not defined."); }

                if (typeof jspdf !== 'undefined') {
                    jspdfInstance = jspdf;
                    console.log("[LIB] jsPDF initialized.");
                } else { console.error("[LIB] jspdf is not defined."); }

                 if (typeof JSZip !== 'undefined') {
                    jszipInstance = JSZip;
                    console.log("[LIB] JSZip initialized.");
                } else { console.error("[LIB] JSZip is not defined."); }

                if (typeof DOMPurify !== 'undefined') { 
                    domPurifyInstance = DOMPurify;
                    console.log("[LIB] DOMPurify initialized.");
                } else { console.warn("[LIB] DOMPurify is not defined. HTML to PDF may fail."); }
                
                 if (typeof html2canvas !== 'undefined') { 
                    html2canvasInstance = html2canvas;
                    console.log("[LIB] html2canvas initialized.");
                } else { console.warn("[LIB] html2canvas is not defined. HTML to PDF may fail."); }
            }

             function setupNavigation() {
                const sections = document.querySelectorAll('main > section');
                const navLinks = document.querySelectorAll('header nav a, #homepage-section a.tool-link, #homepage-section .tool-card h3 a, footer a[href^="#"]');
                const navLinkElements = Array.from(document.querySelectorAll('header nav > ul > li > a:not(.dropbtn), header nav .dropdown-content a')); 
                let currentActiveSectionId = null;

                function updateActiveLink(targetId) {
                    document.querySelectorAll('header nav ul li.dropdown .dropbtn.active-parent-dropdown').forEach(btn => {
                        btn.classList.remove('active-parent-dropdown');
                    });

                    navLinkElements.forEach(link => {
                        if (link.getAttribute('href') === `#${targetId}`) {
                            link.classList.add('active-link');
                            const parentDropdown = link.closest('.dropdown');
                            if (parentDropdown) {
                                parentDropdown.querySelector('.dropbtn')?.classList.add('active-parent-dropdown');
                            }
                        } else {
                            link.classList.remove('active-link');
                        }
                    });
                }


                function showSection(id) {
                    const targetId = id.startsWith('#') ? id.substring(1) : id;
                    const targetSection = document.getElementById(targetId);

                    if (!targetSection) {
                        console.warn(`[NAV] Section "${targetId}" not found. Defaulting home.`);
                        if (targetId !== 'homepage-section') showSection('homepage-section');
                        else console.error("[NAV] Homepage section missing.");
                        return;
                    }

                    if (currentActiveSectionId && currentActiveSectionId !== targetId) {
                        const oldSectionElement = document.getElementById(currentActiveSectionId);
                        const isOldSectionTool = oldSectionElement?.querySelector('.tool-controls') || oldSectionElement?.querySelector('.file-input-container') || currentActiveSectionId === 'base64-to-image-section' || currentActiveSectionId === 'html-to-pdf-section';
                        const isOldSectionStatic = ['about-section', 'contact-section', 'privacy-section', 'homepage-section'].includes(currentActiveSectionId);

                        if (isOldSectionTool && !isOldSectionStatic) {
                            resetToolState(currentActiveSectionId.replace('-section', ''));
                        }
                    }

                    sections.forEach(section => { section.style.display = (section.id === targetId) ? 'block' : 'none'; });

                    if (document.getElementById(targetId)?.style.display === 'block') {
                         AOS.refreshHard();
                         updateActiveLink(targetId);
                         const headerHeight = document.querySelector('header')?.offsetHeight || 70;
                         if (currentActiveSectionId !== targetId) { 
                            setTimeout(() => window.scrollTo({ top: Math.max(0, targetSection.offsetTop - headerHeight), behavior: 'smooth'}), 50);
                         }
                    }
                    currentActiveSectionId = targetId;
                    if (targetId === 'base64-to-image-section' && !toolState['base64-to-image']?.isInitialized) {
                        setupBase64ToImageUI(); 
                    }
                    if (targetId === 'html-to-pdf-section' && !toolState['html-to-pdf']?.isInitialized) {
                        setupHtmlToPdfUI();
                    }
                }

                function handleNavigation() {
                    let hash = window.location.hash;
                    if (!hash || hash === '#' || !document.getElementById(hash.substring(1))) {
                        hash = '#homepage-section';
                    }
                    showSection(hash);
                    if (hash.startsWith('#')) updateActiveLink(hash.substring(1));
                }

                navLinks.forEach(anchor => {
                    anchor.addEventListener('click', function (e) {
                        const targetHash = this.getAttribute('href');
                        if (targetHash && targetHash.startsWith('#') && targetHash !== 'javascript:void(0)') {
                            e.preventDefault();
                            const targetSectionId = targetHash.substring(1);
                            const targetSectionElement = document.getElementById(targetSectionId);

                            if (targetSectionElement) {
                                if (window.location.hash === targetHash) {
                                    const headerHeight = document.querySelector('header')?.offsetHeight || 70;
                                    window.scrollTo({ top: Math.max(0, targetSectionElement.offsetTop - headerHeight), behavior: 'smooth' });
                                } else {
                                    window.location.hash = targetHash; 
                                }
                            } else {
                                console.warn(`[NAV CLICK] Target section ${targetHash} not found.`);
                                if (window.location.hash !== '#homepage-section') window.location.hash = '#homepage-section';
                            }
                        }
                    });
                });

                handleNavigation();
                window.addEventListener('hashchange', handleNavigation);
            }

             function resetToolState(toolId) {
                 const section = document.getElementById(toolId + '-section');
                 if (!section) { console.warn(`[RESET] Section not found: ${toolId}-section`); return; }

                 const state = toolState[toolId] || {};
                 if (state.imageObject?.src?.startsWith('blob:')) { try { URL.revokeObjectURL(state.imageObject.src); } catch(e) {} }
                 if (state.firstPagePreviewUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.firstPagePreviewUrl); } catch(e) {} }
                 if (state.fileUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.fileUrl); } catch(e) {} }
                 if (state.previewBlobUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.previewBlobUrl); } catch(e) {} }
                 if (state.resultBlobUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.resultBlobUrl); } catch(e) {} }
                 if (state.mainImageUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.mainImageUrl); } catch(e) {} }
                 if (state.watermarkImageUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.watermarkImageUrl); } catch(e) {} }


                 if (state.files) {
                    state.files.forEach(fileObj => { if (fileObj.url?.startsWith('blob:')) try { URL.revokeObjectURL(fileObj.url); } catch(e){} });
                 }
                 toolState[toolId] = {}; 

                 if (toolId === 'image-cropper') finalScaledCrop = null;
                 if (toolId === 'image-rotate-flip') { currentRotationAngle = 0; currentFlipH = false; currentFlipV = false; }
                 if (toolId === 'split-pdf') splitPdfDocObject = null;
                 if (toolId === 'organize-pdf') {
                     organizePdfDocObject = null;
                     organizePageData = [];
                     const thumbnailsContainer = document.getElementById('organizePageThumbnails');
                     if (thumbnailsContainer) thumbnailsContainer.innerHTML = '';
                 }
                 if (toolId === 'rotate-pdf') rotatePdfCurrentAngle = 0;


                 try { 
                    const previewSection = section.querySelector('.image-preview, .pdf-tool-preview');
                    if (previewSection) {
                        previewSection.querySelectorAll('img, canvas').forEach(el => { 
                            if (el.src?.startsWith('blob:')) try { URL.revokeObjectURL(el.src); } catch(e){}
                            if (el.tagName === 'IMG') { el.src = ''; el.alt = ''; }
                            if (el.tagName === 'CANVAS') {
                                const ctx = el.getContext('2d');
                                if (ctx) ctx.clearRect(0, 0, el.width, el.height);
                            }
                            el.style.display = 'none';
                            if (el.closest('.pdf-thumbnails-container') && el.closest('.pdf-thumbnails-container').id !== 'organizePageThumbnails') el.remove();
                        });
                        const pdfEmbed = previewSection.querySelector('embed[type="application/pdf"]');
                        if(pdfEmbed) {
                            if (pdfEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(pdfEmbed.src); } catch(e){}
                            pdfEmbed.removeAttribute('src'); pdfEmbed.style.display = 'none';
                        }
                        previewSection.querySelectorAll('.preview-success-message').forEach(msg => msg.style.display = 'none');
                        previewSection.style.display = 'none';
                    }

                    section.querySelectorAll('#jpgThumbnailsContainer, #pdfResultThumbnailsContainer, #organizePageThumbnails, #mergePdfFilesListUl, #jpgToPdfFilesListUl')
                        .forEach(container => { if(container) container.innerHTML = ''; });

                    const downloadSection = section.querySelector('.download-section');
                    if (downloadSection) {
                         const downloadLink = downloadSection.querySelector('a.btn');
                         if (downloadLink) {
                              if (downloadLink.href && (downloadLink.href.startsWith('blob:') || downloadLink.href.includes('cloudconvert.com'))) { 
                                  if (downloadLink.href.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                              }
                              downloadLink.href = '#'; downloadLink.style.display = 'none'; downloadLink.removeAttribute('download');
                         }
                         const dlMessage = downloadSection.querySelector('.preview-success-message');
                         if(dlMessage) dlMessage.style.display = 'none';
                    }

                    section.querySelectorAll('.image-info, .output-info, .file-list-display, .text-output-area, .metadata-display-area') 
                        .forEach(div => { if(div) div.style.display = 'none'; });

                    const processingMsg = section.querySelector('.processing-message');
                    if (processingMsg) processingMsg.style.display = 'none';
                    
                    const placeholderMsg = section.querySelector('.placeholder-message');
                    if (placeholderMsg) {
                        placeholderMsg.style.display = 'none';
                        placeholderMsg.classList.remove('error');
                    }


                    switch(toolId) {
                        case 'organize-pdf':
                              section.querySelector('#processOrganizePdfBtn').disabled = true;
                              section.querySelector('#organizePdfPagesContainer').style.display = 'none';
                              break;
                        case 'rotate-pdf':
                              section.querySelectorAll('.rotate-pdf-controls button').forEach(btn => btn.disabled = true);
                              section.querySelector('#currentRotationAngleDisplay').textContent = '0';
                              const rotatePreviewImg = section.querySelector('#rotatePdfPagePreview');
                              if (rotatePreviewImg) { rotatePreviewImg.src=''; rotatePreviewImg.style.display='none';}
                              section.querySelector('#rotatePdfPreviewContainer').style.display = 'none';
                              section.querySelector('#rotatePdfStatus').textContent = 'Ready';
                              break;
                        case 'image-to-base64':
                            section.querySelector('#imgToBase64ResultText').value = '';
                            section.querySelector('#copyBase64Btn').disabled = true;
                            section.querySelector('#copyBase64Btn').textContent = 'Copy to Clipboard';
                            section.querySelector('#imgToBase64FileName').textContent = '';
                            section.querySelector('#imgToBase64OriginalSize').textContent = '';
                            section.querySelector('#imgToBase64StringLength').textContent = '-';
                            section.querySelector('#imgToBase64ImagePreview').style.display = 'none';
                            section.querySelector('#imgToBase64OutputArea').style.display = 'none';
                            section.querySelector('#imgToBase64Info').style.display = 'none';
                            const imgToBase64PreviewEl = section.querySelector('#imgToBase64OriginalPreview');
                            if(imgToBase64PreviewEl && imgToBase64PreviewEl.src?.startsWith('blob:')) {
                                try { URL.revokeObjectURL(imgToBase64PreviewEl.src); } catch(e) {}
                            }
                            if(imgToBase64PreviewEl) { imgToBase64PreviewEl.src = ''; imgToBase64PreviewEl.style.display = 'none'; }
                            break;
                        case 'base64-to-image':
                            section.querySelector('#base64ToImageInput').value = '';
                            section.querySelector('#base64ToImageConvertBtn').disabled = true;
                            toolState['base64-to-image'] = { isInitialized: false };
                            break;
                        case 'add-page-numbers-pdf':
                            section.querySelectorAll('.tool-controls button, .tool-controls input, .tool-controls select').forEach(el => {
                                if(el.tagName === 'BUTTON' && el.id === 'addPageNumbersPdfBtn') el.disabled = true;
                                else if (el.id === 'pageNumFontSize') el.value = '12';
                                else if (el.id === 'pageNumPosition') el.value = 'bottom-center';
                            });
                            break;
                        case 'add-text-watermark-pdf':
                             section.querySelectorAll('.tool-controls button, .tool-controls input, .tool-controls select').forEach(el => {
                                if(el.tagName === 'BUTTON' && el.id === 'addWatermarkPdfBtn') el.disabled = true;
                                else if (el.id === 'watermarkText') el.value = 'CONFIDENTIAL';
                                else if (el.id === 'watermarkFontSize') el.value = '48';
                                else if (el.id === 'watermarkOpacity') el.value = '0.3';
                            });
                            break;
                        case 'compress-pdf':
                            section.querySelector('#compressPdfBtn').disabled = true;
                            section.querySelector('#pdfCompressionLevel').value = '6';
                            section.querySelector('#pdfCompressionLevelValue').textContent = '6';
                            break;
                        case 'pdf-to-word':
                        case 'pdf-to-powerpoint':
                        case 'pdf-to-excel':
                            let btnIdSuffix = '';
                            if (toolId === 'pdf-to-word') btnIdSuffix = 'Word';
                            else if (toolId === 'pdf-to-powerpoint') btnIdSuffix = 'PowerPoint';
                            else if (toolId === 'pdf-to-excel') btnIdSuffix = 'Excel';
                            const convertButton = section.querySelector(`#convertTo${btnIdSuffix}Btn`);
                            if (convertButton) convertButton.disabled = true;
                            const currentApiState = toolState[toolId] || {};
                            if (currentApiState.fileUrl && currentApiState.fileUrl.startsWith('blob:')) {
                                try { URL.revokeObjectURL(currentApiState.fileUrl); } catch(e) {}
                            }
                            const apiDownloadLink = section.querySelector(`#${toolId.replace('-section', '')}DownloadLink`);
                            if (apiDownloadLink && apiDownloadLink.href && !apiDownloadLink.href.startsWith('blob:')) {
                                apiDownloadLink.href = '#';
                                apiDownloadLink.style.display = 'none';
                            }
                            const apiDownloadMessage = section.querySelector(`#${toolId.replace('-section', '')}DownloadMessage`);
                            if (apiDownloadMessage) apiDownloadMessage.style.display = 'none';
                            break;
                        case 'protect-pdf':
                            section.querySelector('#protectPdfPassword').value = '';
                            section.querySelector('#protectPdfBtn').disabled = true;
                            break;
                        case 'unlock-pdf':
                            section.querySelector('#unlockPdfPassword').value = '';
                            section.querySelector('#unlockPdfBtn').disabled = true;
                            break;
                        case 'pdf-metadata':
                            section.querySelector('#pdfMetadataDisplayArea').style.display = 'none';
                            ['#metaTitle', '#metaAuthor', '#metaSubject', '#metaKeywords'].forEach(sel => {
                                const input = section.querySelector(sel);
                                if (input) input.value = '';
                            });
                            ['#metaCreator', '#metaProducer', '#metaCreationDate', '#metaModDate', '#pdfMetadataFileNameDisplay'].forEach(sel => {
                                const span = section.querySelector(sel);
                                if (span) span.textContent = '-';
                            });
                            section.querySelector('#savePdfMetadataBtn').disabled = true;
                            break;
                        case 'html-to-pdf':
                            section.querySelector('#htmlToPdfInputArea').value = '';
                            section.querySelector('#convertToPdfFromHtmlBtn').disabled = true;
                            toolState['html-to-pdf'] = { isInitialized: false };
                            break;
                        case 'image-color-picker':
                            const canvas = section.querySelector('#colorPickerCanvas');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                ctx.clearRect(0,0, canvas.width, canvas.height);
                                canvas.width = 1; canvas.height = 1; 
                            }
                            section.querySelector('#colorPickerPreviewArea').style.display = 'none';
                            section.querySelector('#colorPickerCanvasContainer').style.cursor = 'default';
                            section.querySelector('#colorPickerOutputDisplay').style.display = 'none';
                            section.querySelector('#colorPickerPreviewBox').style.backgroundColor = 'transparent';
                            section.querySelector('#colorPickerHexValue').textContent = 'HEX: -';
                            section.querySelector('#colorPickerRgbValue').textContent = 'RGB: -';
                            break;
                        case 'image-watermark': 
                            section.querySelector('#watermarkImageUploadContainer').style.display = 'none';
                            section.querySelector('#watermarkControlsContainer').style.display = 'none';
                            const mainImgWM = section.querySelector('#watermarkOriginalMainPreview');
                            const resultImgWM = section.querySelector('#watermarkedResultImage');
                            if (mainImgWM && mainImgWM.src?.startsWith('blob:')) try { URL.revokeObjectURL(mainImgWM.src); } catch(e){}
                            if (resultImgWM && resultImgWM.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultImgWM.src); } catch(e){}
                            if(mainImgWM) mainImgWM.src = '';
                            if(resultImgWM) resultImgWM.src = '';
                            toolState[toolId] = { mainImageFile: null, mainImageUrl: null, mainImageObject: null, watermarkImageFile: null, watermarkImageUrl: null, watermarkImageObject: null, resultBlobUrl: null };
                            const watermarkMainFileInput = section.querySelector('#watermarkMainImageFile');
                            const watermarkOverlayFileInput = section.querySelector('#watermarkOverlayImageFile');
                            if (watermarkMainFileInput) watermarkMainFileInput.value = '';
                            if (watermarkOverlayFileInput) watermarkOverlayFileInput.value = '';
                            section.querySelector('#watermarkMainFileName').textContent = '-';
                            section.querySelector('#watermarkOverlayFileName').textContent = '-';
                            section.querySelector('#watermarkedResultSize').textContent = '-';
                            section.querySelector('#applyImageWatermarkBtn').disabled = true;
                            break;

                    }
                    const fileInput = section.querySelector('input[type="file"]');
                    if (fileInput && toolId !== 'image-watermark-main' && toolId !== 'image-watermark-overlay' && toolId !== 'image-watermark') { 
                        fileInput.value = '';
                    }
                 } catch (error) { console.error(`[RESET] Error resetting UI for ${toolId}:`, error); }
            }

             function addDropZoneListeners(toolId, dropZoneId, fileInputId, isMultiple = false, acceptType = "image/*") {
                 const dropZone = document.getElementById(dropZoneId);
                 const fileInput = document.getElementById(fileInputId);
                 if (!dropZone || !fileInput) { console.error(`[LISTENERS] Missing elements for ${toolId} (DropZone: ${dropZoneId}, Input: ${fileInputId})`); return; }

                 ['dragenter', 'dragover'].forEach(eName => dropZone.addEventListener(eName, e => { preventDefaults(e); dropZone.classList.add('drag-over'); }));
                 ['dragleave', 'drop'].forEach(eName => dropZone.addEventListener(eName, e => { preventDefaults(e); dropZone.classList.remove('drag-over'); }));

                 dropZone.addEventListener('drop', e => {
                     const files = e.dataTransfer.files;
                     if (!files || files.length === 0) return;
                     const baseToolIdForReset = toolId.startsWith('image-watermark') ? 'image-watermark' : toolId;

                     const acceptedFiles = filterAcceptedFiles(files, acceptType);
                     console.log(`[${toolId}] Dropped files:`, files, "Accepted:", acceptedFiles); 

                     if (acceptedFiles.length === 0) { 
                        alert(`Please drop valid ${acceptType.split('/')[1]?.toUpperCase() || acceptType} files.`); 
                        return; 
                     }
                     
                     if (toolId !== 'image-watermark-overlay') { 
                        resetToolState(baseToolIdForReset);
                     }

                     const fileToProcess = isMultiple ? acceptedFiles : acceptedFiles[0];
                     if (!isMultiple && !fileToProcess) { 
                         console.error(`[${toolId}] No valid single file found after filtering (drop).`);
                         alert("Error: No valid file found after filtering.");
                         return;
                     }
                     handleFileSelection(fileToProcess, toolId, isMultiple);
                 });
                 fileInput.addEventListener('change', e => {
                     const inputFiles = e.target.files;
                     if (!inputFiles || inputFiles.length === 0) return;
                     const baseToolIdForReset = toolId.startsWith('image-watermark') ? 'image-watermark' : toolId;
                     
                     const filesArray = Array.from(inputFiles);
                     console.log(`[${toolId}] Selected via input:`, filesArray); 

                     if (toolId !== 'image-watermark-overlay') {
                        resetToolState(baseToolIdForReset);
                     }

                     const fileToProcess = isMultiple ? filesArray : filesArray[0];
                     if (!isMultiple && !fileToProcess) { 
                         console.error(`[${toolId}] No valid single file found from input.`);
                         alert("Error: No file selected or file is invalid.");
                         return;
                     }
                     handleFileSelection(fileToProcess, toolId, isMultiple);
                 });
            }
            function filterAcceptedFiles(files, acceptType) {
                 return Array.from(files).filter(file => {
                    if (!file.type && acceptType !== "application/pdf") return false; 
                    if (acceptType === "application/pdf") return file.type === "application/pdf" || (!file.type && file.name.toLowerCase().endsWith('.pdf'));
                    if (acceptType === "image/jpeg" || acceptType === "image/jpg") return file.type === "image/jpeg" || file.type === "image/jpg";
                    if (acceptType === "image/*") return file.type.startsWith('image/');
                    if (acceptType === "image/png" && file.type === "image/png") return true; 
                    if (acceptType === "image/webp" && file.type === "image/webp") return true;
                    if (acceptType === "image/png,image/jpeg,image/webp") { 
                        return file.type === "image/png" || file.type === "image/jpeg" || file.type === "image/webp";
                    }
                    return false;
                 });
            }
             function handleFileSelection(selected, toolId, isMultiple) {
                 try {
                     const baseToolId = toolId.startsWith('image-watermark') ? 'image-watermark' : toolId;
                     if (!toolState[baseToolId]) toolState[baseToolId] = {};

                     console.log(`[${toolId}] handleFileSelection - selected:`, selected, `isMultiple: ${isMultiple}`);
                     if (!selected && !isMultiple) {
                         console.error(`[${toolId}] 'selected' is undefined and not multiple. Aborting.`);
                         alert("Error: No file was properly selected.");
                         return;
                     }
                     if (isMultiple && (!Array.isArray(selected) || selected.length === 0)) {
                         console.error(`[${toolId}] 'selected' is not a valid array for multiple files. Aborting.`, selected);
                         alert("Error: No valid files found for multiple selection.");
                         return;
                     }


                     if (isMultiple) {
                         const fileObjects = selected.map(file => {
                             if (!(file instanceof File || file instanceof Blob)) { 
                                 console.error("Error in multiple selection: item is not a File/Blob", file);
                                 throw new Error("Invalid item in multiple file selection.");
                             }
                             return { file, url: URL.createObjectURL(file) };
                         });
                         if (fileObjects.length === 0) throw new Error("No valid files found after processing multiple selection.");
                         toolState[baseToolId].files = fileObjects; 
                         if (baseToolId === 'jpg-to-pdf') setupJpgToPdfUI(fileObjects);
                         else if (baseToolId === 'merge-pdf') setupMergePdfUI(fileObjects);
                         else throw new Error(`Multiple file selection not handled for tool: ${baseToolId}`);
                     } else {
                         const file = selected; 
                         if (!(file instanceof File || file instanceof Blob)) { 
                             console.error("Error in single selection: item is not a File/Blob", file);
                             throw new Error("Invalid file selected. Expected a File or Blob object.");
                         }
                         const objectUrl = URL.createObjectURL(file); 
                         
                         if (toolId === 'image-watermark-main') {
                            toolState[baseToolId].mainImageFile = file;
                            toolState[baseToolId].mainImageUrl = objectUrl;
                         } else if (toolId === 'image-watermark-overlay') {
                            toolState[baseToolId].watermarkImageFile = file;
                            toolState[baseToolId].watermarkImageUrl = objectUrl;
                         } else {
                            toolState[baseToolId].file = file;
                            toolState[baseToolId].fileUrl = objectUrl;
                         }


                         if (baseToolId === 'pdf-to-jpg') setupPdfToJpgUI(file, objectUrl);
                         else if (baseToolId === 'split-pdf') setupSplitPdfUI(file, objectUrl);
                         else if (baseToolId === 'organize-pdf') setupOrganizePdfUI(file, objectUrl);
                         else if (baseToolId === 'rotate-pdf') setupRotatePdfUI(file, objectUrl);
                         else if (baseToolId === 'add-page-numbers-pdf') setupAddPageNumbersPdfUI(file, objectUrl);
                         else if (baseToolId === 'add-text-watermark-pdf') setupAddTextWatermarkPdfUI(file, objectUrl);
                         else if (baseToolId === 'compress-pdf') setupCompressPdfUI(file, objectUrl);
                         else if (baseToolId === 'pdf-to-word') setupPdfToWordUI(file, objectUrl);
                         else if (baseToolId === 'pdf-to-powerpoint') setupPdfToPowerPointUI(file, objectUrl);
                         else if (baseToolId === 'pdf-to-excel') setupPdfToExcelUI(file, objectUrl);
                         else if (baseToolId === 'protect-pdf') setupProtectPdfUI(file, objectUrl);
                         else if (baseToolId === 'unlock-pdf') setupUnlockPdfUI(file, objectUrl);
                         else if (baseToolId === 'pdf-metadata') setupPdfMetadataUI(file, objectUrl);
                         else handleImageFile(file, toolId, objectUrl); 
                     }
                 } catch (error) {
                     console.error(`[HANDLE_FILE] Error processing selection for ${toolId}:`, error);
                     alert(`Error processing file(s): ${error.message}`);
                     const baseToolIdForReset = toolId.startsWith('image-watermark') ? 'image-watermark' : toolId;
                     resetToolState(baseToolIdForReset); 
                 }
             }
             function handleImageFile(file, toolId, objectUrl) {
                const baseToolId = toolId.startsWith('image-watermark') ? 'image-watermark' : toolId;
                if (!toolState[baseToolId]) toolState[baseToolId] = {};

                 let setupFn;
                 let targetImageObjectKey; 

                 switch (toolId) {
                     case 'image-compressor': setupFn = setupCompressUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-resizer':    setupFn = setupResizeUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-converter':  setupFn = setupConvertUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-cropper':    setupFn = setupCropUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-rotate-flip':setupFn = setupRotateFlipUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-filters':    setupFn = setupFilterUI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-to-base64':  setupFn = setupImageToBase64UI; targetImageObjectKey = 'imageObject'; break;
                     case 'image-color-picker': setupFn = setupImageColorPickerUI; targetImageObjectKey = 'imageObject'; break; 
                     case 'image-watermark-main': setupFn = setupImageWatermarkMainUI; targetImageObjectKey = 'mainImageObject'; break; 
                     case 'image-watermark-overlay': setupFn = setupImageWatermarkOverlayUI; targetImageObjectKey = 'watermarkImageObject'; break; 
                     default: console.error(`Unknown image toolId in handleImageFile: ${toolId}`); resetToolState(baseToolId); return;
                 }
                 
                 toolState[baseToolId][targetImageObjectKey] = new Image();
                 const imgObj = toolState[baseToolId][targetImageObjectKey];


                 imgObj.onload = () => {
                     if (imgObj.naturalWidth > 0) {
                         setupFn(file, objectUrl); 
                     } else {
                         alert(`Image "${file.name}" loaded but has zero dimensions. Please try a different image.`);
                         resetToolState(baseToolId);
                     }
                     imgObj.onerror = null;
                 };
                  imgObj.onerror = () => {
                     console.error(`[HANDLE_IMG_FILE] Error loading image for ${toolId}: ${file.name}`);
                     alert(`Error loading image "${file.name}". Please ensure it's a valid image file.`);
                     resetToolState(baseToolId);
                     imgObj.onload = null;
                 };
                 imgObj.src = objectUrl;
             }

            // --- Image Compressor ---
             function setupCompressUI(file, imgUrl) {
                 const toolId = 'image-compressor';
                 const section = document.getElementById(toolId + '-section');
                 section.querySelector('#compressOriginalFileName').textContent = file.name;
                 section.querySelector('#compressOriginalSize').textContent = formatBytes(file.size);
                 section.querySelector('#compressedSize').textContent = '-';
                 section.querySelector('#sizeReduction').textContent = '-';
                 section.querySelector('#compressImageInfo').style.display = 'block';
                 section.querySelector('#originalImagePreview').src = imgUrl;
                 section.querySelector('#originalImagePreview').alt = `Original Image Preview (${file.name})`;
                 section.querySelector('#originalImagePreview').style.display = 'block';
                 const compressedPreview = section.querySelector('#compressedImagePreview');
                 if (compressedPreview.src?.startsWith('blob:')) { try { URL.revokeObjectURL(compressedPreview.src); } catch(e){} }
                 compressedPreview.src = ''; compressedPreview.style.display = 'none';
                 section.querySelector('#compressImagePreview').style.display = 'block';
                 section.querySelector('#compressNowBtn').disabled = false;
                 section.querySelector('#qualityValue').textContent = section.querySelector('#compressionQuality').value + '%';
             }
             function setupImageCompressorListeners() {
                 const toolId = 'image-compressor';
                 const section = document.getElementById(toolId + '-section');
                 const qualitySlider = section.querySelector('#compressionQuality');
                 const qualityValueSpan = section.querySelector('#qualityValue');
                 const compressNowBtn = section.querySelector('#compressNowBtn');
                 const compressedSizeSpan = section.querySelector('#compressedSize');
                 const sizeReductionSpan = section.querySelector('#sizeReduction');
                 const compressedImagePreview = section.querySelector('#compressedImagePreview');
                 const downloadLink = section.querySelector('#compressDownloadLink');
                 const downloadMessage = section.querySelector('#compressDownloadMessage');
                 const processingMsg = section.querySelector('#compressProcessingMsg');

                 qualitySlider?.addEventListener('input', (event) => { qualityValueSpan.textContent = event.target.value + '%'; });

                 compressNowBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                     if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0) {
                         processCompressImage(currentFile, currentImage, parseInt(qualitySlider.value, 10));
                     } else { alert("Please select a valid image file first."); }
                 });

                 addDropZoneListeners(toolId, 'compressDropZone', 'compressImageFile', false, "image/*");

                 function processCompressImage(file, imageObj, quality) {
                      compressNowBtn.disabled = true; processingMsg.style.display = 'flex';
                      if (compressedImagePreview.src?.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) {} }
                      compressedImagePreview.src = ''; compressedImagePreview.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight;
                      const mimeType = file.type === 'image/png' ? 'image/png' : file.type === 'image/webp' ? 'image/webp' : 'image/jpeg';

                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.drawImage(imageObj, 0, 0);

                      const outputQuality = quality / 100;
                      canvas.toBlob((blob) => {
                          if (blob) { updateCompressOutput(blob, file.name, file.size, mimeType); }
                          else { alert("Image compression failed."); compressedSizeSpan.textContent = 'Failed'; }
                          const currentState = toolState[toolId] || {};
                          compressNowBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                          processingMsg.style.display = 'none';
                      }, mimeType, outputQuality);
                 }
                 function updateCompressOutput(compressedBlob, originalName, originalSize, mimeType) {
                    if (compressedImagePreview.src?.startsWith('blob:')) try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) {}
                    if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                    const objectUrl = URL.createObjectURL(compressedBlob);
                    toolState[toolId].resultBlobUrl = objectUrl; 

                    compressedSizeSpan.textContent = formatBytes(compressedBlob.size);
                    sizeReductionSpan.textContent = originalSize > 0 ? `${(((originalSize - compressedBlob.size) / originalSize) * 100).toFixed(2)}%` : 'N/A';
                    compressedImagePreview.src = objectUrl; compressedImagePreview.alt = `Compressed Image`; compressedImagePreview.style.display = 'block';
                    downloadLink.href = objectUrl;
                    let ext = mimeType.split('/')[1] || 'jpg'; if (ext === 'jpeg') ext = 'jpg';
                    downloadLink.download = `compressed_${originalName.substring(0, originalName.lastIndexOf('.')) || originalName}.${ext}`;
                    downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Resizer ---
            function setupResizeUI(file, imgUrl) {
                const toolId = 'image-resizer';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId] || {};
                const imageObj = state.imageObject;

                section.querySelector('#resizeOriginalFileName').textContent = file.name;
                section.querySelector('#originalDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                section.querySelector('#resizeOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#newDimensions').textContent = '-';
                section.querySelector('#resizedSize').textContent = '-';
                section.querySelector('#resizeImageInfo').style.display = 'block';
                section.querySelector('#resizeOriginalPreview').src = imgUrl;
                section.querySelector('#resizeOriginalPreview').alt = `Original Image Preview (${file.name})`;
                section.querySelector('#resizeOriginalPreview').style.display = 'block';
                const resizedImgEl = section.querySelector('#resizedImage');
                if(resizedImgEl.src?.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImgEl.src); } catch(e){} }
                resizedImgEl.src = ''; resizedImgEl.style.display = 'none';
                section.querySelector('#resizeImagePreview').style.display = 'block';
                section.querySelector('#resizeWidth').value = imageObj ? imageObj.naturalWidth : '';
                section.querySelector('#resizeHeight').value = imageObj ? imageObj.naturalHeight : '';
                section.querySelector('#applyResizeBtn').disabled = !(imageObj && imageObj.naturalWidth > 0);
            }
            function setupImageResizerListeners() {
                const toolId = 'image-resizer';
                const section = document.getElementById(toolId + '-section');
                const widthInput = section.querySelector('#resizeWidth');
                const heightInput = section.querySelector('#resizeHeight');
                const applyBtn = section.querySelector('#applyResizeBtn');
                 const newDimensionsSpan = section.querySelector('#newDimensions');
                 const resizedSizeSpan = section.querySelector('#resizedSize');
                 const resizedImage = section.querySelector('#resizedImage');
                 const downloadLink = section.querySelector('#resizeDownloadLink');
                 const downloadMessage = section.querySelector('#resizeDownloadMessage');
                 const processingMsg = section.querySelector('#resizeProcessingMsg');

                const dimensionInputHandler = () => {
                   const state = toolState[toolId] || {};
                   const isReady = state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0;
                   if (!isReady) { applyBtn.disabled = true; return; }
                   const w = parseInt(widthInput.value, 10); const h = parseInt(heightInput.value, 10);
                   applyBtn.disabled = !(!isNaN(w) && w > 0 && !isNaN(h) && h > 0);
                };
                widthInput?.addEventListener('input', dimensionInputHandler);
                heightInput?.addEventListener('input', dimensionInputHandler);

                applyBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                   const newW = parseInt(widthInput.value, 10); const newH = parseInt(heightInput.value, 10);
                   if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && !isNaN(newW) && newW > 0 && !isNaN(newH) && newH > 0) {
                       performResize(currentFile, currentImage, newW, newH);
                   } else { alert("Please select file and enter valid positive dimensions."); }
                });

                addDropZoneListeners(toolId, 'resizeDropZone', 'resizeImageFile', false, "image/*");

                function performResize(file, imageObj, newWidth, newHeight) {
                     applyBtn.disabled = true; processingMsg.style.display = 'flex';
                     if (resizedImage.src?.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImage.src); } catch (e) {} }
                     resizedImage.src = ''; resizedImage.style.display = 'none';
                     if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                     newDimensionsSpan.textContent = '-'; resizedSizeSpan.textContent = '-';

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     canvas.width = newWidth; canvas.height = newHeight;
                     const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                     if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, newWidth, newHeight); }
                     else { ctx.clearRect(0, 0, newWidth, newHeight); }
                     ctx.drawImage(imageObj, 0, 0, newWidth, newHeight);

                     canvas.toBlob(blob => {
                         if (blob) { updateResizeOutput(blob, file.name, newWidth, newHeight, mimeType); }
                         else { alert("Resizing failed."); newDimensionsSpan.textContent = 'Failed'; }
                         const currentState = toolState[toolId] || {};
                         const w = parseInt(widthInput.value, 10); const h = parseInt(heightInput.value, 10);
                         applyBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && !isNaN(w) && w > 0 && !isNaN(h) && h > 0);
                         processingMsg.style.display = 'none';
                     }, mimeType);
                }
                function updateResizeOutput(blob, name, w, h, mime) {
                     if (resizedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(resizedImage.src); } catch (e) {}
                     if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                     const url = URL.createObjectURL(blob);
                     toolState[toolId].resultBlobUrl = url;

                     newDimensionsSpan.textContent = `${w}x${h}`;
                     resizedSizeSpan.textContent = formatBytes(blob.size);
                     resizedImage.src = url; resizedImage.alt = 'Resized Image'; resizedImage.style.display = 'block';
                     downloadLink.href = url;
                     let ext = mime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                     downloadLink.download = `resized_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                     downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                }
            }

            // --- Image Converter ---
            function setupConvertUI(file, imgUrl) {
                 const toolId = 'image-converter';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;

                 section.querySelector('#convertOriginalFileName').textContent = file.name;
                 section.querySelector('#originalFormat').textContent = file.type.split('/')[1]?.toUpperCase() || 'Unknown';
                 section.querySelector('#convertOriginalSize').textContent = formatBytes(file.size);
                 section.querySelector('#newFormat').textContent = '-';
                 section.querySelector('#convertedSize').textContent = '-';
                 section.querySelector('#convertImageInfo').style.display = 'block';
                 section.querySelector('#convertOriginalPreview').src = imgUrl;
                 section.querySelector('#convertOriginalPreview').alt = `Original Image Preview (${file.name})`;
                 section.querySelector('#convertOriginalPreview').style.display = 'block';
                 const convertedImgEl = section.querySelector('#convertedImage');
                 if(convertedImgEl.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImgEl.src); } catch(e){}
                 convertedImgEl.src = ''; convertedImgEl.style.display = 'none';
                 section.querySelector('#convertImagePreview').style.display = 'block';
                 section.querySelector('#outputFormat').value = 'image/jpeg';
                 section.querySelector('#applyConvertBtn').disabled = !(imageObj && imageObj.naturalWidth > 0);
            }
            function setupImageConverterListeners() {
                 const toolId = 'image-converter';
                 const section = document.getElementById(toolId + '-section');
                 const formatSelect = section.querySelector('#outputFormat');
                 const applyBtn = section.querySelector('#applyConvertBtn');
                  const newFormatSpan = section.querySelector('#newFormat');
                  const convertedSizeSpan = section.querySelector('#convertedSize');
                  const convertedImage = section.querySelector('#convertedImage');
                  const downloadLink = section.querySelector('#convertDownloadLink');
                  const downloadMessage = section.querySelector('#convertDownloadMessage');
                  const processingMsg = section.querySelector('#convertProcessingMsg');

                 formatSelect?.addEventListener('change', () => {
                    const state = toolState[toolId] || {};
                    applyBtn.disabled = !(state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0);
                 });

                 applyBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                    const mime = formatSelect.value;
                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && mime) {
                        performConversion(currentFile, currentImage, mime);
                    } else { alert("Select file and output format."); }
                 });

                 addDropZoneListeners(toolId, 'convertDropZone', 'convertImageFile', false, "image/*");

                 function performConversion(file, imageObj, outputMime) {
                      applyBtn.disabled = true; processingMsg.style.display = 'flex';
                      if (convertedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImage.src); } catch (e) {}
                      convertedImage.src = ''; convertedImage.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                      newFormatSpan.textContent = '-'; convertedSizeSpan.textContent = '-';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight;
                      if (outputMime === 'image/jpeg' || outputMime === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.drawImage(imageObj, 0, 0);

                      canvas.toBlob(blob => {
                          if (blob) { updateConvertOutput(blob, file.name, outputMime, file.type); }
                          else { alert("Conversion failed."); newFormatSpan.textContent = 'Failed'; }
                          const currentState = toolState[toolId] || {};
                          applyBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && formatSelect.value);
                          processingMsg.style.display = 'none';
                      }, outputMime, 0.8);
                 }
                 function updateConvertOutput(blob, name, outMime, inMime) {
                      if (convertedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImage.src); } catch (e) {}
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      const url = URL.createObjectURL(blob);
                      toolState[toolId].resultBlobUrl = url;

                      section.querySelector('#originalFormat').textContent = inMime.split('/')[1]?.toUpperCase() || '?';
                      newFormatSpan.textContent = outMime.split('/')[1]?.toUpperCase() || '?';
                      convertedSizeSpan.textContent = formatBytes(blob.size);
                      convertedImage.src = url; convertedImage.alt = 'Converted Image'; convertedImage.style.display = 'block';
                      downloadLink.href = url;
                      let ext = outMime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                      downloadLink.download = `converted_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                      downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Cropper ---
            function setupCropUI(file, imgUrl) {
                const toolId = 'image-cropper';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId] || {};
                const imageObj = state.imageObject;

                section.querySelector('#cropOriginalFileName').textContent = file.name;
                section.querySelector('#cropOriginalDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                section.querySelector('#cropOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#newCropDimensions').textContent = '-';
                section.querySelector('#croppedSize').textContent = '-';
                section.querySelector('#cropImageInfo').style.display = 'block';
                const cropOrigPrev = section.querySelector('#cropOriginalImagePreview');
                cropOrigPrev.src = imgUrl;
                cropOrigPrev.alt = `Image to Crop (${file.name})`;
                cropOrigPrev.style.display = 'block';
                section.querySelector('.cropper-container').style.display = 'block';
                section.querySelector('.cropper-container').style.cursor = 'default';
                section.querySelector('.crop-selection-overlay').style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                section.querySelector('.preview-comparison').style.display = 'none';
                const compareOrig = section.querySelector('#cropCompareOriginalPreview');
                const croppedImg = section.querySelector('#croppedImage');
                if(compareOrig.src?.startsWith('blob:')) try { URL.revokeObjectURL(compareOrig.src); } catch(e){}
                if(croppedImg.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImg.src); } catch(e){}
                compareOrig.src = ''; compareOrig.style.display = 'none';
                croppedImg.src = ''; croppedImg.style.display = 'none';
                section.querySelector('#cropImagePreview').style.display = 'block';
                section.querySelector('#selectCropAreaBtn').disabled = !(imageObj && imageObj.naturalWidth > 0);
                section.querySelector('#cropAndDownloadBtn').disabled = true;
                finalScaledCrop = null;
            }
            function setupImageCropperListeners() {
                const toolId = 'image-cropper';
                const section = document.getElementById(toolId + '-section');
                 const selectAreaBtn = section.querySelector('#selectCropAreaBtn');
                 const cropAndDownloadBtn = section.querySelector('#cropAndDownloadBtn');
                  const newCropDimensionsSpan = section.querySelector('#newCropDimensions');
                  const croppedSizeSpan = section.querySelector('#croppedSize');
                  const previewSection = section.querySelector('#cropImagePreview');
                  const interactiveContainer = section.querySelector('.cropper-container');
                  const comparisonContainer = section.querySelector('.preview-comparison');
                  const cropOriginalImagePreview = section.querySelector('#cropOriginalImagePreview');
                  const cropCompareOriginalPreview = section.querySelector('#cropCompareOriginalPreview');
                  const cropSelectionOverlay = section.querySelector('.crop-selection-overlay');
                  const croppedImage = section.querySelector('#croppedImage');
                  const downloadLink = section.querySelector('#cropDownloadLink');
                  const downloadMessage = section.querySelector('#cropDownloadMessage');
                  const processingMsg = section.querySelector('#cropProcessingMsg');

                 let isSelectingCropArea = false; let isDragging = false; let startX = 0, startY = 0;

                 selectAreaBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0) {
                         isSelectingCropArea = true; isDragging = false;
                         cropSelectionOverlay.style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                         interactiveContainer.style.display = 'block'; comparisonContainer.style.display = 'none';
                         cropOriginalImagePreview.style.display = 'block';
                         if (cropCompareOriginalPreview.src?.startsWith('blob:')) try { URL.revokeObjectURL(cropCompareOriginalPreview.src); } catch (e) {}
                         cropCompareOriginalPreview.src = ''; cropCompareOriginalPreview.style.display = 'none';
                         if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                         croppedImage.src = ''; croppedImage.style.display = 'none';
                         newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                         if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                         downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                         finalScaledCrop = null; cropAndDownloadBtn.disabled = true;
                         interactiveContainer.style.cursor = 'crosshair';
                         selectAreaBtn.disabled = true;
                    } else { alert("Please select an image file first."); }
                 });
                 interactiveContainer?.addEventListener('mousedown', (e) => {
                     if (!isSelectingCropArea || isDragging || e.button !== 0) return; e.preventDefault();
                     isDragging = true;
                     const cRect = interactiveContainer.getBoundingClientRect();
                     startX = Math.max(0, Math.min(e.clientX - cRect.left, cRect.width));
                     startY = Math.max(0, Math.min(e.clientY - cRect.top, cRect.height));
                     cropSelectionOverlay.style.left = `${startX}px`; cropSelectionOverlay.style.top = `${startY}px`;
                     cropSelectionOverlay.style.width = '0'; cropSelectionOverlay.style.height = '0';
                     cropSelectionOverlay.style.display = 'block';
                     newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                     cropAndDownloadBtn.disabled = true; finalScaledCrop = null;
                 });
                 interactiveContainer?.addEventListener('mousemove', (e) => {
                     if (!isDragging) return; e.preventDefault();
                     const cRect = interactiveContainer.getBoundingClientRect();
                     const cx = Math.max(0, Math.min(e.clientX - cRect.left, cRect.width));
                     const cy = Math.max(0, Math.min(e.clientY - cRect.top, cRect.height));
                     const x = Math.min(cx, startX); const y = Math.min(cy, startY);
                     const w = Math.abs(cx - startX); const h = Math.abs(cy - startY);
                     cropSelectionOverlay.style.left = `${x}px`; cropSelectionOverlay.style.top = `${y}px`;
                     cropSelectionOverlay.style.width = `${w}px`; cropSelectionOverlay.style.height = `${h}px`;
                     cropAndDownloadBtn.disabled = !(w > 5 && h > 5);
                 });
                 document.addEventListener('mouseup', (e) => {
                     if (!isDragging || !isSelectingCropArea) return;
                     isDragging = false;
                     const state = toolState[toolId] || {};
                     const currentImage = state.imageObject;
                     const fw = cropSelectionOverlay.offsetWidth || 0; const fh = cropSelectionOverlay.offsetHeight || 0;

                     if (fw > 5 && fh > 5 && cropOriginalImagePreview && currentImage?.naturalWidth > 0) {
                         const oRect = cropSelectionOverlay.getBoundingClientRect();
                         const iRect = cropOriginalImagePreview.getBoundingClientRect();
                         if (!iRect.width || !iRect.height) { alert("Cannot calculate crop, image size error."); isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false; return; }
                         const scaleX = currentImage.naturalWidth / iRect.width;
                         const scaleY = currentImage.naturalHeight / iRect.height;
                         const selX = Math.max(0, oRect.left - iRect.left);
                         const selY = Math.max(0, oRect.top - iRect.top);
                         const selW = Math.min(fw, iRect.width - selX);
                         const selH = Math.min(fh, iRect.height - selY);
                         const finX = Math.round(selX * scaleX); const finY = Math.round(selY * scaleY);
                         const finW = Math.max(1, Math.round(selW * scaleX)); const finH = Math.max(1, Math.round(selH * scaleY));

                         if (finW > 0 && finH > 0 && (finX + finW <= currentImage.naturalWidth + 1) && (finY + finH <= currentImage.naturalHeight + 1)) {
                             finalScaledCrop = { x: finX, y: finY, width: finW, height: finH };
                             newCropDimensionsSpan.textContent = `${finW}x${finH}`;
                             cropAndDownloadBtn.disabled = false;
                         } else {
                             console.warn("Invalid crop calc:", {finX, finY, finW, finH, imgW: currentImage.naturalWidth, imgH: currentImage.naturalHeight});
                             finalScaledCrop = null; cropSelectionOverlay.style.display = 'none'; cropAndDownloadBtn.disabled = true;
                             isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                             alert("Invalid selection calculated. Try again within bounds.");
                         }
                     } else {
                          finalScaledCrop = null; cropSelectionOverlay.style.display = 'none'; cropAndDownloadBtn.disabled = true;
                          isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                          if (fw > 0 || fh > 0) alert("Please select a valid crop area (min 5x5 pixels).");
                     }
                 });
                 cropAndDownloadBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && finalScaledCrop) {
                        performCrop(currentFile, currentImage);
                        isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                    } else { alert("Please select an image and define a valid crop area first."); }
                 });

                 addDropZoneListeners(toolId, 'cropDropZone', 'cropImageFile', false, "image/*");

                 function performCrop(file, imageObj) {
                      const { x, y, width, height } = finalScaledCrop;
                      cropAndDownloadBtn.disabled = true; selectAreaBtn.disabled = true; processingMsg.style.display = 'flex';
                      if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                      croppedImage.src = ''; croppedImage.style.display = 'none';
                      if (cropCompareOriginalPreview.src?.startsWith('blob:')) try { URL.revokeObjectURL(cropCompareOriginalPreview.src); } catch (e) {}
                      cropCompareOriginalPreview.src = ''; cropCompareOriginalPreview.style.display = 'none';
                      interactiveContainer.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                      newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = width; canvas.height = height;
                      const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height); }
                      else { ctx.clearRect(0, 0, width, height); }
                      ctx.drawImage(imageObj, x, y, width, height, 0, 0, width, height);

                      canvas.toBlob((blob) => {
                          if (blob) { updateCropOutput(blob, file.name, width, height, mimeType, imageObj.src); }
                          else { alert("Cropping failed."); newCropDimensionsSpan.textContent = 'Failed'; interactiveContainer.style.display='block'; }
                          const currentState = toolState[toolId] || {};
                          selectAreaBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                          cropAndDownloadBtn.disabled = true;
                          processingMsg.style.display = 'none';
                      }, mimeType);
                 }
                 function updateCropOutput(blob, name, w, h, mime, origSrc) {
                    if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                    if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                    const url = URL.createObjectURL(blob);
                    toolState[toolId].resultBlobUrl = url;

                    newCropDimensionsSpan.textContent = `${w}x${h}`;
                    croppedSizeSpan.textContent = formatBytes(blob.size);
                    cropCompareOriginalPreview.src = origSrc;
                    cropCompareOriginalPreview.alt = `Original Preview (${name})`;
                    cropCompareOriginalPreview.style.display = 'block';
                    croppedImage.src = url; croppedImage.alt = `Cropped Image`; croppedImage.style.display = 'block';
                    comparisonContainer.style.display = 'flex'; interactiveContainer.style.display = 'none';
                    previewSection.style.display = 'block';
                    finalScaledCrop = null;
                    downloadLink.href = url;
                    let ext = mime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                    downloadLink.download = `cropped_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                    downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Rotate/Flip ---
             function setupRotateFlipUI(file, imgUrl) {
                 const toolId = 'image-rotate-flip';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;
                 const imageInfoDiv = section.querySelector('.image-info');
                 const originalFileNameSpan = section.querySelector('#rotateFlipOriginalFileName');
                 const originalDimensionsSpan = section.querySelector('#originalRotateFlipDimensions');
                 const originalSizeSpan = section.querySelector('#rotateFlipOriginalSize');
                 const newRotateFlipDimensionsSpan = section.querySelector('#newRotateFlipDimensions');
                 const newRotateFlipSizeSpan = section.querySelector('#newRotateFlipSize');
                 const previewSection = section.querySelector('.image-preview');
                 const originalPreviewImgEl = section.querySelector('#rotateFlipOriginalPreview');
                 const rotatedFlippedImageEl = section.querySelector('#rotatedFlippedImage');
                 const downloadLink = section.querySelector('#rotateFlipDownloadLink');
                 const downloadMessage = section.querySelector('#rotateFlipDownloadMessage');

                 originalFileNameSpan.textContent = file.name;
                 originalDimensionsSpan.textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                 originalSizeSpan.textContent = formatBytes(file.size);
                 newRotateFlipDimensionsSpan.textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                 newRotateFlipSizeSpan.textContent = formatBytes(file.size);
                 if (imageInfoDiv) imageInfoDiv.style.display = 'block';

                 originalPreviewImgEl.src = imgUrl;
                 originalPreviewImgEl.alt = `Original Image Preview (${file.name})`;
                 originalPreviewImgEl.style.display = 'block';

                 currentRotationAngle = 0; currentFlipH = false; currentFlipV = false;

                 if (rotatedFlippedImageEl.src?.startsWith('blob:') && rotatedFlippedImageEl.src !== imgUrl) { try { URL.revokeObjectURL(rotatedFlippedImageEl.src); } catch (e) {} }
                 rotatedFlippedImageEl.src = imgUrl;
                 rotatedFlippedImageEl.alt = 'Result Preview';
                 rotatedFlippedImageEl.style.display = 'block';

                 if (previewSection) previewSection.style.display = 'block';
                 section.querySelectorAll('.rotate-flip-controls button').forEach(btn => btn.disabled = !(imageObj && imageObj.naturalWidth > 0));

                 if (downloadLink.href?.startsWith('blob:') && downloadLink.href !== imgUrl) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                 downloadLink.style.display = 'none'; if(downloadMessage) downloadMessage.style.display = 'none';
            }
             function setupImageRotateFlipListeners() {
                 const toolId = 'image-rotate-flip';
                 const section = document.getElementById(toolId + '-section');
                  const rotateLeftBtn = section.querySelector('#rotateLeftBtn');
                  const rotateRightBtn = section.querySelector('#rotateRightBtn');
                  const flipHorizontalBtn = section.querySelector('#flipHorizontalBtn');
                  const flipVerticalBtn = section.querySelector('#flipVerticalBtn');
                  const newRotateFlipDimensionsSpan = section.querySelector('#newRotateFlipDimensions');
                  const newRotateFlipSizeSpan = section.querySelector('#newRotateFlipSize');
                  const rotatedFlippedImageEl = section.querySelector('#rotatedFlippedImage');
                  const downloadLink = section.querySelector('#rotateFlipDownloadLink');
                  const downloadMessage = section.querySelector('#rotateFlipDownloadMessage');
                  const processingMsg = section.querySelector('#rotateFlipProcessingMsg');
                  const controlButtons = [rotateLeftBtn, rotateRightBtn, flipHorizontalBtn, flipVerticalBtn];

                 function applyAndRenderTransforms() {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file;
                     const currentImage = state.imageObject;

                     if (!currentFile || !currentImage?.complete || currentImage.naturalWidth === 0) {
                         alert("Please select a valid image first."); return;
                      }
                      controlButtons.forEach(btn => btn.disabled = true);
                      if(processingMsg) processingMsg.style.display = 'flex';

                      const oldDownloadHref = downloadLink.href;
                      if (oldDownloadHref?.startsWith('blob:') && oldDownloadHref !== state.fileUrl) {
                          try { URL.revokeObjectURL(oldDownloadHref); } catch(e) {}
                      }
                      downloadLink.style.display = 'none'; if(downloadMessage) downloadMessage.style.display = 'none';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      const img = currentImage;
                      const iw = img.naturalWidth; const ih = img.naturalHeight;
                      if (currentRotationAngle === 90 || currentRotationAngle === 270) { [canvas.width, canvas.height] = [ih, iw]; }
                      else { [canvas.width, canvas.height] = [iw, ih]; }
                      const mimeType = currentFile.type.startsWith('image/') ? currentFile.type : 'image/jpeg';
                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.translate(canvas.width / 2, canvas.height / 2);
                      ctx.scale(currentFlipH ? -1 : 1, currentFlipV ? -1 : 1);
                      ctx.rotate(currentRotationAngle * Math.PI / 180);
                      ctx.drawImage(img, -iw / 2, -ih / 2, iw, ih);

                      canvas.toBlob((blob) => {
                          try {
                              if (!blob) throw new Error("Canvas toBlob failed.");
                              const newUrl = URL.createObjectURL(blob);
                              toolState[toolId].resultBlobUrl = newUrl;

                              const oldResultSrc = rotatedFlippedImageEl.src;
                              if (oldResultSrc?.startsWith('blob:') && oldResultSrc !== state.fileUrl && oldResultSrc !== newUrl) {
                                   try { URL.revokeObjectURL(oldResultSrc); } catch (e) {}
                               }
                              rotatedFlippedImageEl.src = newUrl; rotatedFlippedImageEl.style.display = 'block';
                              newRotateFlipDimensionsSpan.textContent = `${canvas.width}x${canvas.height}`;
                              newRotateFlipSizeSpan.textContent = formatBytes(blob.size);
                              downloadLink.href = newUrl;
                              let ext = mimeType.split('/')[1] || 'jpg'; if (ext === 'jpeg') ext = 'jpg';
                              downloadLink.download = `transformed_${currentFile.name.substring(0, currentFile.name.lastIndexOf('.')) || currentFile.name}.${ext}`;
                              downloadLink.style.display = 'inline-block'; if(downloadMessage) downloadMessage.style.display = 'block';
                          } catch(error) { console.error("Transform Error:", error); alert(`Transformation Error: ${error.message}`); }
                          finally {
                              const currentState = toolState[toolId] || {};
                              controlButtons.forEach(btn => btn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0));
                              if(processingMsg) processingMsg.style.display = 'none';
                           }
                      }, mimeType);
                 }

                 rotateLeftBtn?.addEventListener('click', () => { currentRotationAngle = (currentRotationAngle - 90 + 360) % 360; applyAndRenderTransforms(); });
                 rotateRightBtn?.addEventListener('click', () => { currentRotationAngle = (currentRotationAngle + 90) % 360; applyAndRenderTransforms(); });
                 flipHorizontalBtn?.addEventListener('click', () => { currentFlipH = !currentFlipH; applyAndRenderTransforms(); });
                 flipVerticalBtn?.addEventListener('click', () => { currentFlipV = !currentFlipV; applyAndRenderTransforms(); });
                 addDropZoneListeners(toolId, 'rotateFlipDropZone', 'rotateFlipImageFile', false, "image/*");
             }

            // --- Image Filters ---
             function setupFilterUI(file, imgUrl) {
                 const toolId = 'image-filters';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;
                  section.querySelector('#filterOriginalFileName').textContent = file.name;
                  section.querySelector('#originalFilterDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                  section.querySelector('#filterOriginalSize').textContent = formatBytes(file.size);
                  section.querySelector('#newFilterSize').textContent = '-';
                  section.querySelector('#filterImageInfo').style.display = 'block';
                  section.querySelector('#filterOriginalPreview').src = imgUrl;
                  section.querySelector('#filterOriginalPreview').alt = `Original Image Preview (${file.name})`;
                  section.querySelector('#filterOriginalPreview').style.display = 'block';
                  const filteredImgEl = section.querySelector('#filteredImage');
                  if(filteredImgEl.src?.startsWith('blob:') && filteredImgEl.src !== imgUrl) try { URL.revokeObjectURL(filteredImgEl.src); } catch(e){}
                  filteredImgEl.src = '';
                  filteredImgEl.style.display = 'none';
                  section.querySelector('#filterImagePreview').style.display = 'block';
                  section.querySelector('#filterType').disabled = !(imageObj && imageObj.naturalWidth > 0);
                  section.querySelector('#filterType').value = 'none';
                  section.querySelector('#applyFilterBtn').disabled = true;
             }
             function setupImageFiltersListeners() {
                 const toolId = 'image-filters';
                 const section = document.getElementById(toolId + '-section');
                 const filterTypeSelect = section.querySelector('#filterType');
                 const applyFilterBtn = section.querySelector('#applyFilterBtn');
                  const newFilterSizeSpan = section.querySelector('#newFilterSize');
                  const filteredImage = section.querySelector('#filteredImage');
                  const downloadLink = section.querySelector('#filterDownloadLink');
                  const downloadMessage = section.querySelector('#filterDownloadMessage');
                  const processingMsg = section.querySelector('#filterProcessingMsg');

                 filterTypeSelect?.addEventListener('change', () => {
                    const state = toolState[toolId] || {};
                    const selected = filterTypeSelect.value;
                    const ready = state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0;

                    applyFilterBtn.disabled = !(ready && selected !== 'none');

                    if (ready && selected === 'none') {
                        const originalUrl = state.fileUrl; 
                        if(filteredImage.src?.startsWith('blob:') && filteredImage.src !== originalUrl) try { URL.revokeObjectURL(filteredImage.src); } catch(e){}
                        filteredImage.src = originalUrl || '';
                        filteredImage.style.display = originalUrl ? 'block' : 'none';
                        newFilterSizeSpan.textContent = state.file ? formatBytes(state.file.size) : '-';
                        if(downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                        downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    }
                 });

                 applyFilterBtn?.addEventListener('click', () => {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file;
                     const currentImage = state.imageObject;
                     const selected = filterTypeSelect.value;
                     if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && selected !== 'none') {
                         applyFilter(selected);
                     } else { alert("Select image and filter first."); }
                 });

                 addDropZoneListeners(toolId, 'filterDropZone', 'filterImageFile', false, "image/*");

                 function applyFilter(filterType) {
                     const state = toolState[toolId] || {};
                     const file = state.file;
                     const imageObj = state.imageObject;
                     if (!file || !imageObj?.complete || !imageObj.naturalWidth > 0) return;
                     if (filterType === 'none') return;

                     filterTypeSelect.disabled = true; applyFilterBtn.disabled = true; processingMsg.style.display = 'flex';
                     if (filteredImage.src?.startsWith('blob:') && filteredImage.src !== state.fileUrl) try { URL.revokeObjectURL(filteredImage.src); } catch (e) {}
                     filteredImage.style.display = 'none';
                     if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                     newFilterSizeSpan.textContent = '-';

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     const w = imageObj.naturalWidth; const h = imageObj.naturalHeight;
                     canvas.width = w; canvas.height = h;
                     const mime = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                     if (mime === 'image/jpeg' || mime === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); }
                     else { ctx.clearRect(0, 0, w, h); }
                     ctx.drawImage(imageObj, 0, 0, w, h);
                     let imageData; try { imageData = ctx.getImageData(0, 0, w, h); } catch (e) { alert("Cannot get image data."); filterTypeSelect.disabled = false; applyFilterBtn.disabled = filterTypeSelect.value === 'none'; processingMsg.style.display = 'none'; return; }
                     let pixels = imageData.data;

                     try {
                         for (let i = 0; i < pixels.length; i += 4) {
                             const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2]; let nr, ng, nb;
                             switch(filterType) {
                                case 'grayscale': nr = ng = nb = Math.round(0.2126*r + 0.7152*g + 0.0722*b); break;
                                case 'sepia': nr = Math.min(255, Math.round(.393*r+.769*g+.189*b)); ng = Math.min(255, Math.round(.349*r+.686*g+.168*b)); nb = Math.min(255, Math.round(.272*r+.534*g+.131*b)); break;
                                case 'invert': nr=255-r; ng=255-g; nb=255-b; break;
                                case 'red': nr=r; ng=0; nb=0; break; case 'green': nr=0; ng=g; nb=0; break; case 'blue': nr=0; ng=0; nb=b; break;
                                default: nr=r; ng=g; nb=b; break;
                             }
                             pixels[i]=nr; pixels[i+1]=ng; pixels[i+2]=nb;
                         }
                         ctx.putImageData(imageData, 0, 0);
                     } catch(error) { console.error("Filter Error:", error); alert("Error applying filter."); filterTypeSelect.disabled=false; applyFilterBtn.disabled=true; processingMsg.style.display='none'; return; }

                     canvas.toBlob((blob) => {
                         if (blob) { updateFilterOutput(blob, file.name, mime); }
                         else { alert("Filtering failed."); newFilterSizeSpan.textContent = 'Failed'; }
                          const currentState = toolState[toolId] || {};
                         filterTypeSelect.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                         applyFilterBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && filterTypeSelect.value !== 'none');
                         processingMsg.style.display = 'none';
                     }, mime, 0.85);
                 }
                 function updateFilterOutput(blob, name, mime) {
                      const state = toolState[toolId] || {};
                      if (filteredImage.src?.startsWith('blob:') && filteredImage.src !== state.fileUrl) try { URL.revokeObjectURL(filteredImage.src); } catch (e) {}
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                      const url = URL.createObjectURL(blob);
                      toolState[toolId].resultBlobUrl = url;

                      newFilterSizeSpan.textContent = formatBytes(blob.size);
                      filteredImage.src = url; filteredImage.alt = `Filtered Image (${name})`; filteredImage.style.display = 'block';
                      downloadLink.href = url;
                      let ext = mime.split('/')[1] || 'jpg'; if(ext==='jpeg') ext='jpg';
                      downloadLink.download = `filtered_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                      downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image to Base64 Converter ---
            function setupImageToBase64UI(file, imgUrl) {
                const toolId = 'image-to-base64';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId];
                const imageObj = state.imageObject;

                section.querySelector('#imgToBase64FileName').textContent = file.name;
                section.querySelector('#imgToBase64OriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#imgToBase64StringLength').textContent = '-';
                section.querySelector('#imgToBase64Info').style.display = 'block';

                const originalPreview = section.querySelector('#imgToBase64OriginalPreview');
                originalPreview.src = imgUrl;
                originalPreview.alt = `Original: ${file.name}`;
                originalPreview.style.display = 'block';
                section.querySelector('#imgToBase64ImagePreview').style.display = 'block';

                section.querySelector('#imgToBase64OutputArea').style.display = 'none';
                section.querySelector('#imgToBase64ResultText').value = '';
                section.querySelector('#copyBase64Btn').disabled = true;
                section.querySelector('#copyBase64Btn').textContent = 'Copy to Clipboard';

                performImageToBase64Conversion(file, imageObj);
            }
            function setupImageToBase64Listeners() {
                const toolId = 'image-to-base64';
                addDropZoneListeners(toolId, 'imgToBase64DropZone', 'imgToBase64File', false, "image/*");

                const section = document.getElementById(toolId + '-section');
                const copyBtn = section.querySelector('#copyBase64Btn');
                const resultTextArea = section.querySelector('#imgToBase64ResultText');

                copyBtn.addEventListener('click', () => {
                    if (resultTextArea.value) {
                        navigator.clipboard.writeText(resultTextArea.value)
                            .then(() => {
                                copyBtn.textContent = 'Copied!';
                                setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
                            })
                            .catch(err => {
                                console.error('Failed to copy Base64: ', err);
                                alert('Failed to copy. Please try manually.');
                            });
                    }
                });
            }
            function performImageToBase64Conversion(file, imageObj) {
                const toolId = 'image-to-base64';
                const section = document.getElementById(toolId + '-section');
                const processingMsg = section.querySelector('#imgToBase64ProcessingMsg');
                const outputArea = section.querySelector('#imgToBase64OutputArea');
                const resultTextEl = section.querySelector('#imgToBase64ResultText');
                const stringLengthSpan = section.querySelector('#imgToBase64StringLength');
                const copyBtn = section.querySelector('#copyBase64Btn');

                processingMsg.style.display = 'flex';
                outputArea.style.display = 'none';
                resultTextEl.value = '';
                copyBtn.disabled = true;

                const reader = new FileReader();
                reader.onloadend = function() {
                    const base64String = reader.result;
                    resultTextEl.value = base64String;
                    stringLengthSpan.textContent = base64String.length;
                    outputArea.style.display = 'block';
                    copyBtn.disabled = false;
                    processingMsg.style.display = 'none';
                }
                reader.onerror = function() {
                    alert("Failed to read file for Base64 conversion.");
                    processingMsg.style.display = 'none';
                }
                reader.readAsDataURL(file);
            }

            // --- Base64 to Image Converter ---
            function setupBase64ToImageUI() { 
                const toolId = 'base64-to-image';
                const section = document.getElementById(toolId + '-section');
                if (toolState[toolId]?.isInitialized && section.querySelector('#base64ToImageInput').value) {
                    section.querySelector('#base64ToImageConvertBtn').disabled = !section.querySelector('#base64ToImageInput').value.trim().startsWith('data:image');
                    return;
                }

                const inputTextArea = section.querySelector('#base64ToImageInput');
                const convertBtn = section.querySelector('#base64ToImageConvertBtn');
                const previewImg = section.querySelector('#base64ToImageResultPreview');
                const outputInfo = section.querySelector('#base64ToImageOutputInfo');
                const downloadLink = section.querySelector('#base64ToImageDownloadLink');
                const downloadMessage = section.querySelector('#base64ToImageDownloadMessage');

                inputTextArea.value = '';
                convertBtn.disabled = true;
                if (previewImg.src?.startsWith('blob:')) try {URL.revokeObjectURL(previewImg.src);} catch(e){}
                if (toolState[toolId]?.resultBlobUrl) try {URL.revokeObjectURL(toolState[toolId].resultBlobUrl);} catch(e){}

                previewImg.src = ''; previewImg.style.display = 'none';
                section.querySelector('#base64ToImagePreview').style.display = 'none';
                outputInfo.style.display = 'none';
                downloadLink.style.display = 'none';
                downloadMessage.style.display = 'none';

                toolState[toolId] = { isInitialized: true, resultBlobUrl: null };
            }
            function setupBase64ToImageListeners() {
                const toolId = 'base64-to-image';
                const section = document.getElementById(toolId + '-section');
                const inputTextArea = section.querySelector('#base64ToImageInput');
                const convertBtn = section.querySelector('#base64ToImageConvertBtn');
                const formatSelect = section.querySelector('#base64ToImageOutputFormat');
                const processingMsg = section.querySelector('#base64ToImageProcessingMsg');
                const previewImg = section.querySelector('#base64ToImageResultPreview');
                const previewContainer = section.querySelector('#base64ToImagePreview');
                const outputInfoDiv = section.querySelector('#base64ToImageOutputInfo');
                const detectedFormatSpan = section.querySelector('#base64ToImageDetectedFormat');
                const dimensionsSpan = section.querySelector('#base64ToImageDimensions');
                const newSizeSpan = section.querySelector('#base64ToImageNewSize');
                const downloadLink = section.querySelector('#base64ToImageDownloadLink');
                const downloadMessage = section.querySelector('#base64ToImageDownloadMessage');

                inputTextArea.addEventListener('input', () => {
                    convertBtn.disabled = !inputTextArea.value.trim().startsWith('data:image');
                });

                convertBtn.addEventListener('click', () => {
                    const base64String = inputTextArea.value.trim();
                    if (!base64String.startsWith('data:image')) {
                        alert("Invalid Base64 image data string. It should start with 'data:image/...'.");
                        return;
                    }
                    performBase64ToImageConversion(base64String, formatSelect.value);
                });

                function performBase64ToImageConversion(base64String, outputMime) {
                    processingMsg.style.display = 'flex';
                    convertBtn.disabled = true; inputTextArea.disabled = true; formatSelect.disabled = true;

                    if (previewImg.src?.startsWith('blob:')) try {URL.revokeObjectURL(previewImg.src);} catch(e){}
                    if (toolState[toolId]?.resultBlobUrl) try {URL.revokeObjectURL(toolState[toolId].resultBlobUrl);} catch(e){}
                    toolState[toolId].resultBlobUrl = null;

                    previewImg.src = ''; previewImg.style.display = 'none';
                    previewContainer.style.display = 'none';
                    outputInfoDiv.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) try {URL.revokeObjectURL(downloadLink.href);} catch(e){}
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';


                    const img = new Image();
                    img.onload = () => {
                        detectedFormatSpan.textContent = img.src.substring(5, img.src.indexOf(';')).toUpperCase();
                        dimensionsSpan.textContent = `${img.naturalWidth} x ${img.naturalHeight}`;
                        previewImg.src = img.src; 
                        previewImg.style.display = 'block';
                        previewContainer.style.display = 'block';

                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        if (outputMime === 'image/jpeg') {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                        ctx.drawImage(img, 0, 0);
                        canvas.toBlob(blob => {
                            if (blob) {
                                const blobUrl = URL.createObjectURL(blob);
                                toolState[toolId].resultBlobUrl = blobUrl;

                                newSizeSpan.textContent = formatBytes(blob.size);
                                outputInfoDiv.style.display = 'block';

                                downloadLink.href = blobUrl;
                                const ext = outputMime.split('/')[1];
                                downloadLink.download = `image_from_base64.${ext}`;
                                downloadLink.style.display = 'inline-block';
                                downloadMessage.style.display = 'block';
                            } else {
                                alert("Failed to convert image for download.");
                            }
                            processingMsg.style.display = 'none';
                            convertBtn.disabled = false; inputTextArea.disabled = false; formatSelect.disabled = false;
                        }, outputMime, 0.9);
                    };
                    img.onerror = () => {
                        alert("Failed to load image from Base64 string. Ensure it's a valid image data URL.");
                        processingMsg.style.display = 'none';
                        convertBtn.disabled = false; inputTextArea.disabled = false; formatSelect.disabled = false;
                    };
                    img.src = base64String;
                }
            }

            // --- Image Color Picker (NEW) ---
            function setupImageColorPickerUI(file, imgUrl) {
                const toolId = 'image-color-picker';
                const section = document.getElementById(toolId + '-section');
                const imageObj = toolState[toolId].imageObject;


                section.querySelector('#colorPickerFileName').textContent = file.name;
                section.querySelector('#colorPickerDimensions').textContent = `${imageObj.naturalWidth}x${imageObj.naturalHeight}`;
                section.querySelector('#colorPickerImageInfo').style.display = 'block';

                const canvas = section.querySelector('#colorPickerCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageObj.naturalWidth;
                canvas.height = imageObj.naturalHeight;
                ctx.drawImage(imageObj, 0, 0);
                canvas.style.display = 'block';
                
                section.querySelector('#colorPickerPreviewArea').style.display = 'block';
                section.querySelector('#colorPickerCanvasContainer').style.cursor = 'crosshair';
                section.querySelector('#colorPickerOutputDisplay').style.display = 'none';
                section.querySelector('#colorPickerProcessingMsg').style.display = 'none';
            }

            function setupImageColorPickerListeners() {
                const toolId = 'image-color-picker';
                addDropZoneListeners(toolId, 'colorPickerDropZone', 'colorPickerImageFile', false, "image/*");
                
                const section = document.getElementById(toolId + '-section');
                const canvas = section.querySelector('#colorPickerCanvas');
                const outputDisplay = section.querySelector('#colorPickerOutputDisplay');
                const previewBox = section.querySelector('#colorPickerPreviewBox');
                const hexValueSpan = section.querySelector('#colorPickerHexValue');
                const rgbValueSpan = section.querySelector('#colorPickerRgbValue');

                canvas.addEventListener('click', (event) => {
                    const state = toolState[toolId];
                    if (!state || !state.imageObject || !canvas.getContext) return;

                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;

                    const x = Math.floor((event.clientX - rect.left) * scaleX);
                    const y = Math.floor((event.clientY - rect.top) * scaleY);
                    
                    try {
                        const pixelData = ctx.getImageData(x, y, 1, 1).data;
                        const r = pixelData[0];
                        const g = pixelData[1];
                        const b = pixelData[2];

                        const hex = "#" + ("000000" + ((r << 16) | (g << 8) | b).toString(16)).slice(-6).toUpperCase();
                        const rgb = `RGB(${r}, ${g}, ${b})`;

                        previewBox.style.backgroundColor = hex;
                        hexValueSpan.textContent = `HEX: ${hex}`;
                        rgbValueSpan.textContent = rgb;
                        outputDisplay.style.display = 'block';
                    } catch (e) {
                        console.error("Error picking color: ", e);
                        alert("Could not pick color. Please try clicking within the image boundaries.");
                    }
                });
            }

             // --- Image Watermark (Overlay) ---
            function setupImageWatermarkMainUI(file, imgUrl) {
                const toolId = 'image-watermark'; 
                const section = document.getElementById(toolId + '-section');
                
                toolState[toolId] = toolState[toolId] || {}; 
                
                section.querySelector('#watermarkMainFileName').textContent = file.name;
                section.querySelector('#watermarkOriginalMainPreview').src = imgUrl;
                section.querySelector('#watermarkOriginalMainPreview').style.display = 'block';
                section.querySelector('#imageWatermarkPreview').style.display = 'block'; 
                section.querySelector('#imageWatermarkInfo').style.display = 'block';
                section.querySelector('#watermarkImageUploadContainer').style.display = 'block'; 
                
                toolState[toolId].watermarkImageFile = null;
                toolState[toolId].watermarkImageUrl = null;
                toolState[toolId].watermarkImageObject = null; // Reset this specifically
                section.querySelector('#watermarkOverlayFileName').textContent = '-';
                section.querySelector('#watermarkControlsContainer').style.display = 'none';
                section.querySelector('#applyImageWatermarkBtn').disabled = true;
                const resultImg = section.querySelector('#watermarkedResultImage');
                if (resultImg.src?.startsWith('blob:')) try {URL.revokeObjectURL(resultImg.src);}catch(e){}
                resultImg.src = '';
                resultImg.style.display = 'none';
                section.querySelector('#watermarkedResultSize').textContent = '-'; 
            }

            function setupImageWatermarkOverlayUI(file, imgUrl) {
                const toolId = 'image-watermark'; 
                const section = document.getElementById(toolId + '-section');

                if (!toolState[toolId] || !toolState[toolId].mainImageObject) {
                    alert("Please upload the main image first.");
                    resetToolState(toolId); 
                    return;
                }

                section.querySelector('#watermarkOverlayFileName').textContent = file.name;
                section.querySelector('#watermarkControlsContainer').style.display = 'flex';
                section.querySelector('#applyImageWatermarkBtn').disabled = false;
                applyImageWatermark(true); 
            }
            
            async function applyImageWatermark(previewOnly = false) {
                const toolId = 'image-watermark';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId];

                if (!state || !state.mainImageObject || !state.watermarkImageObject || 
                    !state.mainImageObject.complete || state.mainImageObject.naturalWidth === 0 ||
                    !state.watermarkImageObject.complete || state.watermarkImageObject.naturalWidth === 0) {
                    if(!previewOnly) alert("Please ensure both main and watermark images are loaded correctly.");
                    section.querySelector('#imageWatermarkProcessingMsg').style.display = 'none';
                    section.querySelector('#applyImageWatermarkBtn').disabled = !(state?.mainImageObject && state?.watermarkImageObject);
                    return;
                }

                const mainImg = state.mainImageObject;
                const watermarkImg = state.watermarkImageObject;
                const opacity = parseFloat(section.querySelector('#watermarkOpacitySlider').value);
                const scalePercent = parseInt(section.querySelector('#watermarkScaleSlider').value, 10);
                const position = section.querySelector('#watermarkPosition').value;

                const processingMsg = section.querySelector('#imageWatermarkProcessingMsg');
                const applyBtn = section.querySelector('#applyImageWatermarkBtn');
                const resultImgEl = section.querySelector('#watermarkedResultImage');
                const downloadLink = section.querySelector('#imageWatermarkDownloadLink');
                const downloadMessage = section.querySelector('#imageWatermarkDownloadMessage');
                
                applyBtn.disabled = true;
                processingMsg.style.display = 'flex';
                if (!previewOnly) {
                    downloadLink.style.display = 'none';
                    downloadMessage.style.display = 'none';
                    if (state.resultBlobUrl && state.resultBlobUrl !== resultImgEl.src) {
                        try { URL.revokeObjectURL(state.resultBlobUrl); } catch(e){}
                        state.resultBlobUrl = null;
                    }
                }
                if (previewOnly && resultImgEl.src && resultImgEl.src.startsWith('blob:') && resultImgEl.src !== state.resultBlobUrl) {
                    try { URL.revokeObjectURL(resultImgEl.src); } catch (e) {}
                }


                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = mainImg.naturalWidth;
                canvas.height = mainImg.naturalHeight;

                ctx.drawImage(mainImg, 0, 0);

                let wmWidth = watermarkImg.naturalWidth;
                let wmHeight = watermarkImg.naturalHeight;
                const scaleFactor = (scalePercent / 100) * (mainImg.naturalWidth / watermarkImg.naturalWidth) ; 
                
                wmWidth = watermarkImg.naturalWidth * scaleFactor; 
                wmHeight = watermarkImg.naturalHeight * scaleFactor;


                ctx.globalAlpha = opacity;

                const margin = 20; 

                if (position === 'tile') {
                    const patternCanvas = document.createElement('canvas');
                    const patternCtx = patternCanvas.getContext('2d');
                    const tileSpacing = margin * 2; 
                    patternCanvas.width = wmWidth + tileSpacing; 
                    patternCanvas.height = wmHeight + tileSpacing;
                    patternCtx.drawImage(watermarkImg, tileSpacing / 2, tileSpacing / 2, wmWidth, wmHeight);
                    const pattern = ctx.createPattern(patternCanvas, 'repeat');
                    if (pattern) { 
                        ctx.fillStyle = pattern;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    } else {
                        console.warn("Failed to create tile pattern for watermark.");
                        let x = (canvas.width - wmWidth) / 2; 
                        let y = (canvas.height - wmHeight) / 2;
                        ctx.drawImage(watermarkImg, x, y, wmWidth, wmHeight);
                    }
                } else {
                    let x, y;
                    switch (position) {
                        case 'top-left': x = margin; y = margin; break;
                        case 'top-right': x = canvas.width - wmWidth - margin; y = margin; break;
                        case 'bottom-left': x = margin; y = canvas.height - wmHeight - margin; break;
                        case 'center': x = (canvas.width - wmWidth) / 2; y = (canvas.height - wmHeight) / 2; break;
                        case 'bottom-right':
                        default:
                            x = canvas.width - wmWidth - margin; y = canvas.height - wmHeight - margin; break;
                    }
                    ctx.drawImage(watermarkImg, x, y, wmWidth, wmHeight);
                }
                
                ctx.globalAlpha = 1.0; 

                const resultMimeType = state.mainImageFile.type.startsWith('image/png') ? 'image/png' : 'image/jpeg';
                const resultBlob = await new Promise(resolve => canvas.toBlob(resolve, resultMimeType, 0.9)); 
                
                if (resultBlob) {
                    const objectUrl = URL.createObjectURL(resultBlob);
                    resultImgEl.src = objectUrl; 
                    resultImgEl.style.display = 'block';
                    section.querySelector('#imageWatermarkPreview').style.display = 'block';
                    
                    if (!previewOnly) {
                        state.resultBlobUrl = objectUrl; 
                        section.querySelector('#watermarkedResultSize').textContent = formatBytes(resultBlob.size);
                        section.querySelector('#imageWatermarkInfo').style.display = 'block';
                        
                        downloadLink.href = objectUrl;
                        let ext = (resultMimeType.split('/')[1] || 'jpg');
                        if (ext === 'jpeg') ext = 'jpg';
                        downloadLink.download = `watermarked_${state.mainImageFile.name.substring(0, state.mainImageFile.name.lastIndexOf('.')) || state.mainImageFile.name}.${ext}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';
                    }
                } else {
                    if(!previewOnly) alert("Failed to apply watermark.");
                }
                
                processingMsg.style.display = 'none';
                applyBtn.disabled = false;
            }


            function setupImageWatermarkListeners() {
                const toolId = 'image-watermark';
                const section = document.getElementById(toolId + '-section');

                addDropZoneListeners('image-watermark-main', 'watermarkMainImageDropZone', 'watermarkMainImageFile', false, "image/*");
                addDropZoneListeners('image-watermark-overlay', 'watermarkOverlayImageDropZone', 'watermarkOverlayImageFile', false, "image/png,image/jpeg,image/webp");
                
                const opacitySlider = section.querySelector('#watermarkOpacitySlider');
                const opacityValue = section.querySelector('#watermarkOpacityValue');
                const scaleSlider = section.querySelector('#watermarkScaleSlider');
                const scaleValue = section.querySelector('#watermarkScaleValue');
                const positionSelect = section.querySelector('#watermarkPosition');
                const applyBtn = section.querySelector('#applyImageWatermarkBtn');

                const updatePreview = () => {
                    if (toolState[toolId]?.mainImageObject && toolState[toolId]?.watermarkImageObject) {
                        applyImageWatermark(true); 
                    }
                };

                opacitySlider.addEventListener('input', () => {
                    opacityValue.textContent = opacitySlider.value;
                    updatePreview();
                });
                scaleSlider.addEventListener('input', () => {
                    scaleValue.textContent = scaleSlider.value + '%';
                    updatePreview();
                });
                positionSelect.addEventListener('change', updatePreview);

                applyBtn.addEventListener('click', () => {
                    applyImageWatermark(false); 
                });
            }


            // --- PDF Tools ---
            function setupJpgToPdfUI(fileObjects) {
                 const section = document.getElementById('jpg-to-pdf-section');
                 const fileListUl = section.querySelector('#jpgToPdfFilesListUl');
                 const thumbnailsContainer = section.querySelector('#jpgThumbnailsContainer');
                 const resultEmbed = section.querySelector('#jpgToPdfResultPreviewEmbed');
                 const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');

                 fileListUl.innerHTML = ''; thumbnailsContainer.innerHTML = '';
                 if (successMsg) successMsg.style.display = 'none';
                 if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                 resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                 if (fileObjects.length > 0) {
                     fileObjects.forEach(obj => {
                          const li = document.createElement('li'); li.textContent = `${obj.file.name} (${formatBytes(obj.file.size)})`; fileListUl.appendChild(li);
                          const img = document.createElement('img'); img.src = obj.url; img.alt = `Preview ${obj.file.name}`; img.style.display = 'inline-block'; thumbnailsContainer.appendChild(img);
                      });
                     section.querySelector('#jpgToPdfFileList').style.display = 'block';
                     section.querySelector('#jpgToPdfPreviewContainer').style.display = 'block';
                     section.querySelector('#convertToPdfBtn').disabled = false;
                 } else {
                      section.querySelector('#jpgToPdfFileList').style.display = 'none';
                      section.querySelector('#jpgToPdfPreviewContainer').style.display = 'none';
                      section.querySelector('#convertToPdfBtn').disabled = true;
                 }
                 section.querySelector('#jpgToPdfOutputInfo').style.display = 'none';
                 section.querySelector('#jpgToPdfResultText').textContent = '';
                 const dl = section.querySelector('#jpgToPdfDownloadLink');
                 const dlMsg = section.querySelector('#jpgToPdfDownloadMessage');
                 if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                 dl.style.display = 'none'; dlMsg.style.display = 'none';
             }
            function setupJpgToPdfListeners() {
                 const toolId = 'jpg-to-pdf';
                 addDropZoneListeners(toolId, 'jpgToPdfDropZone', 'jpgToPdfFilesInput', true, "image/jpeg");
                 const section = document.getElementById(toolId + '-section');
                 const convertBtn = section.querySelector('#convertToPdfBtn');
                  const processingMsg = section.querySelector('#jpgToPdfProcessingMsg');
                  const downloadLink = section.querySelector('#jpgToPdfDownloadLink');
                  const downloadMessage = section.querySelector('#jpgToPdfDownloadMessage');
                  const outputInfo = section.querySelector('#jpgToPdfOutputInfo');
                  const resultText = section.querySelector('#jpgToPdfResultText');
                  const resultEmbed = section.querySelector('#jpgToPdfResultPreviewEmbed');
                  const successMsgElementJP = resultEmbed.parentNode.querySelector('.preview-success-message');

                 convertBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFiles = state.files || [];

                     if (currentFiles.length === 0) { alert("Please select JPG files first."); return; }
                     if (!jspdfInstance?.jsPDF) { alert("jsPDF library not loaded."); return; }

                     convertBtn.disabled = true; processingMsg.style.display = 'flex';
                     outputInfo.style.display = 'none';
                     if (successMsgElementJP) successMsgElementJP.style.display = 'none';
                     if(resultEmbed.src?.startsWith('blob:')) try{URL.revokeObjectURL(resultEmbed.src); }catch(e){}
                     resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                     if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     const { jsPDF } = jspdfInstance; const pdf = new jsPDF({ unit: 'pt', format: 'a4', compress: true });
                     let pdfBlob;
                     try {
                         for (let i = 0; i < currentFiles.length; i++) {
                             const fileObj = currentFiles[i];
                             processingMsg.textContent = `Processing image ${i + 1}/${currentFiles.length}...`;
                             const img = new Image(); img.src = fileObj.url;
                             await new Promise((resolve, reject) => {
                                 img.onload = () => {
                                     const iw = img.naturalWidth, ih = img.naturalHeight; if(iw === 0 || ih === 0) return reject(`Img ${i+1} bad dims`);
                                     const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
                                     const ratio = iw / ih; let nw = pw - 20, nh = nw / ratio;
                                     if (nh > ph - 20) { nh = ph - 20; nw = nh * ratio; }
                                     const x = (pw - nw) / 2, y = (ph - nh) / 2;
                                     if (i > 0) pdf.addPage();
                                     const cvs = document.createElement('canvas'); cvs.width=iw; cvs.height=ih; cvs.getContext('2d').drawImage(img,0,0);
                                     pdf.addImage(cvs.toDataURL('image/jpeg'), 'JPEG', x, y, nw, nh);
                                     resolve();
                                 };
                                 img.onerror = (err) => reject(`Could not load image ${i+1}: ${err}`);
                             });
                         }
                         processingMsg.textContent = 'Generating PDF...';
                         pdfBlob = pdf.output('blob'); const pdfUrl = URL.createObjectURL(pdfBlob);
                         toolState[toolId].resultBlobUrl = pdfUrl;

                         resultEmbed.src = pdfUrl; resultEmbed.style.display = 'block';
                         downloadLink.href = pdfUrl; downloadLink.download = 'converted_images.pdf';
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${currentFiles.length} JPG(s) converted. PDF Size: ${formatBytes(pdfBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementJP) { successMsgElementJP.textContent = `PDF generated! (${currentFiles.length} images, ${formatBytes(pdfBlob.size)})`; successMsgElementJP.style.display = 'block'; }
                     } catch (error) {
                          console.error("JPG to PDF Error:", error); alert(`Error: ${error.message || error}`);
                          resultText.textContent = `Conversion failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                     } 
                     finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                         const currentState = toolState[toolId] || {};
                         convertBtn.disabled = (currentState.files?.length || 0) === 0;
                     }
                 });
             }
            async function setupPdfToJpgUI(file, url) {
                  const toolId = 'pdf-to-jpg';
                  const section = document.getElementById(toolId + '-section');
                  section.querySelector('#pdfToJpgFileName').textContent = file.name;
                  section.querySelector('#pdfToJpgFileSize').textContent = formatBytes(file.size);
                  section.querySelector('#pdfToJpgPageCount').textContent = 'Loading...';
                  section.querySelector('#pdfToJpgFileInfo').style.display = 'block';
                  section.querySelector('#convertToJpgsBtn').disabled = true;
                  section.querySelector('#pdfToJpgOutputInfo').style.display = 'none';
                  section.querySelector('#pdfToJpgResultText').textContent = '';
                  section.querySelector('#pdfToJpgPreviewContainer').style.display = 'none';
                  const previewImg = section.querySelector('#pdfOriginalFirstPagePreview');
                  if(previewImg.src?.startsWith('blob:')) try{ URL.revokeObjectURL(previewImg.src); } catch(e){}
                  previewImg.src = ''; previewImg.style.display = 'none';
                  section.querySelector('#pdfResultThumbnailsContainer').innerHTML = '';
                  const dl = section.querySelector('#pdfToJpgDownloadLink');
                  const dlMsg = section.querySelector('#pdfToJpgDownloadMessage');
                   if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                  dl.style.display = 'none'; dlMsg.style.display = 'none';
                  const successMsg = section.querySelector('#pdfResultThumbnailsContainer')?.closest('.preview-comparison > div')?.querySelector('.preview-success-message');
                  if(successMsg) successMsg.style.display = 'none';

                  if (!pdfjsLibInstance) { alert("pdf.js failed to load."); return; }
                  let firstPageUrl = null;
                  try {
                     const arrayBuffer = await file.arrayBuffer();
                     const pdfDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer }).promise;
                     section.querySelector('#pdfToJpgPageCount').textContent = pdfDoc.numPages;
                     if (pdfDoc.numPages > 0) {
                          const page = await pdfDoc.getPage(1); const viewport = page.getViewport({ scale: 0.5 });
                          const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                          canvas.width = viewport.width; canvas.height = viewport.height;
                          ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                          await page.render({ canvasContext: ctx, viewport }).promise;
                          const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
                          if(blob) {
                              firstPageUrl = URL.createObjectURL(blob);
                              previewImg.src = firstPageUrl; previewImg.style.display = 'block';
                              section.querySelector('#pdfToJpgPreviewContainer').style.display = 'block';
                              if(toolState[toolId]) toolState[toolId].firstPagePreviewUrl = firstPageUrl;
                          }
                     }
                     section.querySelector('#convertToJpgsBtn').disabled = false;
                  } catch (err) {
                     console.error("PDF Preview Error:", err); alert(`PDF Preview Error: ${err.message}`);
                     if(firstPageUrl) URL.revokeObjectURL(firstPageUrl); resetToolState(toolId);
                  }
            }
            function setupPdfToJpgListeners() {
                  const toolId = 'pdf-to-jpg';
                 addDropZoneListeners(toolId, 'pdfToJpgDropZone', 'pdfToJpgFileInput', false, "application/pdf");
                 const section = document.getElementById(toolId + '-section');
                 const convertBtn = section.querySelector('#convertToJpgsBtn');
                  const processingMsg = section.querySelector('#pdfToJpgProcessingMsg');
                  const downloadLink = section.querySelector('#pdfToJpgDownloadLink');
                  const downloadMessage = section.querySelector('#pdfToJpgDownloadMessage');
                  const outputInfo = section.querySelector('#pdfToJpgOutputInfo');
                  const resultText = section.querySelector('#pdfToJpgResultText');
                  const previewContainer = section.querySelector('#pdfToJpgPreviewContainer');
                  const resultThumbnailsContainer = section.querySelector('#pdfResultThumbnailsContainer');
                  const successMsgElementPJ = resultThumbnailsContainer.closest('.preview-comparison > div')?.querySelector('.preview-success-message');
                  const maxPreviewPages = 5;

                 convertBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file;

                     if (!currentFile) { alert("Please select a PDF file first."); return; }
                     if (!pdfjsLibInstance || !jszipInstance) { alert("Required libraries not loaded."); return; }

                     convertBtn.disabled = true; processingMsg.style.display = 'flex';
                     outputInfo.style.display = 'none'; resultThumbnailsContainer.innerHTML = '';
                     if (successMsgElementPJ) successMsgElementPJ.style.display = 'none';
                     if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     let arrayBuffer;
                     try { arrayBuffer = await currentFile.arrayBuffer(); }
                     catch (e) { alert("Error reading file."); processingMsg.style.display = 'none'; convertBtn.disabled = !toolState[toolId]?.file; return; }

                     let pdfDoc, previewBlobUrls = [], numPages = 0, zipBlob;
                     try {
                         pdfDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer }).promise;
                         numPages = pdfDoc.numPages; if (numPages === 0) throw new Error("PDF has no pages.");
                         const zip = new jszipInstance(); const quality = 0.9;

                         for (let i = 1; i <= numPages; i++) {
                             processingMsg.textContent = `Processing page ${i}/${numPages}...`;
                             const page = await pdfDoc.getPage(i); const vp = page.getViewport({ scale: 2.0 });
                             const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                             canvas.width = vp.width; canvas.height = vp.height; ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                             await page.render({ canvasContext: ctx, viewport: vp }).promise;
                             const jpgBlob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
                             if (!jpgBlob) throw new Error(`Failed JPG for page ${i}`);
                             zip.file(`page_${String(i).padStart(3, '0')}.jpg`, jpgBlob);
                             if (i <= maxPreviewPages) {
                                 const url = URL.createObjectURL(jpgBlob); previewBlobUrls.push(url);
                                 const img = document.createElement('img'); img.src = url; img.alt = `Page ${i} Preview`; img.style.display = 'inline-block';
                                 resultThumbnailsContainer.appendChild(img);
                             }
                         }
                         if(previewBlobUrls.length > 0 && previewContainer) previewContainer.style.display = 'block';
                         processingMsg.textContent = 'Zipping...';
                         zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                         const zipUrl = URL.createObjectURL(zipBlob);
                         toolState[toolId].resultBlobUrl = zipUrl; 

                         downloadLink.href = zipUrl; downloadLink.download = `${currentFile.name.replace(/\.pdf$/i, '')}_jpgs.zip`;
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${numPages} page(s) converted. ZIP Size: ${formatBytes(zipBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementPJ) { successMsgElementPJ.textContent = `Converted to ${numPages} JPG(s)! (ZIP: ${formatBytes(zipBlob.size)})`; successMsgElementPJ.style.display = 'block'; }
                     } catch (error) {
                         console.error("PDF to JPG Error:", error); alert(`Error: ${error.message || error}`);
                         resultText.textContent = `Conversion failed: ${error.message || error}`; outputInfo.style.display = 'block';
                         section.querySelector('#pdfToJpgPageCount').textContent = pdfDoc ? pdfDoc.numPages : '?';
                     } finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                         convertBtn.disabled = !toolState[toolId]?.file;
                         previewBlobUrls.forEach(url => { try { URL.revokeObjectURL(url); } catch(e){} });
                     }
                 });
            }
            function setupMergePdfUI(fileObjects) {
                  const toolId = 'merge-pdf';
                  const section = document.getElementById(toolId + '-section');
                  const fileListUl = section.querySelector('#mergePdfFilesListUl');
                  const resultEmbed = section.querySelector('#mergePdfResultPreviewEmbed');
                  const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');

                  fileListUl.innerHTML = '';
                  if (successMsg) successMsg.style.display = 'none';
                  if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                  resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                  if (fileObjects.length >= 2) {
                       fileObjects.forEach(obj => {
                           const li = document.createElement('li'); li.textContent = `${obj.file.name} (${formatBytes(obj.file.size)})`; fileListUl.appendChild(li);
                       });
                      section.querySelector('#mergePdfFileList').style.display = 'block';
                      section.querySelector('#mergePdfPreviewContainer').style.display = 'block';
                      section.querySelector('#mergePdfsBtn').disabled = false;
                  } else {
                       section.querySelector('#mergePdfFileList').style.display = 'none';
                       section.querySelector('#mergePdfPreviewContainer').style.display = 'none';
                       section.querySelector('#mergePdfsBtn').disabled = true;
                       if (fileObjects.length === 1) { alert("Select at least two PDFs to merge."); }
                  }
                  section.querySelector('#mergePdfOutputInfo').style.display = 'none';
                  section.querySelector('#mergePdfResultText').textContent = '';
                   const dl = section.querySelector('#mergePdfDownloadLink');
                   const dlMsg = section.querySelector('#mergePdfDownloadMessage');
                    if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                   dl.style.display = 'none'; dlMsg.style.display = 'none';
              }
            function setupMergePdfListeners() {
                  const toolId = 'merge-pdf';
                 addDropZoneListeners(toolId, 'mergePdfDropZone', 'mergePdfFilesInput', true, "application/pdf");
                 const section = document.getElementById(toolId + '-section');
                 const mergeBtn = section.querySelector('#mergePdfsBtn');
                  const processingMsg = section.querySelector('#mergePdfProcessingMsg');
                  const downloadLink = section.querySelector('#mergePdfDownloadLink');
                  const downloadMessage = section.querySelector('#mergePdfDownloadMessage');
                  const outputInfo = section.querySelector('#mergePdfOutputInfo');
                  const resultText = section.querySelector('#mergePdfResultText');
                  const resultEmbed = section.querySelector('#mergePdfResultPreviewEmbed');
                  const successMsgElementMP = resultEmbed.parentNode.querySelector('.preview-success-message');

                 mergeBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFiles = state.files || [];

                     if (currentFiles.length < 2) { alert("Select at least two PDFs."); return; }
                     if (!pdfLibInstance?.PDFDocument) { alert("PDF-Lib not loaded."); return; }

                     mergeBtn.disabled = true; processingMsg.style.display = 'flex';
                     outputInfo.style.display = 'none';
                     if (successMsgElementMP) successMsgElementMP.style.display = 'none';
                      if(resultEmbed.src?.startsWith('blob:')) try{URL.revokeObjectURL(resultEmbed.src); }catch(e){}
                     resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     let totalPagesMerged = 0; let mergedBlob;
                     try {
                         const mergedPdf = await pdfLibInstance.PDFDocument.create();
                         for (let i = 0; i < currentFiles.length; i++) {
                             const fileObj = currentFiles[i];
                             processingMsg.textContent = `Processing PDF ${i + 1}/${currentFiles.length}...`;
                             const pdfToMerge = await pdfLibInstance.PDFDocument.load(await fileObj.file.arrayBuffer(), { ignoreEncryption: true });
                             const indices = pdfToMerge.getPageIndices();
                             if (indices.length === 0) { console.warn(`PDF ${i+1} skipped (no pages).`); continue; }
                             const copiedPages = await mergedPdf.copyPages(pdfToMerge, indices);
                             copiedPages.forEach(page => mergedPdf.addPage(page)); totalPagesMerged += indices.length;
                         }
                         if (totalPagesMerged === 0) throw new Error("No pages merged.");
                         processingMsg.textContent = 'Saving PDF...';
                         mergedBlob = new Blob([await mergedPdf.save()], { type: 'application/pdf' });
                         const mergedUrl = URL.createObjectURL(mergedBlob);
                         toolState[toolId].resultBlobUrl = mergedUrl;

                         resultEmbed.src = mergedUrl; resultEmbed.style.display = 'block';
                         downloadLink.href = mergedUrl; downloadLink.download = 'merged_document.pdf';
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${currentFiles.length} PDFs merged (${totalPagesMerged} pages). Size: ${formatBytes(mergedBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementMP) { successMsgElementMP.textContent = `PDFs merged! (${totalPagesMerged} pages, ${formatBytes(mergedBlob.size)})`; successMsgElementMP.style.display = 'block'; }
                     } catch (error) {
                          console.error("Merge PDF Error:", error); alert(`Merge Error: ${error.message || error}`);
                          resultText.textContent = `Merge failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                     } 
                     finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                         const currentState = toolState[toolId] || {};
                         mergeBtn.disabled = (currentState.files?.length || 0) < 2;
                     }
                 });
             }
            function parsePageRanges(rangeString, totalPages) {
                  const pages = new Set(); if (!rangeString || rangeString.trim() === '') return [];
                  const parts = rangeString.split(',');
                  for (const part of parts) {
                      const trimmed = part.trim();
                      if (/^\d+$/.test(trimmed)) { const p = parseInt(trimmed, 10); if (p > 0 && p <= totalPages) pages.add(p - 1); else throw new Error(`Page ${p} out of range (1-${totalPages})`); }
                      else if (/^\d+-\d+$/.test(trimmed)) { const [s, e] = trimmed.split('-').map(n => parseInt(n, 10)); if (s > 0 && e >= s && e <= totalPages) { for (let i = s; i <= e; i++) pages.add(i - 1); } else throw new Error(`Range ${s}-${e} invalid (max: ${totalPages})`); }
                      else if (trimmed !== '') throw new Error(`Invalid format: "${trimmed}"`);
                  }
                  if (pages.size === 0 && rangeString.trim() !== '') throw new Error("No valid pages selected.");
                  return Array.from(pages).sort((a, b) => a - b);
             }
            async function setupSplitPdfUI(file, url) {
                  const toolId = 'split-pdf';
                  const section = document.getElementById(toolId + '-section');
                  section.querySelector('#splitPdfFileName').textContent = file.name;
                  section.querySelector('#splitPdfFileSize').textContent = formatBytes(file.size);
                  section.querySelector('#splitPdfTotalPages').textContent = 'Loading...';
                  section.querySelector('#splitPdfFileInfo').style.display = 'block';
                  section.querySelector('#splitPageRange').disabled = true; section.querySelector('#splitPageRange').value = '';
                  section.querySelector('#splitPdfBtn').disabled = true;
                  section.querySelector('#splitPdfOutputInfo').style.display = 'none';
                  section.querySelector('#splitPdfResultText').textContent = '';
                  section.querySelector('#splitPdfPreviewContainer').style.display = 'none';
                  const previewImg = section.querySelector('#splitPdfOriginalPreview');
                  if(previewImg.src?.startsWith('blob:')) try{ URL.revokeObjectURL(previewImg.src); } catch(e){}
                  previewImg.src = ''; previewImg.style.display = 'none';
                  const resultEmbed = section.querySelector('#splitPdfResultPreviewEmbed');
                  const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');
                  if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                  resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                  if(successMsg) successMsg.style.display = 'none';
                  const dl = section.querySelector('#splitPdfDownloadLink');
                  const dlMsg = section.querySelector('#splitPdfDownloadMessage');
                  if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                  dl.style.display = 'none'; dlMsg.style.display = 'none';

                  splitPdfDocObject = null; 
                  let firstPageUrl = null;
                  if (!pdfLibInstance?.PDFDocument || !pdfjsLibInstance) { alert("PDF libraries not loaded."); return; }
                  try {
                     const arrayBuffer = await file.arrayBuffer();
                     const tempPdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                     const numPages = tempPdfDoc.getPageCount();
                     section.querySelector('#splitPdfTotalPages').textContent = numPages;

                     if(numPages > 0) {
                         const pdfjsDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer.slice(0) }).promise;
                         const page = await pdfjsDoc.getPage(1); const viewport = page.getViewport({ scale: 0.5 });
                         const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                         canvas.width = viewport.width; canvas.height = viewport.height; ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                         await page.render({ canvasContext: ctx, viewport }).promise;
                         const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
                         if(blob){
                             firstPageUrl = URL.createObjectURL(blob);
                             previewImg.src = firstPageUrl; previewImg.style.display = 'block';
                             section.querySelector('#splitPdfPreviewContainer').style.display = 'block';
                              if(toolState[toolId]) toolState[toolId].firstPagePreviewUrl = firstPageUrl;
                          }
                     }
                     section.querySelector('#splitPageRange').disabled = (numPages === 0);
                     section.querySelector('#splitPdfBtn').disabled = (numPages === 0 || !section.querySelector('#splitPageRange').value.trim());
                     if(numPages === 0) alert("PDF has no pages.");
                  } catch(err) {
                     console.error("Split PDF Setup Error:", err); alert(`PDF Load Error: ${err.message}`);
                     if(firstPageUrl) URL.revokeObjectURL(firstPageUrl); resetToolState(toolId);
                  }
             }
            function setupSplitPdfListeners() {
                  const toolId = 'split-pdf';
                  addDropZoneListeners(toolId, 'splitPdfDropZone', 'splitPdfFileInput', false, "application/pdf");
                  const section = document.getElementById(toolId + '-section');
                  const rangeInput = section.querySelector('#splitPageRange');
                  const splitBtn = section.querySelector('#splitPdfBtn');
                   const processingMsg = section.querySelector('#splitPdfProcessingMsg');
                   const downloadLink = section.querySelector('#splitPdfDownloadLink');
                   const downloadMessage = section.querySelector('#splitPdfDownloadMessage');
                   const outputInfo = section.querySelector('#splitPdfOutputInfo');
                   const resultText = section.querySelector('#splitPdfResultText');
                   const resultEmbed = section.querySelector('#splitPdfResultPreviewEmbed');
                   const successMsgElementSP = resultEmbed.parentNode.querySelector('.preview-success-message');

                  rangeInput?.addEventListener('input', () => {
                     const totalPages = parseInt(section.querySelector('#splitPdfTotalPages').textContent, 10);
                     splitBtn.disabled = !(totalPages > 0 && rangeInput.value.trim());
                  });

                  splitBtn?.addEventListener('click', async () => {
                      const state = toolState[toolId] || {};
                      const currentFile = state.file;

                      if (!currentFile) { alert("Please upload a PDF file first."); return; }
                      if (!pdfLibInstance?.PDFDocument) { alert("PDF-Lib not loaded."); return; }

                      const totalPages = parseInt(section.querySelector('#splitPdfTotalPages').textContent, 10);
                      const rangeString = rangeInput.value;
                      let pageIndices;
                      try { pageIndices = parsePageRanges(rangeString, totalPages); if (pageIndices.length === 0) { alert("Please enter valid page numbers/ranges."); return; } }
                      catch (error) { alert(`Invalid page selection: ${error.message}`); return; }

                      splitBtn.disabled = true; rangeInput.disabled = true; processingMsg.style.display = 'flex';
                      outputInfo.style.display = 'none'; if(successMsgElementSP) successMsgElementSP.style.display = 'none';
                      if(resultEmbed.src?.startsWith('blob:')) try{ URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                      resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                      let newPdfDoc, newBlob;
                      try {
                          const arrayBuffer = await currentFile.arrayBuffer();
                          const sourcePdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, {ignoreEncryption: true});

                          processingMsg.textContent = `Extracting ${pageIndices.length} page(s)...`;
                          newPdfDoc = await pdfLibInstance.PDFDocument.create();
                          const copiedPages = await newPdfDoc.copyPages(sourcePdfDoc, pageIndices);
                          copiedPages.forEach(page => newPdfDoc.addPage(page));
                          if (newPdfDoc.getPageCount() === 0) throw new Error("No pages were extracted.");

                          processingMsg.textContent = 'Saving split PDF...';
                          newBlob = new Blob([await newPdfDoc.save()], { type: 'application/pdf' });
                          const newUrl = URL.createObjectURL(newBlob);
                          toolState[toolId].resultBlobUrl = newUrl;


                          const oldDownloadHref = downloadLink.href;
                          if (oldDownloadHref?.startsWith('blob:') && oldDownloadHref !== newUrl) { try { URL.revokeObjectURL(oldDownloadHref); } catch(e) {} }

                          resultEmbed.src = newUrl; resultEmbed.style.display = 'block';
                          downloadLink.href = newUrl;
                          downloadLink.download = `split_${rangeString.replace(/[^0-9a-zA-Z-]/g, '_')}_${currentFile.name}`;
                          downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                          resultText.textContent = `Extracted ${newPdfDoc.getPageCount()} page(s). New Size: ${formatBytes(newBlob.size)}`;
                          outputInfo.style.display = 'block';
                          if (successMsgElementSP) { successMsgElementSP.textContent = `PDF split successfully! (${newPdfDoc.getPageCount()} pages, ${formatBytes(newBlob.size)})`; successMsgElementSP.style.display = 'block'; }
                      } catch (error) {
                           console.error("Split PDF Error:", error); alert(`Split Error: ${error.message || error}`);
                           resultText.textContent = `Split failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                      } finally {
                           processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                           const canRetry = totalPages > 0;
                           splitBtn.disabled = !(canRetry && rangeInput.value.trim());
                           rangeInput.disabled = !canRetry;
                      }
                  });
             }

            // --- Organize PDF Tool ---
            async function setupOrganizePdfUI(file, fileUrl) {
                const toolId = 'organize-pdf';
                const section = document.getElementById(toolId + '-section');

                const fileNameSpan = section.querySelector('#organizePdfFileName');
                const originalPageCountSpan = section.querySelector('#organizePdfOriginalPageCount');
                const fileInfoDiv = section.querySelector('#organizePdfFileInfo');
                const pagesContainer = section.querySelector('#organizePdfPagesContainer');
                const thumbnailsDiv = section.querySelector('#organizePageThumbnails');
                const processBtn = section.querySelector('#processOrganizePdfBtn');
                const processingMsg = section.querySelector('#organizePdfProcessingMsg');

                fileNameSpan.textContent = file.name;
                fileInfoDiv.style.display = 'block';
                pagesContainer.style.display = 'block';
                thumbnailsDiv.innerHTML = '';
                processBtn.disabled = true;
                organizePageData = []; 
                organizePdfDocObject = null; 


                if (!pdfjsLibInstance || !pdfLibInstance) {
                    alert("PDF processing libraries not loaded. Please refresh.");
                    return;
                }
                processingMsg.textContent = 'Loading PDF preview...';
                processingMsg.style.display = 'flex';

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const tempPdfDocForPreview = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                    const numPages = tempPdfDocForPreview.getPageCount();
                    originalPageCountSpan.textContent = numPages;

                    if (numPages === 0) {
                        alert("This PDF has no pages to organize.");
                        processingMsg.style.display = 'none';
                        return;
                    }

                    const pdfjsDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer.slice(0) }).promise;

                    for (let i = 0; i < numPages; i++) {
                        processingMsg.textContent = `Loading preview for page ${i + 1}/${numPages}...`;
                        const page = await pdfjsDoc.getPage(i + 1);
                        const viewport = page.getViewport({ scale: 0.3 });
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        canvas.style.display = 'block';

                        await page.render({ canvasContext: ctx, viewport }).promise;
                        const thumbnailUrl = canvas.toDataURL('image/png');

                        const pageItem = document.createElement('div');
                        pageItem.classList.add('page-thumbnail-item');
                        pageItem.setAttribute('draggable', true);
                        pageItem.dataset.originalIndex = i;

                        const img = document.createElement('img');
                        img.src = thumbnailUrl;
                        img.alt = `Page ${i + 1}`;

                        const pageNumDisplay = document.createElement('div');
                        pageNumDisplay.classList.add('page-number-display');
                        pageNumDisplay.textContent = `Page ${i + 1}`;

                        const deleteBtn = document.createElement('button');
                        deleteBtn.classList.add('delete-page-btn');
                        deleteBtn.innerHTML = '&times;';
                        deleteBtn.title = 'Mark for Deletion';
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const item = e.target.closest('.page-thumbnail-item');
                            const pageInfo = organizePageData.find(p => p.originalIndex === parseInt(item.dataset.originalIndex));
                            if (pageInfo) {
                                pageInfo.isDeleted = !pageInfo.isDeleted;
                                item.classList.toggle('marked-for-deletion', pageInfo.isDeleted);
                                deleteBtn.title = pageInfo.isDeleted ? 'Unmark Deletion' : 'Mark for Deletion';
                            }
                        });

                        pageItem.appendChild(img);
                        pageItem.appendChild(pageNumDisplay);
                        pageItem.appendChild(deleteBtn);
                        thumbnailsDiv.appendChild(pageItem);

                        organizePageData.push({
                            originalIndex: i,
                            isDeleted: false,
                            element: pageItem,
                        });
                    }
                    makeThumbnailsDraggable();
                    processBtn.disabled = false;

                } catch (error) {
                    console.error("Error setting up Organize PDF UI:", error);
                    alert(`Failed to load PDF for organization: ${error.message}`);
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }

            function makeThumbnailsDraggable() {
                const thumbnailsDiv = document.getElementById('organizePageThumbnails');
                if (!thumbnailsDiv) return;
                let draggedItem = null;

                thumbnailsDiv.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('page-thumbnail-item')) {
                        draggedItem = e.target;
                        setTimeout(() => e.target.classList.add('dragging'), 0);
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                thumbnailsDiv.addEventListener('dragend', (e) => {
                    if (draggedItem && e.target.classList.contains('page-thumbnail-item')) {
                       setTimeout(() => {
                            if (draggedItem) draggedItem.classList.remove('dragging');
                            draggedItem = null;
                       },0);
                    }
                });

                thumbnailsDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const targetItem = e.target.closest('.page-thumbnail-item');
                    if (targetItem && draggedItem && targetItem !== draggedItem) {
                        const children = Array.from(thumbnailsDiv.children);
                        const draggedIndex = children.indexOf(draggedItem);
                        const targetIndex = children.indexOf(targetItem);

                        if (draggedIndex < targetIndex) {
                             thumbnailsDiv.insertBefore(draggedItem, targetItem.nextSibling);
                        } else {
                             thumbnailsDiv.insertBefore(draggedItem, targetItem);
                        }
                    }
                });
            }

            function setupOrganizePdfListeners() {
                const toolId = 'organize-pdf';
                addDropZoneListeners(toolId, 'organizePdfDropZone', 'organizePdfFileInput', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const processBtn = section.querySelector('#processOrganizePdfBtn');
                const processingMsg = section.querySelector('#organizePdfProcessingMsg');
                const downloadLink = section.querySelector('#organizePdfDownloadLink');
                const downloadMessage = section.querySelector('#organizePdfDownloadMessage');
                const outputInfoDiv = section.querySelector('#organizePdfOutputInfo');
                const resultTextSpan = section.querySelector('#organizePdfResultText');

                processBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file || organizePageData.length === 0) {
                        alert("Please upload a PDF and ensure pages are loaded.");
                        return;
                    }

                    processBtn.disabled = true;
                    processingMsg.textContent = 'Applying changes...';
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none';
                    downloadMessage.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const sourcePdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                        const newPdfDoc = await pdfLibInstance.PDFDocument.create();
                        const finalPageOrderIndices = [];
                        const thumbnailElements = Array.from(document.getElementById('organizePageThumbnails').children);

                        thumbnailElements.forEach(thumbEl => {
                            const originalIndex = parseInt(thumbEl.dataset.originalIndex);
                            const pageDataEntry = organizePageData.find(p => p.originalIndex === originalIndex);
                            if (pageDataEntry && !pageDataEntry.isDeleted) {
                                finalPageOrderIndices.push(originalIndex);
                            }
                        });


                        if (finalPageOrderIndices.length === 0) {
                            alert("All pages are marked for deletion or no pages selected. Cannot create an empty PDF.");
                            processingMsg.style.display = 'none';
                            processBtn.disabled = !(toolState[toolId]?.file && organizePageData.length > 0);
                            return;
                        }

                        const pagesToCopy = await newPdfDoc.copyPages(sourcePdfDoc, finalPageOrderIndices);
                        pagesToCopy.forEach(page => newPdfDoc.addPage(page));

                        const pdfBytes = await newPdfDoc.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        toolState[toolId].resultBlobUrl = url;


                        downloadLink.href = url;
                        const originalFileName = toolState[toolId]?.file?.name || 'document.pdf';
                        downloadLink.download = `organized_${originalFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = `PDF organized successfully. New PDF has ${newPdfDoc.getPageCount()} pages. Size: ${formatBytes(blob.size)}`;
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error processing organized PDF:", error);
                        alert(`Failed to organize PDF: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        processBtn.disabled = !(toolState[toolId]?.file && organizePageData.length > 0);
                    }
                });
            }

            // --- Rotate PDF Tool ---
            async function setupRotatePdfUI(file, fileUrl) {
                const toolId = 'rotate-pdf';
                const section = document.getElementById(toolId + '-section');

                const fileNameSpan = section.querySelector('#rotatePdfFileName');
                const pageCountSpan = section.querySelector('#rotatePdfPageCount');
                const fileInfoDiv = section.querySelector('#rotatePdfFileInfo');
                const previewContainer = section.querySelector('#rotatePdfPreviewContainer');
                const previewImg = section.querySelector('#rotatePdfPagePreview');
                const angleDisplay = section.querySelector('#currentRotationAngleDisplay');
                const statusSpan = section.querySelector('#rotatePdfStatus');
                const rotateLeftBtn = section.querySelector('#rotatePdfLeftBtn');
                const rotateRightBtn = section.querySelector('#rotatePdfRightBtn');
                const applyBtn = section.querySelector('#applyRotationBtn');
                const processingMsg = section.querySelector('#rotatePdfProcessingMsg');

                fileNameSpan.textContent = file.name;
                fileInfoDiv.style.display = 'block';
                previewContainer.style.display = 'none';
                statusSpan.textContent = 'Loading PDF...';
                rotateLeftBtn.disabled = true;
                rotateRightBtn.disabled = true;
                applyBtn.disabled = true;
                rotatePdfCurrentAngle = 0;
                angleDisplay.textContent = '0';

                if (!pdfjsLibInstance || !pdfLibInstance) {
                    alert("PDF processing libraries not loaded. Please refresh.");
                    statusSpan.textContent = 'Error: Libraries not loaded';
                    return;
                }
                processingMsg.textContent = 'Loading PDF...';
                processingMsg.style.display = 'flex';

                let arrayBuffer;
                try {
                    arrayBuffer = await file.arrayBuffer();
                    const tempPdfDocForInfo = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                    const numPages = tempPdfDocForInfo.getPageCount();
                    pageCountSpan.textContent = numPages;

                    if (numPages === 0) {
                        statusSpan.textContent = 'PDF has no pages';
                        alert("This PDF has no pages to rotate.");
                        processingMsg.style.display = 'none';
                        return;
                    }

                    statusSpan.textContent = 'Loading preview...';
                    const pdfjsDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer.slice(0) }).promise;
                    const page = await pdfjsDoc.getPage(1);
                    await renderPdfPageToImg(page, previewImg, 0.8, 0);

                    previewContainer.style.display = 'block';
                    previewImg.style.display = 'block';
                    statusSpan.textContent = 'Ready to rotate';
                    rotateLeftBtn.disabled = false;
                    rotateRightBtn.disabled = false;
                    applyBtn.disabled = false;

                } catch (error) {
                    console.error("Error setting up Rotate PDF UI:", error);
                    alert(`Failed to load PDF for rotation: ${error.message}`);
                    statusSpan.textContent = `Error: ${error.message}`;
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }

            async function renderPdfPageToImg(pdfPage, imgElement, scale = 1.0, rotation = 0) {
                 const viewport = pdfPage.getViewport({ scale: scale, rotation: rotation });
                 const canvas = document.createElement('canvas');
                 const ctx = canvas.getContext('2d');
                 canvas.width = viewport.width;
                 canvas.height = viewport.height;

                 ctx.fillStyle = '#fff';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 await pdfPage.render({ canvasContext: ctx, viewport }).promise;

                 const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                 const currentBlobUrl = imgElement.src;
                 const newBlobUrl = URL.createObjectURL(blob);

                 imgElement.src = newBlobUrl;
                 imgElement.style.display = 'block';

                 if (currentBlobUrl && currentBlobUrl.startsWith('blob:')) {
                     try { URL.revokeObjectURL(currentBlobUrl); } catch(e) {}
                 }
                 const activeToolId = document.querySelector('main > section[style*="block"]').id.replace('-section', '');
                 if (toolState[activeToolId]) {
                    if(toolState[activeToolId].previewBlobUrl && toolState[activeToolId].previewBlobUrl.startsWith('blob:')) {
                         try { URL.revokeObjectURL(toolState[activeToolId].previewBlobUrl); } catch(e){}
                    }
                     toolState[activeToolId].previewBlobUrl = newBlobUrl;
                 }
            }

            function setupRotatePdfListeners() {
                const toolId = 'rotate-pdf';
                addDropZoneListeners(toolId, 'rotatePdfDropZone', 'rotatePdfFileInput', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const rotateLeftBtn = section.querySelector('#rotatePdfLeftBtn');
                const rotateRightBtn = section.querySelector('#rotatePdfRightBtn');
                const applyBtn = section.querySelector('#applyRotationBtn');
                const processingMsg = section.querySelector('#rotatePdfProcessingMsg');
                const downloadLink = section.querySelector('#rotatePdfDownloadLink');
                const downloadMessage = section.querySelector('#rotatePdfDownloadMessage');
                const outputInfoDiv = section.querySelector('#rotatePdfOutputInfo');
                const resultTextSpan = section.querySelector('#rotatePdfResultText');
                const previewImg = section.querySelector('#rotatePdfPagePreview');
                const angleDisplay = section.querySelector('#currentRotationAngleDisplay');
                const statusSpan = section.querySelector('#rotatePdfStatus');
                const { degrees } = pdfLibInstance;

                const updatePreviewRotation = async (newAngle) => {
                     if (!toolState[toolId]?.file) return;
                     processingMsg.textContent = 'Updating preview...';
                     processingMsg.style.display = 'flex';
                     rotateLeftBtn.disabled = true; rotateRightBtn.disabled = true; applyBtn.disabled = true;
                     try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const pdfjsDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer }).promise;
                        if (pdfjsDoc.numPages > 0) {
                             const page = await pdfjsDoc.getPage(1);
                             await renderPdfPageToImg(page, previewImg, 0.8, newAngle);
                             angleDisplay.textContent = `${newAngle}°`;
                             statusSpan.textContent = `Previewing ${newAngle}° rotation`;
                        } else { throw new Error("PDF has no pages for preview."); }
                     } catch(error) {
                         console.error("Error updating preview rotation:", error);
                         statusSpan.textContent = 'Preview error'; alert(`Error updating preview: ${error.message}`);
                     } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!toolState[toolId]?.file;
                        rotateLeftBtn.disabled = !fileLoaded;
                        rotateRightBtn.disabled = !fileLoaded;
                        applyBtn.disabled = !fileLoaded;
                     }
                };

                rotateLeftBtn.addEventListener('click', () => {
                    rotatePdfCurrentAngle = (rotatePdfCurrentAngle - 90 + 360) % 360;
                    updatePreviewRotation(rotatePdfCurrentAngle);
                });

                rotateRightBtn.addEventListener('click', () => {
                    rotatePdfCurrentAngle = (rotatePdfCurrentAngle + 90) % 360;
                    updatePreviewRotation(rotatePdfCurrentAngle);
                });

                applyBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) { alert("Please upload a PDF first."); return; }

                    rotateLeftBtn.disabled = true; rotateRightBtn.disabled = true; applyBtn.disabled = true;
                    processingMsg.textContent = 'Applying rotation to all pages...';
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }
                    statusSpan.textContent = 'Processing...';

                    try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const pdfDocToRotate = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                        const pages = pdfDocToRotate.getPages();
                        pages.forEach(page => {
                            const currentRotation = page.getRotation().angle;
                            page.setRotation(degrees((currentRotation + rotatePdfCurrentAngle) % 360));
                        });

                        const pdfBytes = await pdfDocToRotate.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        toolState[toolId].resultBlobUrl = url;

                        downloadLink.href = url;
                        const originalFileName = toolState[toolId]?.file?.name || 'document.pdf';
                        downloadLink.download = `rotated_${rotatePdfCurrentAngle}deg_${originalFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = `PDF rotated successfully by ${rotatePdfCurrentAngle}°. Size: ${formatBytes(blob.size)}`;
                        outputInfoDiv.style.display = 'block';
                        statusSpan.textContent = 'Rotation applied!';

                    } catch (error) {
                        console.error("Error processing rotated PDF:", error);
                        alert(`Failed to rotate PDF: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                        statusSpan.textContent = 'Error during processing';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!toolState[toolId]?.file;
                        rotateLeftBtn.disabled = !fileLoaded;
                        rotateRightBtn.disabled = !fileLoaded;
                        applyBtn.disabled = !fileLoaded;
                    }
                });
            }

            // --- Add Page Numbers to PDF ---
            async function setupAddPageNumbersPdfUI(file, fileUrl) {
                const toolId = 'add-page-numbers-pdf';
                const section = document.getElementById(toolId + '-section');
                const fileNameSpan = section.querySelector('#addPageNumbersPdfFileName');
                const pageCountSpan = section.querySelector('#addPageNumbersPdfPageCount');
                const fileInfoDiv = section.querySelector('#addPageNumbersPdfFileInfo');
                const processBtn = section.querySelector('#addPageNumbersPdfBtn');
                const processingMsg = section.querySelector('#addPageNumbersPdfProcessingMsg');
                const resultEmbed = section.querySelector('#addPageNumbersPdfResultEmbed');
                const previewContainer = section.querySelector('#addPageNumbersPdfPreviewContainer');
                const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');

                fileNameSpan.textContent = file.name;
                fileInfoDiv.style.display = 'block';
                processBtn.disabled = true;

                if (!pdfLibInstance) { alert("PDF-Lib library not loaded."); return; }

                processingMsg.textContent = 'Loading PDF...';
                processingMsg.style.display = 'flex';
                previewContainer.style.display = 'none';
                 if (resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                if (successMsg) successMsg.style.display = 'none';


                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const tempPdfDocForInfo = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                    const numPages = tempPdfDocForInfo.getPageCount();
                    pageCountSpan.textContent = numPages;

                    if (numPages === 0) {
                        alert("This PDF has no pages.");
                        processingMsg.style.display = 'none';
                        return;
                    }
                    processBtn.disabled = false;
                } catch (error) {
                    console.error(`Error setting up Add Page Numbers PDF UI:`, error);
                    alert(`Failed to load PDF: ${error.message}`);
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }
            function setupAddPageNumbersPdfListeners() {
                const toolId = 'add-page-numbers-pdf';
                addDropZoneListeners(toolId, 'addPageNumbersPdfDropZone', 'addPageNumbersPdfFile', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const processBtn = section.querySelector('#addPageNumbersPdfBtn');
                const fontSizeInput = section.querySelector('#pageNumFontSize');
                const positionSelect = section.querySelector('#pageNumPosition');
                const processingMsg = section.querySelector('#addPageNumbersPdfProcessingMsg');
                const downloadLink = section.querySelector('#addPageNumbersPdfDownloadLink');
                const downloadMessage = section.querySelector('#addPageNumbersPdfDownloadMessage');
                const outputInfoDiv = section.querySelector('#addPageNumbersPdfOutputInfo');
                const resultTextSpan = section.querySelector('#addPageNumbersPdfResultText');
                const resultEmbed = section.querySelector('#addPageNumbersPdfResultEmbed');
                const previewContainer = section.querySelector('#addPageNumbersPdfPreviewContainer');
                const successMsgElement = resultEmbed.parentNode.querySelector('.preview-success-message');
                const { rgb, StandardFonts } = pdfLibInstance;

                processBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) { alert("Please upload a PDF first."); return; }

                    processBtn.disabled = true;
                    fontSizeInput.disabled = true; positionSelect.disabled = true;
                    processingMsg.textContent = 'Adding page numbers...';
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    previewContainer.style.display = 'none';
                    if (resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                    resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                    if (successMsgElement) successMsgElement.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }


                    try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                        const fontSize = parseInt(fontSizeInput.value) || 12;
                        const position = positionSelect.value;
                        const color = rgb(0, 0, 0);
                        const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);

                        const pages = pdfDoc.getPages();
                        for (let i = 0; i < pages.length; i++) {
                            const page = pages[i];
                            const { width, height } = page.getSize();
                            const pageNumText = `${i + 1}`;
                            const textWidth = helveticaFont.widthOfTextAtSize(pageNumText, fontSize);
                            const textHeight = helveticaFont.heightAtSize(fontSize); 

                            let x, y;
                            const margin = 30;

                            switch (position) {
                                case 'bottom-left':   x = margin; y = margin; break;
                                case 'bottom-center': x = (width - textWidth) / 2; y = margin; break;
                                case 'bottom-right':  x = width - textWidth - margin; y = margin; break;
                                case 'top-left':      x = margin; y = height - textHeight - (margin / 2); break; 
                                case 'top-center':    x = (width - textWidth) / 2; y = height - textHeight - (margin / 2); break;
                                case 'top-right':     x = width - textWidth - margin; y = height - textHeight - (margin / 2); break;
                                default:              x = (width - textWidth) / 2; y = margin;
                            }
                            page.drawText(pageNumText, { x, y, size: fontSize, font: helveticaFont, color });
                        }

                        const pdfBytes = await pdfDoc.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        toolState[toolId].resultBlobUrl = url;

                        resultEmbed.src = url; resultEmbed.style.display = 'block';
                        previewContainer.style.display = 'block';
                        if (successMsgElement) { successMsgElement.textContent = `Page numbers added! Preview shown.`; successMsgElement.style.display = 'block'; }


                        downloadLink.href = url;
                        const originalFileName = toolState[toolId]?.file?.name || 'document.pdf';
                        downloadLink.download = `numbered_${originalFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = `Page numbers added. New Size: ${formatBytes(blob.size)}`;
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error adding page numbers:", error);
                        alert(`Failed to add page numbers: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!toolState[toolId]?.file;
                        processBtn.disabled = !fileLoaded;
                        fontSizeInput.disabled = !fileLoaded;
                        positionSelect.disabled = !fileLoaded;
                    }
                });
            }

            // --- Add Text Watermark to PDF ---
            async function setupAddTextWatermarkPdfUI(file, fileUrl) {
                const toolId = 'add-text-watermark-pdf';
                const section = document.getElementById(toolId + '-section');
                const fileNameSpan = section.querySelector('#addWatermarkPdfFileName');
                const pageCountSpan = section.querySelector('#addWatermarkPdfPageCount');
                const fileInfoDiv = section.querySelector('#addWatermarkPdfFileInfo');
                const processBtn = section.querySelector('#addWatermarkPdfBtn');
                const processingMsg = section.querySelector('#addWatermarkPdfProcessingMsg');
                const resultEmbed = section.querySelector('#addWatermarkPdfResultEmbed');
                const previewContainer = section.querySelector('#addWatermarkPdfPreviewContainer');
                const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');


                fileNameSpan.textContent = file.name;
                fileInfoDiv.style.display = 'block';
                processBtn.disabled = true;

                if (!pdfLibInstance) { alert("PDF-Lib library not loaded."); return; }

                processingMsg.textContent = 'Loading PDF...';
                processingMsg.style.display = 'flex';
                previewContainer.style.display = 'none';
                if (resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                if (successMsg) successMsg.style.display = 'none';

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const tempPdfDocForInfo = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                    const numPages = tempPdfDocForInfo.getPageCount();
                    pageCountSpan.textContent = numPages;

                    if (numPages === 0) {
                        alert("This PDF has no pages.");
                        processingMsg.style.display = 'none';
                        return;
                    }
                    processBtn.disabled = false;
                } catch (error) {
                    console.error(`Error setting up Add Watermark PDF UI:`, error);
                    alert(`Failed to load PDF: ${error.message}`);
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }
            function setupAddTextWatermarkPdfListeners() {
                const toolId = 'add-text-watermark-pdf';
                addDropZoneListeners(toolId, 'addWatermarkPdfDropZone', 'addWatermarkPdfFile', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const processBtn = section.querySelector('#addWatermarkPdfBtn');
                const textInput = section.querySelector('#watermarkText');
                const fontSizeInput = section.querySelector('#watermarkFontSize');
                const opacityInput = section.querySelector('#watermarkOpacity');
                const processingMsg = section.querySelector('#addWatermarkPdfProcessingMsg');
                const downloadLink = section.querySelector('#addWatermarkPdfDownloadLink');
                const downloadMessage = section.querySelector('#addWatermarkPdfDownloadMessage');
                const outputInfoDiv = section.querySelector('#addWatermarkPdfOutputInfo');
                const resultTextSpan = section.querySelector('#addWatermarkPdfResultText');
                const resultEmbed = section.querySelector('#addWatermarkPdfResultEmbed');
                const previewContainer = section.querySelector('#addWatermarkPdfPreviewContainer');
                const successMsgElement = resultEmbed.parentNode.querySelector('.preview-success-message');

                const { rgb, StandardFonts, degrees } = pdfLibInstance;

                processBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) { alert("Please upload a PDF first."); return; }
                    const watermarkText = textInput.value.trim();
                    if (!watermarkText) { alert("Please enter watermark text."); return; }

                    processBtn.disabled = true;
                    textInput.disabled = true; fontSizeInput.disabled = true; opacityInput.disabled = true;
                    processingMsg.textContent = 'Adding watermark...';
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    previewContainer.style.display = 'none';
                    if (resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                    resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                    if (successMsgElement) successMsgElement.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                        const fontSize = parseInt(fontSizeInput.value) || 48;
                        const opacityValue = parseFloat(opacityInput.value) || 0.3;
                        const color = rgb(0.5, 0.5, 0.5); // Gray color
                        const helveticaFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

                        const pages = pdfDoc.getPages();
                        for (const page of pages) {
                            const { width, height } = page.getSize();
                            const textWidth = helveticaFont.widthOfTextAtSize(watermarkText, fontSize);
                            
                            const centerX = width / 2;
                            const centerY = height / 2;

                            page.drawText(watermarkText, {
                                x: centerX, 
                                y: centerY,
                                xOffset: -textWidth / 2, 
                                yOffset: -fontSize / 3,  
                                size: fontSize,
                                font: helveticaFont,
                                color,
                                opacity: opacityValue,
                                rotate: degrees(-45),
                            });
                        }

                        const pdfBytes = await pdfDoc.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        toolState[toolId].resultBlobUrl = url;


                        resultEmbed.src = url; resultEmbed.style.display = 'block';
                        previewContainer.style.display = 'block';
                        if (successMsgElement) { successMsgElement.textContent = `Watermark added! Preview shown.`; successMsgElement.style.display = 'block'; }


                        downloadLink.href = url;
                        const originalFileName = toolState[toolId]?.file?.name || 'document.pdf';
                        downloadLink.download = `watermarked_${originalFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = `Watermark added. New Size: ${formatBytes(blob.size)}`;
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error adding watermark:", error);
                        alert(`Failed to add watermark: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!toolState[toolId]?.file;
                        processBtn.disabled = !fileLoaded;
                        textInput.disabled = !fileLoaded;
                        fontSizeInput.disabled = !fileLoaded;
                        opacityInput.disabled = !fileLoaded;
                    }
                });
            }

            // --- Compress PDF ---
            async function setupCompressPdfUI(file, fileUrl) {
                const toolId = 'compress-pdf';
                const section = document.getElementById(toolId + '-section');
                const fileNameSpan = section.querySelector('#compressPdfFileName');
                const originalSizeSpan = section.querySelector('#compressPdfOriginalSize');
                const pageCountSpan = section.querySelector('#compressPdfPageCount');
                const fileInfoDiv = section.querySelector('#compressPdfFileInfo');
                const processBtn = section.querySelector('#compressPdfBtn');
                const processingMsg = section.querySelector('#compressPdfProcessingMsg');
                const originalEmbed = section.querySelector('#compressPdfOriginalEmbed');
                const previewContainer = section.querySelector('#compressPdfPreviewContainer');

                fileNameSpan.textContent = file.name;
                originalSizeSpan.textContent = formatBytes(file.size);
                fileInfoDiv.style.display = 'block';
                processBtn.disabled = true;

                if (!pdfLibInstance || !pdfjsLibInstance) { alert("PDF libraries not loaded."); return; }

                processingMsg.textContent = 'Loading PDF info & preview...';
                processingMsg.style.display = 'flex';
                previewContainer.style.display = 'none';
                if (originalEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(originalEmbed.src); } catch(e){}
                originalEmbed.removeAttribute('src'); originalEmbed.style.display = 'none';

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const tempPdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                    const numPages = tempPdfDoc.getPageCount();
                    pageCountSpan.textContent = numPages;

                    if (numPages === 0) {
                        alert("This PDF has no pages to compress.");
                        processingMsg.style.display = 'none';
                        return;
                    }

                    const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
                    const tempUrl = URL.createObjectURL(blob);
                    if(toolState[toolId]) toolState[toolId].previewBlobUrl = tempUrl; 

                    originalEmbed.src = tempUrl;
                    originalEmbed.style.display = 'block';
                    previewContainer.style.display = 'block';

                    processBtn.disabled = false;
                } catch (error) {
                    console.error(`Error setting up Compress PDF UI:`, error);
                    alert(`Failed to load PDF: ${error.message}`);
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }
            function setupCompressPdfListeners() {
                const toolId = 'compress-pdf';
                addDropZoneListeners(toolId, 'compressPdfDropZone', 'compressPdfFile', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const processBtn = section.querySelector('#compressPdfBtn');
                const compressionLevelSlider = section.querySelector('#pdfCompressionLevel');
                const compressionLevelValue = section.querySelector('#pdfCompressionLevelValue');
                const processingMsg = section.querySelector('#compressPdfProcessingMsg');
                const downloadLink = section.querySelector('#compressPdfDownloadLink');
                const downloadMessage = section.querySelector('#compressPdfDownloadMessage');
                const outputInfoDiv = section.querySelector('#compressPdfOutputInfo');
                const newSizeSpan = section.querySelector('#compressedPdfNewSize');
                const reductionSpan = section.querySelector('#compressedPdfSizeReduction');

                compressionLevelSlider.addEventListener('input', (event) => {
                    compressionLevelValue.textContent = event.target.value;
                });

                processBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) { alert("Please upload a PDF first."); return; }

                    processBtn.disabled = true;
                    compressionLevelSlider.disabled = true;
                    processingMsg.textContent = 'Compressing PDF... This may take some time.';
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const arrayBuffer = await toolState[toolId].file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, {
                            ignoreEncryption: true,
                            updateMetadata: false 
                        });
                        
                        const pdfBytes = await pdfDoc.save({
                            useObjectStreams: true, 
                        });

                        const originalSize = toolState[toolId].file.size;
                        const newBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(newBlob);
                        toolState[toolId].resultBlobUrl = url;

                        downloadLink.href = url;
                        const originalFileName = toolState[toolId]?.file?.name || 'document.pdf';
                        downloadLink.download = `compressed_${originalFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        newSizeSpan.textContent = formatBytes(newBlob.size);
                        reductionSpan.textContent = originalSize > 0 ? `${(((originalSize - newBlob.size) / originalSize) * 100).toFixed(2)}%` : 'N/A';
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error compressing PDF:", error);
                        alert(`Failed to compress PDF: ${error.message}`);
                        newSizeSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!toolState[toolId]?.file;
                        processBtn.disabled = !fileLoaded;
                        compressionLevelSlider.disabled = !fileLoaded;
                    }
                });
            }


            // --- PDF to Word (API Integration) ---
            function setupPdfToWordUI(file, fileUrl) {
                const toolId = 'pdf-to-word';
                const section = document.getElementById(toolId + '-section');
                const placeholderMsgDiv = section.querySelector('#pdfToWordPlaceholderMessage');

                section.querySelector('#pdfToWordFileName').textContent = file.name;
                section.querySelector('#pdfToWordFileInfo').style.display = 'block';
                section.querySelector('#convertToWordBtn').disabled = false;
                if(placeholderMsgDiv) {
                    placeholderMsgDiv.textContent = "Ready to convert to Word via API.";
                    placeholderMsgDiv.style.display = 'none'; 
                    placeholderMsgDiv.classList.remove('error');
                }
                section.querySelector('#pdfToWordDownloadLink').style.display = 'none';
                section.querySelector('#pdfToWordDownloadMessage').style.display = 'none';
            }

            function setupPdfToWordListeners() {
                const toolId = 'pdf-to-word';
                addDropZoneListeners(toolId, 'pdfToWordDropZone', 'pdfToWordFile', false, "application/pdf");
                const section = document.getElementById(toolId + '-section');
                const convertBtn = section.querySelector('#convertToWordBtn');
                const processingMsg = section.querySelector('#pdfToWordProcessingMsg');
                const placeholderMsgDiv = section.querySelector('#pdfToWordPlaceholderMessage');
                const downloadLink = section.querySelector('#pdfToWordDownloadLink');
                const downloadMessage = section.querySelector('#pdfToWordDownloadMessage');

                convertBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) {
                        alert("Please upload a PDF first.");
                        return;
                    }
                    if (!CLOUDCONVERT_API_KEY || CLOUDCONVERT_API_KEY === 'YOUR_API_KEY_HERE_FOR_LOCAL_TESTING_ONLY') { 
                        alert("CloudConvert API Key is not configured correctly. This tool will not work.\nPlease ensure it's set for testing or a backend proxy is used in production.");
                        if(placeholderMsgDiv) {
                            placeholderMsgDiv.textContent = "API Key not configured or placeholder used. Conversion aborted.";
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                        return;
                    }

                    const pdfFile = toolState[toolId].file;

                    convertBtn.disabled = true;
                    processingMsg.textContent = 'Preparing upload...';
                    processingMsg.style.display = 'flex';
                    if(placeholderMsgDiv) {
                        placeholderMsgDiv.style.display = 'none';
                        placeholderMsgDiv.classList.remove('error');
                    }
                    downloadLink.style.display = 'none';
                    downloadMessage.style.display = 'none';
                    if (downloadLink.href && !downloadLink.href.startsWith('blob:')) { 
                        downloadLink.href = '#';
                    }

                    let importTaskId = null; 
                    let convertTaskId = null; 
                    let exportTaskId = null;  

                    try {
                        processingMsg.textContent = 'Requesting upload URL... (Step 1/4)';
                        const createImportTaskResponse = await fetch('https://api.cloudconvert.com/v2/import/upload', {
                            method: 'POST',
                            headers: { 
                                'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ filename: pdfFile.name }) 
                        });

                        if (!createImportTaskResponse.ok) {
                            const errorData = await createImportTaskResponse.json().catch(() => ({ message: createImportTaskResponse.statusText }));
                            let displayError = `Create Import Task failed: ${errorData.message || createImportTaskResponse.statusText}`;
                            if (createImportTaskResponse.status === 402) { 
                                displayError = "CloudConvert API Error: Your account has run out of conversion credits or requires payment.";
                            }
                            throw new Error(displayError);
                        }
                        
                        const importTaskDetails = (await createImportTaskResponse.json()).data;
                        importTaskId = importTaskDetails.id; 
                        const uploadUrl = importTaskDetails.result.form.url;
                        const uploadParameters = importTaskDetails.result.form.parameters;
                        
                        processingMsg.textContent = 'Uploading actual file... (Step 2/4)';
                        const fileUploadFormData = new FormData();
                        for (const key in uploadParameters) {
                            fileUploadFormData.append(key, uploadParameters[key]);
                        }
                        fileUploadFormData.append('file', pdfFile); 
                        const actualUploadResponse = await fetch(uploadUrl, { method: 'POST', body: fileUploadFormData });
                        if (!actualUploadResponse.ok) { 
                            const uploadErrorText = await actualUploadResponse.text();
                            throw new Error(`Actual file upload to S3 failed (${actualUploadResponse.status}): ${uploadErrorText.substring(0,300)}`); 
                        }
                        
                        processingMsg.textContent = 'Waiting for import to finalize... (Step 2/4)';
                        let currentImportTaskData = importTaskDetails; 
                        await new Promise(resolve => setTimeout(resolve, 1500)); 
                        let importPollAttempts = 0;
                        while (currentImportTaskData.status !== 'finished' && currentImportTaskData.status !== 'error' && importPollAttempts < 10) {
                            importPollAttempts++;
                            await new Promise(resolve => setTimeout(resolve, 3000)); 
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${importTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            const statusResultText = await statusResponse.text();
                            let statusResultJson;
                            try { statusResultJson = JSON.parse(statusResultText); } catch (e) { throw new Error(`Failed to parse import task status JSON (Attempt ${importPollAttempts}). Status: ${statusResponse.status}. Body: ${statusResultText.substring(0,200)}`); }
                            if (!statusResponse.ok) { throw new Error(`Failed to get import task status (Attempt ${importPollAttempts}): ${statusResultJson.message || statusResponse.statusText}`);}
                            currentImportTaskData = statusResultJson.data; 
                            if (!currentImportTaskData) { throw new Error('Import task status response did not contain .data field'); }
                            processingMsg.textContent = `Importing... Status: ${currentImportTaskData.status} (Progress: ${currentImportTaskData.percent || 0}%)`;
                            if (currentImportTaskData.status === 'error') { throw new Error(`Import task failed: ${currentImportTaskData.message || 'Unknown API error during import'}`); }
                        }
                        if (currentImportTaskData.status !== 'finished') { throw new Error(`Import did not finish successfully after ${importPollAttempts} attempts. Status: ${currentImportTaskData.status}`);}
                        
                        processingMsg.textContent = 'Starting conversion... (Step 3/4)';
                        const convertPayload = { 
                            input: importTaskId,
                            input_format: 'pdf',
                            output_format: 'docx',
                            engine: 'pdftron-pdf2word', 
                            engine_version: 'latest'
                        };
                        
                        const convertResponse = await fetch('https://api.cloudconvert.com/v2/convert', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(convertPayload)
                        });
                        const convertResponseText = await convertResponse.text();
                        
                        if (!convertResponse.ok) {
                            let errorJson;
                            try { errorJson = JSON.parse(convertResponseText); } catch(e) {errorJson = {message: convertResponse.statusText};}
                            let displayError = `Conversion task creation failed (${convertResponse.status}): ${errorJson.message || convertResponse.statusText}. Response: ${convertResponseText.substring(0, 300)}`;
                            if (convertResponse.status === 402) {
                                displayError = "CloudConvert API Error: Your account has run out of conversion credits or requires payment for this conversion type.";
                            }
                            throw new Error(displayError);
                        }
                        
                        let convertResult = JSON.parse(convertResponseText);
                        convertTaskId = convertResult.data.id; 
                        
                        processingMsg.textContent = 'Converting... (Waiting for API - Step 3/4)';
                        let currentConvertTaskData = convertResult.data; 
                        let convertPollAttempts = 0;

                        while (currentConvertTaskData.status !== 'finished' && currentConvertTaskData.status !== 'error' && convertPollAttempts < 20) { 
                            convertPollAttempts++;
                            await new Promise(resolve => setTimeout(resolve, 3000)); 
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${convertTaskId}`, { 
                                headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` }
                            });
                            const statusResultText = await statusResponse.text();
                            let statusResultJson;
                            try { statusResultJson = JSON.parse(statusResultText); } catch (e) { throw new Error(`Failed to parse convert task status JSON (Attempt ${convertPollAttempts}). Status: ${statusResponse.status}. Body: ${statusResultText.substring(0,200)}`); }
                            if (!statusResponse.ok) { throw new Error(`Failed to get convert task status (Attempt ${convertPollAttempts}): ${statusResultJson.message || statusResponse.statusText}`);}
                            
                            currentConvertTaskData = statusResultJson.data; 
                            if (!currentConvertTaskData) { throw new Error('Convert task status response did not contain .data field'); }
                            processingMsg.textContent = `Converting... Status: ${currentConvertTaskData.status} (Progress: ${currentConvertTaskData.percent || 0}%)`;
                            if (currentConvertTaskData.status === 'error') {
                                throw new Error(`Conversion task failed: ${currentConvertTaskData.message || 'Unknown API error during conversion'}`);
                            }
                        }

                        if (currentConvertTaskData.status !== 'finished') {
                             throw new Error(`Conversion task did not finish successfully after ${convertPollAttempts} attempts. Status: ${currentConvertTaskData.status}`);
                        }
                        
                        processingMsg.textContent = 'Preparing download... (Step 4/4)';
                        const exportPayload = { input: convertTaskId }; 

                        const exportResponse = await fetch('https://api.cloudconvert.com/v2/export/url', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(exportPayload)
                        });
                         if (!exportResponse.ok) {
                             const errorData = await exportResponse.json().catch(() => ({ message: exportResponse.statusText }));
                            throw new Error(`Export task creation failed: ${errorData.message || exportResponse.statusText}`);
                        }
                        let exportResult = await exportResponse.json();
                        exportTaskId = exportResult.data.id; 
                        
                        processingMsg.textContent = 'Finalizing... (Waiting for API - Step 4/4)';
                        let currentExportTaskData = exportResult.data;
                        let exportPollAttempts = 0;

                         while (currentExportTaskData.status !== 'finished' && currentExportTaskData.status !== 'error' && exportPollAttempts < 10) {
                            exportPollAttempts++;
                            await new Promise(resolve => setTimeout(resolve, 2000)); 
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${exportTaskId}`, { 
                                headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` }
                            });
                            const statusResultText = await statusResponse.text();
                            let statusResultJson;
                            try { statusResultJson = JSON.parse(statusResultText); } catch (e) { throw new Error(`Failed to parse export task status JSON (Attempt ${exportPollAttempts}). Status: ${statusResponse.status}. Body: ${statusResultText.substring(0,200)}`); }
                            if (!statusResponse.ok) { throw new Error(`Failed to get export task status (Attempt ${exportPollAttempts}): ${statusResultJson.message || statusResponse.statusText}`);}

                            currentExportTaskData = statusResultJson.data;
                            if (!currentExportTaskData) { throw new Error('Export task status response did not contain .data field'); }
                            
                            if (currentExportTaskData.status === 'error') {
                                throw new Error(`Export task failed: ${currentExportTaskData.message || 'Unknown API error during export'}`);
                            }
                        }

                        if (currentExportTaskData.status !== 'finished' || !currentExportTaskData.result?.files?.[0]?.url) {
                            throw new Error(`Export task did not complete successfully or no download URL found after ${exportPollAttempts} attempts. Status: ${currentExportTaskData.status}`);
                        }

                        const downloadUrl = currentExportTaskData.result.files[0].url;
                        const convertedFileName = currentExportTaskData.result.files[0].filename || pdfFile.name.replace(/\.pdf$/i, '.docx');

                        downloadLink.href = downloadUrl;
                        downloadLink.download = convertedFileName; 
                        downloadLink.textContent = `Download ${convertedFileName}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';
                        processingMsg.style.display = 'none';

                    } catch (error) {
                        console.error('CloudConvert Error (Word):', error);
                        processingMsg.style.display = 'none';
                        if(placeholderMsgDiv){
                            placeholderMsgDiv.textContent = `Conversion Error: ${error.message}. Please check console or try again.`;
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                    } finally {
                        convertBtn.disabled = false;
                    }
                });
            }

            // --- PDF to PowerPoint (API Integration) ---
           function setupPdfToPowerPointUI(file, fileUrl) {
                const toolId = 'pdf-to-powerpoint';
                const section = document.getElementById(toolId + '-section');
                section.querySelector('#pdfToPowerPointFileName').textContent = file.name;
                section.querySelector('#pdfToPowerPointFileInfo').style.display = 'block';
                section.querySelector('#convertToPowerPointBtn').disabled = false;
                const placeholderMsgDiv = section.querySelector('#pdfToPowerPointPlaceholderMessage');
                if (placeholderMsgDiv) {
                    placeholderMsgDiv.textContent = "Ready to convert to PowerPoint via API.";
                    placeholderMsgDiv.style.display = 'none';
                    placeholderMsgDiv.classList.remove('error');
                }
                section.querySelector('#pdfToPowerPointDownloadLink').style.display = 'none';
                const downloadMessageEl = section.querySelector('#pdfToPowerPointDownloadMessage'); 
                if (downloadMessageEl) downloadMessageEl.style.display = 'none';
            }

            function setupPdfToPowerPointListeners() {
                const toolId = 'pdf-to-powerpoint';
                addDropZoneListeners(toolId, 'pdfToPowerPointDropZone', 'pdfToPowerPointFile', false, "application/pdf");
                const section = document.getElementById(toolId + '-section');
                const convertBtn = section.querySelector('#convertToPowerPointBtn');
                const processingMsg = section.querySelector('#pdfToPowerPointProcessingMsg');
                const placeholderMsgDiv = section.querySelector('#pdfToPowerPointPlaceholderMessage');
                const downloadLink = section.querySelector('#pdfToPowerPointDownloadLink');
                const downloadMessage = section.querySelector('#pdfToPowerPointDownloadMessage'); 

                convertBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) {
                        alert("Please upload a PDF first.");
                        return;
                    }
                    if (!CLOUDCONVERT_API_KEY || CLOUDCONVERT_API_KEY === 'YOUR_API_KEY_HERE_FOR_LOCAL_TESTING_ONLY') {
                        alert("CloudConvert API Key is not configured correctly. This tool will not work.\nPlease ensure it's set for testing or a backend proxy is used in production.");
                        if (placeholderMsgDiv) {
                            placeholderMsgDiv.textContent = "API Key not configured or placeholder used. Conversion aborted.";
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                        return;
                    }

                    const pdfFile = toolState[toolId].file;

                    convertBtn.disabled = true;
                    processingMsg.textContent = 'Preparing upload...';
                    processingMsg.style.display = 'flex';
                    if (placeholderMsgDiv) {
                        placeholderMsgDiv.style.display = 'none';
                        placeholderMsgDiv.classList.remove('error');
                    }
                    downloadLink.style.display = 'none';
                    if(downloadMessage) downloadMessage.style.display = 'none';
                    if (downloadLink.href && !downloadLink.href.startsWith('blob:')) {
                        downloadLink.href = '#';
                    }

                    let importTaskId = null;
                    let convertTaskId = null;
                    let exportTaskId = null;

                    try {
                        processingMsg.textContent = 'Requesting upload URL... (Step 1/4)';
                        const createImportTaskResponse = await fetch('https://api.cloudconvert.com/v2/import/upload', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ filename: pdfFile.name })
                        });
                        if (!createImportTaskResponse.ok) {
                            const errorData = await createImportTaskResponse.json().catch(() => ({ message: createImportTaskResponse.statusText }));
                            let displayError = `Create Import Task failed: ${errorData.message || createImportTaskResponse.statusText}`;
                            if (createImportTaskResponse.status === 402) displayError = "CloudConvert API Error: Your account has run out of conversion credits or requires payment.";
                            throw new Error(displayError);
                        }
                        const importTaskDetails = (await createImportTaskResponse.json()).data;
                        importTaskId = importTaskDetails.id;
                        const uploadUrl = importTaskDetails.result.form.url;
                        const uploadParameters = importTaskDetails.result.form.parameters;

                        processingMsg.textContent = 'Uploading actual file... (Step 2/4)';
                        const fileUploadFormData = new FormData();
                        for (const key in uploadParameters) fileUploadFormData.append(key, uploadParameters[key]);
                        fileUploadFormData.append('file', pdfFile);
                        const actualUploadResponse = await fetch(uploadUrl, { method: 'POST', body: fileUploadFormData });
                        if (!actualUploadResponse.ok) throw new Error(`Actual file upload to S3 failed (${actualUploadResponse.status})`);
                        
                        processingMsg.textContent = 'Waiting for import to finalize... (Step 2/4)';
                        let currentImportTaskData = importTaskDetails;
                        for (let i = 0; i < 10 && currentImportTaskData.status !== 'finished'; i++) { 
                            await new Promise(resolve => setTimeout(resolve, i === 0 ? 1500 : 3000)); 
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${importTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            if(!statusResponse.ok) throw new Error(`Failed to poll import task: ${statusResponse.statusText}`);
                            currentImportTaskData = (await statusResponse.json()).data;
                            processingMsg.textContent = `Importing... Status: ${currentImportTaskData.status} (Progress: ${currentImportTaskData.percent || 0}%)`;
                            if (currentImportTaskData.status === 'error') throw new Error(`Import task failed: ${currentImportTaskData.message || 'API error'}`);
                        }
                        if (currentImportTaskData.status !== 'finished') throw new Error('Import did not finish in time.');

                        processingMsg.textContent = 'Starting conversion to PowerPoint... (Step 3/4)';
                        const convertPayload = {
                            input: importTaskId,
                            input_format: 'pdf',
                            output_format: 'pptx', 
                            engine: 'pdftron-pdf2powerpoint', 
                            engine_version: 'latest'
                        };
                        const convertResponse = await fetch('https://api.cloudconvert.com/v2/convert', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify(convertPayload)
                        });
                        if (!convertResponse.ok) {
                            const errorData = await convertResponse.json().catch(() => ({ message: convertResponse.statusText }));
                            let displayError = `Conversion task creation failed: ${errorData.message || convertResponse.statusText}`;
                            if (convertResponse.status === 402) displayError = "CloudConvert API Error: Credits/payment issue for PowerPoint conversion.";
                            throw new Error(displayError);
                        }
                        let convertResult = await convertResponse.json();
                        convertTaskId = convertResult.data.id;

                        processingMsg.textContent = 'Converting to PowerPoint... (Waiting - Step 3/4)';
                        let currentConvertTaskData = convertResult.data;
                        for (let i = 0; i < 25 && currentConvertTaskData.status !== 'finished'; i++) { 
                            await new Promise(resolve => setTimeout(resolve, 3000));
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${convertTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            if(!statusResponse.ok) throw new Error(`Failed to poll convert task: ${statusResponse.statusText}`);
                            currentConvertTaskData = (await statusResponse.json()).data;
                            processingMsg.textContent = `Converting to PowerPoint... Status: ${currentConvertTaskData.status} (Progress: ${currentConvertTaskData.percent || 0}%)`;
                            if (currentConvertTaskData.status === 'error') throw new Error(`Conversion task failed: ${currentConvertTaskData.message || 'API error'}`);
                        }
                        if (currentConvertTaskData.status !== 'finished') throw new Error('PowerPoint conversion did not finish in time.');

                        processingMsg.textContent = 'Preparing PowerPoint download... (Step 4/4)';
                        const exportPayload = { input: convertTaskId };
                        const exportResponse = await fetch('https://api.cloudconvert.com/v2/export/url', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportPayload)
                        });
                        if (!exportResponse.ok) throw new Error('Export task creation failed');
                        let exportResult = await exportResponse.json();
                        exportTaskId = exportResult.data.id;

                        processingMsg.textContent = 'Finalizing PowerPoint... (Waiting - Step 4/4)';
                        let currentExportTaskData = exportResult.data;
                        for (let i = 0; i < 10 && currentExportTaskData.status !== 'finished'; i++) {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${exportTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            if(!statusResponse.ok) throw new Error(`Failed to poll export task: ${statusResponse.statusText}`);
                            currentExportTaskData = (await statusResponse.json()).data;
                            if (currentExportTaskData.status === 'error') throw new Error(`Export task failed: ${currentExportTaskData.message || 'API error'}`);
                        }
                        if (currentExportTaskData.status !== 'finished' || !currentExportTaskData.result?.files?.[0]?.url) {
                            throw new Error('Export did not complete or no download URL found.');
                        }

                        const downloadUrl = currentExportTaskData.result.files[0].url;
                        const convertedFileName = currentExportTaskData.result.files[0].filename || pdfFile.name.replace(/\.pdf$/i, '.pptx');

                        downloadLink.href = downloadUrl;
                        downloadLink.download = convertedFileName;
                        downloadLink.textContent = `Download ${convertedFileName}`;
                        downloadLink.style.display = 'inline-block';
                        if(downloadMessage) {
                            downloadMessage.textContent = 'Your PowerPoint presentation is ready!'; 
                            downloadMessage.style.display = 'block';
                        }
                        processingMsg.style.display = 'none';

                    } catch (error) {
                        console.error('CloudConvert Error (PowerPoint):', error);
                        processingMsg.style.display = 'none';
                        if (placeholderMsgDiv) {
                            placeholderMsgDiv.textContent = `Conversion Error: ${error.message}. Please check console or try again.`;
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                    } finally {
                        convertBtn.disabled = false;
                    }
                });
            }


            // --- PDF to Excel (API Integration) ---
            function setupPdfToExcelUI(file, fileUrl) {
                const toolId = 'pdf-to-excel';
                const section = document.getElementById(toolId + '-section');
                section.querySelector('#pdfToExcelFileName').textContent = file.name;
                section.querySelector('#pdfToExcelFileInfo').style.display = 'block';
                section.querySelector('#convertToExcelBtn').disabled = false;
                const placeholderMsgDiv = section.querySelector('#pdfToExcelPlaceholderMessage');
                if (placeholderMsgDiv) {
                    placeholderMsgDiv.textContent = "Ready to convert to Excel via API.";
                    placeholderMsgDiv.style.display = 'none';
                    placeholderMsgDiv.classList.remove('error');
                }
                section.querySelector('#pdfToExcelDownloadLink').style.display = 'none';
                const downloadMessageEl = section.querySelector('#pdfToExcelDownloadMessage'); 
                if(downloadMessageEl) downloadMessageEl.style.display = 'none';
            }

            function setupPdfToExcelListeners() {
                const toolId = 'pdf-to-excel';
                addDropZoneListeners(toolId, 'pdfToExcelDropZone', 'pdfToExcelFile', false, "application/pdf");
                const section = document.getElementById(toolId + '-section');
                const convertBtn = section.querySelector('#convertToExcelBtn');
                const processingMsg = section.querySelector('#pdfToExcelProcessingMsg');
                const placeholderMsgDiv = section.querySelector('#pdfToExcelPlaceholderMessage');
                const downloadLink = section.querySelector('#pdfToExcelDownloadLink');
                const downloadMessage = section.querySelector('#pdfToExcelDownloadMessage'); 

                convertBtn.addEventListener('click', async () => {
                    if (!toolState[toolId]?.file) {
                        alert("Please upload a PDF first.");
                        return;
                    }
                    if (!CLOUDCONVERT_API_KEY || CLOUDCONVERT_API_KEY === 'YOUR_API_KEY_HERE_FOR_LOCAL_TESTING_ONLY') {
                        alert("CloudConvert API Key is not configured correctly. This tool will not work.\nPlease ensure it's set for testing or a backend proxy is used in production.");
                        if (placeholderMsgDiv) {
                            placeholderMsgDiv.textContent = "API Key not configured or placeholder used. Conversion aborted.";
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                        return;
                    }

                    const pdfFile = toolState[toolId].file;

                    convertBtn.disabled = true;
                    processingMsg.textContent = 'Preparing upload...';
                    processingMsg.style.display = 'flex';
                    if (placeholderMsgDiv) {
                        placeholderMsgDiv.style.display = 'none';
                        placeholderMsgDiv.classList.remove('error');
                    }
                    downloadLink.style.display = 'none';
                    if(downloadMessage) downloadMessage.style.display = 'none';
                    if (downloadLink.href && !downloadLink.href.startsWith('blob:')) {
                        downloadLink.href = '#';
                    }

                    let importTaskId = null;
                    let convertTaskId = null;
                    let exportTaskId = null;

                    try {
                        processingMsg.textContent = 'Requesting upload URL... (Step 1/4)';
                        const createImportTaskResponse = await fetch('https://api.cloudconvert.com/v2/import/upload', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ filename: pdfFile.name })
                        });
                        if (!createImportTaskResponse.ok) {
                            const errorData = await createImportTaskResponse.json().catch(() => ({ message: createImportTaskResponse.statusText }));
                            let displayError = `Create Import Task failed: ${errorData.message || createImportTaskResponse.statusText}`;
                            if (createImportTaskResponse.status === 402) displayError = "CloudConvert API Error: Your account has run out of conversion credits or requires payment.";
                            throw new Error(displayError);
                        }
                        const importTaskDetails = (await createImportTaskResponse.json()).data;
                        importTaskId = importTaskDetails.id;
                        const uploadUrl = importTaskDetails.result.form.url;
                        const uploadParameters = importTaskDetails.result.form.parameters;

                        processingMsg.textContent = 'Uploading actual file... (Step 2/4)';
                        const fileUploadFormData = new FormData();
                        for (const key in uploadParameters) fileUploadFormData.append(key, uploadParameters[key]);
                        fileUploadFormData.append('file', pdfFile);
                        const actualUploadResponse = await fetch(uploadUrl, { method: 'POST', body: fileUploadFormData });
                        if (!actualUploadResponse.ok) throw new Error(`Actual file upload to S3 failed (${actualUploadResponse.status})`);
                        
                        processingMsg.textContent = 'Waiting for import to finalize... (Step 2/4)';
                        let currentImportTaskData = importTaskDetails;
                        for (let i = 0; i < 10 && currentImportTaskData.status !== 'finished'; i++) {
                            await new Promise(resolve => setTimeout(resolve, i === 0 ? 1500 : 3000));
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${importTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                             if(!statusResponse.ok) throw new Error(`Failed to poll import task: ${statusResponse.statusText}`);
                            currentImportTaskData = (await statusResponse.json()).data;
                            processingMsg.textContent = `Importing... Status: ${currentImportTaskData.status} (Progress: ${currentImportTaskData.percent || 0}%)`;
                            if (currentImportTaskData.status === 'error') throw new Error(`Import task failed: ${currentImportTaskData.message || 'API error'}`);
                        }
                        if (currentImportTaskData.status !== 'finished') throw new Error('Import did not finish in time.');

                        processingMsg.textContent = 'Starting conversion to Excel... (Step 3/4)';
                        const convertPayload = {
                            input: importTaskId,
                            input_format: 'pdf',
                            output_format: 'xlsx', 
                            engine: 'pdftron-pdf2excel', 
                            engine_version: 'latest'
                        };
                        const convertResponse = await fetch('https://api.cloudconvert.com/v2/convert', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify(convertPayload)
                        });
                        if (!convertResponse.ok) {
                            const errorData = await convertResponse.json().catch(() => ({ message: convertResponse.statusText }));
                            let displayError = `Conversion task creation failed: ${errorData.message || convertResponse.statusText}`;
                            if (convertResponse.status === 402) displayError = "CloudConvert API Error: Credits/payment issue for Excel conversion.";
                            throw new Error(displayError);
                        }
                        let convertResult = await convertResponse.json();
                        convertTaskId = convertResult.data.id;

                        processingMsg.textContent = 'Converting to Excel... (Waiting - Step 3/4)';
                        let currentConvertTaskData = convertResult.data;
                        for (let i = 0; i < 25 && currentConvertTaskData.status !== 'finished'; i++) {
                            await new Promise(resolve => setTimeout(resolve, 3000));
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${convertTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            if(!statusResponse.ok) throw new Error(`Failed to poll convert task: ${statusResponse.statusText}`);
                            currentConvertTaskData = (await statusResponse.json()).data;
                            processingMsg.textContent = `Converting to Excel... Status: ${currentConvertTaskData.status} (Progress: ${currentConvertTaskData.percent || 0}%)`;
                            if (currentConvertTaskData.status === 'error') throw new Error(`Conversion task failed: ${currentConvertTaskData.message || 'API error'}`);
                        }
                        if (currentConvertTaskData.status !== 'finished') throw new Error('Excel conversion did not finish in time.');

                        processingMsg.textContent = 'Preparing Excel download... (Step 4/4)';
                        const exportPayload = { input: convertTaskId };
                        const exportResponse = await fetch('https://api.cloudconvert.com/v2/export/url', {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify(exportPayload)
                        });
                        if (!exportResponse.ok) throw new Error('Export task creation failed');
                        let exportResult = await exportResponse.json();
                        exportTaskId = exportResult.data.id;

                        processingMsg.textContent = 'Finalizing Excel... (Waiting - Step 4/4)';
                        let currentExportTaskData = exportResult.data;
                        for (let i = 0; i < 10 && currentExportTaskData.status !== 'finished'; i++) {
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            const statusResponse = await fetch(`https://api.cloudconvert.com/v2/tasks/${exportTaskId}`, { headers: { 'Authorization': `Bearer ${CLOUDCONVERT_API_KEY}` } });
                            if(!statusResponse.ok) throw new Error(`Failed to poll export task: ${statusResponse.statusText}`);
                            currentExportTaskData = (await statusResponse.json()).data;
                            if (currentExportTaskData.status === 'error') throw new Error(`Export task failed: ${currentExportTaskData.message || 'API error'}`);
                        }
                        if (currentExportTaskData.status !== 'finished' || !currentExportTaskData.result?.files?.[0]?.url) {
                            throw new Error('Export did not complete or no download URL found.');
                        }

                        const downloadUrl = currentExportTaskData.result.files[0].url;
                        const convertedFileName = currentExportTaskData.result.files[0].filename || pdfFile.name.replace(/\.pdf$/i, '.xlsx');

                        downloadLink.href = downloadUrl;
                        downloadLink.download = convertedFileName;
                        downloadLink.textContent = `Download ${convertedFileName}`;
                        downloadLink.style.display = 'inline-block';
                        if(downloadMessage) {
                            downloadMessage.textContent = 'Your Excel spreadsheet is ready!'; 
                            downloadMessage.style.display = 'block';
                        }
                        processingMsg.style.display = 'none';

                    } catch (error) {
                        console.error('CloudConvert Error (Excel):', error);
                        processingMsg.style.display = 'none';
                        if (placeholderMsgDiv) {
                            placeholderMsgDiv.textContent = `Conversion Error: ${error.message}. Please check console or try again.`;
                            placeholderMsgDiv.style.display = 'block';
                            placeholderMsgDiv.classList.add('error');
                        }
                    } finally {
                        convertBtn.disabled = false;
                    }
                });
            }

            // --- Protect PDF (NEW) ---
            function setupProtectPdfUI(file, fileUrl) {
                const toolId = 'protect-pdf';
                const section = document.getElementById(toolId + '-section');
                section.querySelector('#protectPdfFileName').textContent = file.name;
                section.querySelector('#protectPdfOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#protectPdfFileInfo').style.display = 'block';
                section.querySelector('#protectPdfPassword').value = '';
                section.querySelector('#protectPdfPassword').disabled = false;
                section.querySelector('#protectPdfBtn').disabled = false;
            }

            function setupProtectPdfListeners() {
                const toolId = 'protect-pdf';
                addDropZoneListeners(toolId, 'protectPdfDropZone', 'protectPdfFile', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const passwordInput = section.querySelector('#protectPdfPassword');
                const protectBtn = section.querySelector('#protectPdfBtn');
                const processingMsg = section.querySelector('#protectPdfProcessingMsg');
                const outputInfoDiv = section.querySelector('#protectPdfOutputInfo');
                const resultTextSpan = section.querySelector('#protectPdfResultText');
                const newSizeSpan = section.querySelector('#protectPdfNewSize');
                const downloadLink = section.querySelector('#protectPdfDownloadLink');
                const downloadMessage = section.querySelector('#protectPdfDownloadMessage');

                protectBtn.addEventListener('click', async () => {
                    const state = toolState[toolId];
                    if (!state?.file) { alert("Please upload a PDF file first."); return; }
                    const password = passwordInput.value;
                    if (!password) { alert("Please enter a password."); return; }

                    protectBtn.disabled = true; passwordInput.disabled = true;
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const arrayBuffer = await state.file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                        
                        const pdfBytes = await pdfDoc.save({
                            useObjectStreams: true,
                            userPassword: password,
                            ownerPassword: password 
                        });

                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        state.resultBlobUrl = url;

                        downloadLink.href = url;
                        downloadLink.download = `protected_${state.file.name}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = "PDF protected successfully.";
                        newSizeSpan.textContent = formatBytes(blob.size);
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error protecting PDF:", error);
                        alert(`Failed to protect PDF: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!state?.file;
                        protectBtn.disabled = !fileLoaded;
                        passwordInput.disabled = !fileLoaded;
                    }
                });
            }

            // --- Unlock PDF (NEW) ---
            function setupUnlockPdfUI(file, fileUrl) {
                const toolId = 'unlock-pdf';
                const section = document.getElementById(toolId + '-section');
                section.querySelector('#unlockPdfFileName').textContent = file.name;
                section.querySelector('#unlockPdfOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#unlockPdfFileInfo').style.display = 'block';
                section.querySelector('#unlockPdfPassword').value = '';
                section.querySelector('#unlockPdfPassword').disabled = false;
                section.querySelector('#unlockPdfBtn').disabled = false;
            }

            function setupUnlockPdfListeners() {
                const toolId = 'unlock-pdf';
                addDropZoneListeners(toolId, 'unlockPdfDropZone', 'unlockPdfFile', false, "application/pdf");

                const section = document.getElementById(toolId + '-section');
                const passwordInput = section.querySelector('#unlockPdfPassword');
                const unlockBtn = section.querySelector('#unlockPdfBtn');
                const processingMsg = section.querySelector('#unlockPdfProcessingMsg');
                const outputInfoDiv = section.querySelector('#unlockPdfOutputInfo');
                const resultTextSpan = section.querySelector('#unlockPdfResultText');
                const newSizeSpan = section.querySelector('#unlockPdfNewSize');
                const downloadLink = section.querySelector('#unlockPdfDownloadLink');
                const downloadMessage = section.querySelector('#unlockPdfDownloadMessage');

                unlockBtn.addEventListener('click', async () => {
                    const state = toolState[toolId];
                    if (!state?.file) { alert("Please upload a PDF file first."); return; }
                    const password = passwordInput.value;
                    
                    unlockBtn.disabled = true; passwordInput.disabled = true;
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                     if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }


                    try {
                        const arrayBuffer = await state.file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { 
                            userPassword: password || undefined, 
                            ownerPassword: password || undefined 
                        });

                        const pdfBytes = await pdfDoc.save({ useObjectStreams: true });

                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        state.resultBlobUrl = url;

                        downloadLink.href = url;
                        downloadLink.download = `unlocked_${state.file.name}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = "PDF unlocked successfully.";
                        newSizeSpan.textContent = formatBytes(blob.size);
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error unlocking PDF:", error);
                        let userMessage = `Failed to unlock PDF: ${error.message}`;
                        if (error.name === 'EncryptedPDFError' || error.message.toLowerCase().includes('password')) {
                            userMessage = "Failed to unlock PDF. The password might be incorrect, or the PDF uses an unsupported encryption type.";
                        }
                        alert(userMessage);
                        resultTextSpan.textContent = `Error: ${userMessage}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!state?.file;
                        unlockBtn.disabled = !fileLoaded;
                        passwordInput.disabled = !fileLoaded;
                    }
                });
            }

            // --- PDF Metadata Viewer/Editor (NEW) ---
            async function setupPdfMetadataUI(file, fileUrl) {
                const toolId = 'pdf-metadata';
                const section = document.getElementById(toolId + '-section');
                const processingMsg = section.querySelector('#pdfMetadataProcessingMsg');
                const displayArea = section.querySelector('#pdfMetadataDisplayArea');
                const saveBtn = section.querySelector('#savePdfMetadataBtn');

                section.querySelector('#pdfMetadataFileNameDisplay').textContent = file.name;
                displayArea.style.display = 'none';
                saveBtn.disabled = true;

                if (!pdfLibInstance) { alert("PDF-Lib library not loaded."); return; }
                processingMsg.style.display = 'flex';

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { 
                        ignoreEncryption: true, 
                        updateMetadata: false 
                    });

                    section.querySelector('#metaTitle').value = pdfDoc.getTitle() || '';
                    section.querySelector('#metaAuthor').value = pdfDoc.getAuthor() || '';
                    section.querySelector('#metaSubject').value = pdfDoc.getSubject() || '';
                    section.querySelector('#metaKeywords').value = pdfDoc.getKeywords() || '';
                    section.querySelector('#metaCreator').textContent = pdfDoc.getCreator() || '-';
                    section.querySelector('#metaProducer').textContent = pdfDoc.getProducer() || '-';
                    
                    const creationDate = pdfDoc.getCreationDate();
                    section.querySelector('#metaCreationDate').textContent = creationDate ? creationDate.toLocaleString() : '-';
                    
                    const modDate = pdfDoc.getModificationDate();
                    section.querySelector('#metaModDate').textContent = modDate ? modDate.toLocaleString() : '-';

                    displayArea.style.display = 'block';
                    saveBtn.disabled = false;

                } catch (error) {
                    console.error("Error loading PDF metadata:", error);
                    alert(`Failed to load PDF metadata: ${error.message}. The PDF might be encrypted or corrupted.`);
                    resetToolState(toolId);
                } finally {
                    processingMsg.style.display = 'none';
                }
            }

            function setupPdfMetadataListeners() {
                const toolId = 'pdf-metadata';
                addDropZoneListeners(toolId, 'pdfMetadataDropZone', 'pdfMetadataFile', false, "application/pdf");
                
                const section = document.getElementById(toolId + '-section');
                const saveBtn = section.querySelector('#savePdfMetadataBtn');
                const processingMsg = section.querySelector('#pdfMetadataProcessingMsg');
                const outputInfoDiv = section.querySelector('#pdfMetadataOutputInfo');
                const resultTextSpan = section.querySelector('#pdfMetadataResultText');
                const downloadLink = section.querySelector('#pdfMetadataDownloadLink');
                const downloadMessage = section.querySelector('#pdfMetadataDownloadMessage');

                saveBtn.addEventListener('click', async () => {
                    const state = toolState[toolId];
                    if (!state?.file) { alert("Please upload a PDF file first."); return; }

                    saveBtn.disabled = true;
                    processingMsg.style.display = 'flex';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const arrayBuffer = await state.file.arrayBuffer();
                        const pdfDoc = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                        const title = section.querySelector('#metaTitle').value;
                        const author = section.querySelector('#metaAuthor').value;
                        const subject = section.querySelector('#metaSubject').value;
                        const keywords = section.querySelector('#metaKeywords').value;

                        if (title) pdfDoc.setTitle(title);
                        if (author) pdfDoc.setAuthor(author);
                        if (subject) pdfDoc.setSubject(subject);
                        if (keywords) pdfDoc.setKeywords(keywords.split(',').map(k => k.trim()).filter(k => k));
                        pdfDoc.setModificationDate(new Date());


                        const pdfBytes = await pdfDoc.save({ useObjectStreams: true });
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        const url = URL.createObjectURL(blob);
                        state.resultBlobUrl = url;

                        downloadLink.href = url;
                        downloadLink.download = `metadata_updated_${state.file.name}`;
                        downloadLink.style.display = 'inline-block';
                        downloadMessage.style.display = 'block';

                        resultTextSpan.textContent = "PDF metadata updated successfully.";
                        outputInfoDiv.style.display = 'block';

                    } catch (error) {
                        console.error("Error saving PDF metadata:", error);
                        alert(`Failed to save PDF metadata: ${error.message}`);
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                    } finally {
                        processingMsg.style.display = 'none';
                        const fileLoaded = !!state?.file;
                        saveBtn.disabled = !fileLoaded;
                    }
                });
            }
            
            // --- HTML to PDF (NEW) ---
            function setupHtmlToPdfUI() {
                const toolId = 'html-to-pdf';
                const section = document.getElementById(toolId + '-section');
                const convertBtn = section.querySelector('#convertToPdfFromHtmlBtn');
                const inputArea = section.querySelector('#htmlToPdfInputArea');
                
                inputArea.value = '';
                convertBtn.disabled = true;
                toolState[toolId] = { isInitialized: true };
            }

            function setupHtmlToPdfListeners() {
                const toolId = 'html-to-pdf';
                const section = document.getElementById(toolId + '-section');
                const inputArea = section.querySelector('#htmlToPdfInputArea');
                const convertBtn = section.querySelector('#convertToPdfFromHtmlBtn');
                const processingMsg = section.querySelector('#htmlToPdfProcessingMsg');
                const resultEmbed = section.querySelector('#htmlToPdfResultEmbed');
                const previewContainer = section.querySelector('#htmlToPdfPreviewContainer');
                const successMsg = previewContainer.querySelector('.preview-success-message');
                const outputInfoDiv = section.querySelector('#htmlToPdfOutputInfo');
                const resultTextSpan = section.querySelector('#htmlToPdfResultText');
                const downloadLink = section.querySelector('#htmlToPdfDownloadLink');
                const downloadMessage = section.querySelector('#htmlToPdfDownloadMessage');

                inputArea.addEventListener('input', () => {
                    convertBtn.disabled = !inputArea.value.trim();
                });

                convertBtn.addEventListener('click', async () => {
                    const htmlContent = inputArea.value.trim();
                    if (!htmlContent) { alert("Please paste some HTML content."); return; }
                    if (!jspdfInstance?.jsPDF) { alert("jsPDF library not loaded. Cannot convert HTML."); return; }
                    if (!domPurifyInstance) { alert("DOMPurify library not loaded. HTML to PDF conversion aborted for security. Check console."); return;}
                    if (!html2canvasInstance) { alert("html2canvas library not loaded. HTML to PDF conversion aborted. Check console."); return;}


                    convertBtn.disabled = true; inputArea.disabled = true;
                    processingMsg.style.display = 'flex';
                    previewContainer.style.display = 'none';
                    outputInfoDiv.style.display = 'none';
                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    if (resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                    resultEmbed.removeAttribute('src');
                    if (successMsg) successMsg.style.display = 'none';
                    if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch(e){} }

                    try {
                        const { jsPDF } = jspdfInstance;
                        const pdf = new jsPDF({
                            unit: 'pt',
                            format: 'a4',
                            orientation: 'portrait'
                        });
                        
                        const cleanHtml = domPurifyInstance.sanitize(htmlContent);
                        
                        await pdf.html(cleanHtml, { 
                            callback: function (doc) {
                                const pdfBlob = doc.output('blob');
                                const url = URL.createObjectURL(pdfBlob);
                                toolState[toolId].resultBlobUrl = url;

                                resultEmbed.src = url;
                                resultEmbed.style.display = 'block';
                                previewContainer.style.display = 'block';
                                if (successMsg) {
                                    successMsg.textContent = `PDF generated! Size: ${formatBytes(pdfBlob.size)}`;
                                    successMsg.style.display = 'block';
                                }

                                downloadLink.href = url;
                                downloadLink.download = 'converted_html.pdf';
                                downloadLink.style.display = 'inline-block';
                                downloadMessage.style.display = 'block';

                                resultTextSpan.textContent = `HTML converted to PDF. Size: ${formatBytes(pdfBlob.size)}`;
                                outputInfoDiv.style.display = 'block';
                                processingMsg.style.display = 'none';
                                convertBtn.disabled = false; inputArea.disabled = false;
                            },
                            x: 15, 
                            y: 15, 
                            autoPaging: 'text', 
                            width: 565, 
                            windowWidth: 800,
                            html2canvas: {
                                scale: 0.75, 
                                useCORS: true 
                            }
                        });

                    } catch (error) {
                        console.error("Error converting HTML to PDF:", error);
                        let errorMsg = `Failed to convert HTML to PDF: ${error.message}.`;
                        if (error.message && error.message.toLowerCase().includes("could not load html2canvas")){
                            errorMsg += " Please ensure html2canvas library is correctly loaded."
                        }
                        alert(errorMsg + " Check console for details.");
                        resultTextSpan.textContent = `Error: ${error.message}`;
                        outputInfoDiv.style.display = 'block';
                        processingMsg.style.display = 'none';
                        convertBtn.disabled = false; inputArea.disabled = false;
                    }
                });
            }


            // --- Initialize All Tool Listeners ---
            function initializeAllToolListeners() {
                setupImageCompressorListeners();
                setupImageResizerListeners();
                setupImageConverterListeners();
                setupImageCropperListeners();
                setupImageRotateFlipListeners();
                setupImageFiltersListeners();
                setupImageToBase64Listeners();
                setupBase64ToImageListeners();
                setupImageColorPickerListeners(); 
                setupImageWatermarkListeners(); 
                setupJpgToPdfListeners();
                setupPdfToJpgListeners();
                setupMergePdfListeners();
                setupSplitPdfListeners();
                setupOrganizePdfListeners();
                setupRotatePdfListeners();
                setupAddPageNumbersPdfListeners();
                setupAddTextWatermarkPdfListeners();
                setupCompressPdfListeners();
                setupPdfToWordListeners();
                setupPdfToPowerPointListeners(); 
                setupPdfToExcelListeners();   
                setupProtectPdfListeners(); 
                setupUnlockPdfListeners(); 
                setupPdfMetadataListeners(); 
                setupHtmlToPdfListeners(); 
            }

            // --- Contact Form ---
             function setupContactForm() { 
                 const contactForm = document.getElementById('contactForm');
                 if (contactForm) {
                     contactForm.addEventListener('submit', function(e) {
                         const formAction = contactForm.getAttribute('action');
                         if (!formAction || formAction === '#') {
                              e.preventDefault();
                              alert("Thank you! (Demo form - not sending emails)");
                              console.warn("Contact form submit blocked - no action set.");
                         }
                     });
                 }
             }

            // --- Blob Cleanup ---
            function setupBlobCleanup() {
                window.addEventListener('beforeunload', () => {
                    console.log("[CLEANUP] Revoking Blob URLs...");
                    let revokedCount = 0;
                    const urlsToRevoke = new Set();

                    document.querySelectorAll('img[src^="blob:"], embed[src^="blob:"], a[href^="blob:"]')
                        .forEach(el => { if(el.src && el.src.startsWith('blob:')) urlsToRevoke.add(el.src); if(el.href && el.href.startsWith('blob:')) urlsToRevoke.add(el.href); });

                    Object.values(toolState).forEach(state => {
                        if (state?.imageObject?.src?.startsWith('blob:')) urlsToRevoke.add(state.imageObject.src);
                        if (state?.mainImageObject?.src?.startsWith('blob:')) urlsToRevoke.add(state.mainImageObject.src); 
                        if (state?.watermarkImageObject?.src?.startsWith('blob:')) urlsToRevoke.add(state.watermarkImageObject.src); 
                        if (state?.fileUrl?.startsWith('blob:')) urlsToRevoke.add(state.fileUrl);
                        if (state?.mainImageUrl?.startsWith('blob:')) urlsToRevoke.add(state.mainImageUrl); 
                        if (state?.watermarkImageUrl?.startsWith('blob:')) urlsToRevoke.add(state.watermarkImageUrl); 
                        if (state?.firstPagePreviewUrl?.startsWith('blob:')) urlsToRevoke.add(state.firstPagePreviewUrl);
                        if (state?.previewBlobUrl?.startsWith('blob:')) urlsToRevoke.add(state.previewBlobUrl);
                        if (state?.resultBlobUrl?.startsWith('blob:')) urlsToRevoke.add(state.resultBlobUrl);
                        if (state?.files) {
                            state.files.forEach(fileObj => { if(fileObj.url?.startsWith('blob:')) urlsToRevoke.add(fileObj.url); });
                        }
                    });

                    urlsToRevoke.forEach(url => {
                         try { URL.revokeObjectURL(url); revokedCount++; } catch (e) { /* Silently ignore */ }
                    });
                    console.log(`[CLEANUP] Attempted revoke for ${urlsToRevoke.size} URLs, ${revokedCount} successful.`);
                });
            }

        })(); // End IIFE
    </script>

</body>
</html>
