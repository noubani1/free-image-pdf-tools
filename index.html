<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Updated Title -->
    <title>FreeImagePDFTools</title>
    <meta name="description" content="Free online tools for image compression, resizing, conversion (JPG, PNG, WebP), interactive cropping, rotation, and various filters. Optimize your photos, manage files, and discover future PDF tools.">
    <meta name="keywords" content="online tools, free tools, image compressor, compress image, image resizer, resize image, image converter, convert image, JPG, PNG, WebP, image crop, crop photo, interactive crop, rotate image, flip image, image filters, grayscale image, sepia, invert, photo filters, PDF tools, online PDF, web tools, photo editor, optimize photos">
    <meta name="author" content="FreeImagePDFTools">

    <!-- Favicon (Optional but recommended for SEO and branding) -->
    <!-- <link rel="icon" href="/favicon.ico" type="image/x-icon"> -->

    <!-- Google Fonts (Optional, replace with your preferred font) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <!-- AOS (Animate On Scroll) CSS -->
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">


    <!-- Open Graph / Social Media Tags -->
    <meta property="og:title" content="FreeImagePDFTools | Free Image & PDF Tools">
    <meta property="og:description" content="Free online tools for image compression, resizing, conversion, cropping, and more. Easy-to-use browser-based photo and document utilities.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="YOUR_WEBSITE_URL_HERE"> <!-- REMOVE or replace with your actual URL -->
    <!-- <meta property="og:image" content="YOUR_IMAGE_URL_HERE"> --> <!-- Replace with a relevant image -->


    <style>
        /* --- General & Layout Styles --- */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --info-color: #17a2b8; /* This is the color used by menu links */
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --light-color: #f8f9fa;
            --dark-color: #343a3a; /* Slightly darker for contrast */
            --white-color: #fff;
            --gray-color: #6c757d;
            --border-radius: 0.5rem; /* Increased border-radius */
            --padding-base: 1rem;
            --margin-base: 1rem;
            --section-spacing: 3rem; /* Space between tool sections */
        }

        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--light-color);
            color: var(--dark-color);
            padding-top: 60px; /* Add padding equal to header height */
        }

        header {
            background-color: var(--dark-color);
            color: var(--white-color);
            padding: 0.8rem var(--padding-base);
            position: fixed; /* Fixed header */
            width: 100%;
            top: 0;
            left: 0;
            z-index: 1000; /* Ensure header is on top */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        header .container {
            display: flex;
            /* Changed from space-between to flex-start */
            justify-content: flex-start;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 var(--padding-base); /* Adjust padding to avoid double padding */
            box-shadow: none; /* Remove container box shadow from header container */
            /* Added gap for space between site title and nav */
            gap: 2rem; /* Adjust this value for desired spacing */
        }

        header h1 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--info-color); /* Match menu link color */
             /* text-align: left; /* Can keep or remove, flexbox handles alignment */
        }

         header nav ul {
             list-style: none;
             margin: 0;
             padding: 0;
             display: flex;
             gap: 1rem;
         }

         header nav a {
             color: var(--info-color); /* Color the title should match */
             text-decoration: none;
             font-weight: bold;
             transition: color 0.3s ease;
         }

         header nav a:hover {
             color: var(--white-color);
         }


        .container {
            max-width: 1200px;
            margin: var(--margin-base) auto;
            padding: var(--padding-base);
            background-color: var(--white-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* Softer shadow */
            border-radius: var(--border-radius); /* Rounded corners */
        }

        h1, h2, h3 {
            color: var(--dark-color);
            margin-bottom: var(--padding-base);
            text-align: center;
        }
        /* Ensure header h1 retains its updated color */
        header h1 {
            color: var(--info-color);
        }


        h2 {
            margin-top: 0; /* Remove extra top margin */
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.3s ease; /* Smooth link hover */
        }

        a:hover {
            text-decoration: underline;
            color: #0056b3; /* Darker hover color */
        }

        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--white-color); /* Ensure default text color is white */
            padding: 0.75rem 1.5rem; /* Larger padding for tappability */
            border-radius: var(--border-radius);
            text-align: center;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease; /* Added transform for hover */
            font-size: 1rem;
            line-height: 1.5;
            vertical-align: middle;
            text-decoration: none; /* Ensure buttons aren't underlined if used as links */
        }

        .btn:hover {
            background-color: #0056b3;
            color: var(--white-color); /* FIX: Ensure text color remains white on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: var(--white-color); /* Ensure default text color is white for secondary */
        }

        .btn-secondary:hover {
            background-color: #545b62;
             color: var(--white-color); /* FIX: Ensure text color remains white on hover */
        }

        .btn-success {
             background-color: var(--success-color);
             color: var(--white-color); /* Ensure default text color is white for success */
        }

        .btn-success:hover {
             background-color: #218838;
             color: var(--white-color); /* FIX: Ensure text color remains white on hover */
        }

        .btn:disabled {
            background-color: #cccccc;
            color: #666; /* Darker text for disabled */
            cursor: not-allowed;
            transform: none; /* No transform when disabled */
        }


        .alert {
            padding: var(--padding-base);
            margin-bottom: var(--margin-base);
            border-radius: var(--border-radius);
        }

        .alert-info {
            background-color: var(--info-color);
            color: var(--white-color);
        }

        /* --- UPDATED CSS RULES --- */
        /* Hide all sections initially. JS will show the correct one on load. */
         main > section {
             display: none;
         }


        /* --- Ad Placement Styles --- */
        .ad-container {
            width: 100%;
            margin: 2rem auto;
            text-align: center;
            background-color: var(--light-color);
            padding: 1rem;
            border: 1px dashed var(--gray-color);
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            color: var(--gray-color);
        }

        /* --- Tool Specific Styles (General) --- */
         .tool-controls {
            margin-bottom: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            justify-content: center;
        }

         .tool-controls label {
            font-weight: bold;
            margin-right: 10px;
         }

        .file-input-container {
            margin-bottom: 1.5rem;
            text-align: center;
        }

        /* Style for the visible drag and drop zone */
         .drop-zone {
             border: 2px dashed var(--primary-color);
             border-radius: var(--border-radius);
             padding: 2rem;
             text-align: center;
             cursor: pointer;
             transition: background-color 0.3s ease, border-color 0.3s ease;
             color: var(--gray-color);
             max-width: 500px; /* Limit drop zone size */
             margin: 1rem auto; /* Center the zone */
             display: flex; /* Use flex for centering content */
             flex-direction: column;
             align-items: center;
             justify-content: center;
             min-height: 150px;
             /* Important: ensure it has layout, not just 'display: none' when its section is active */
         }

         .drop-zone.drag-over {
             background-color: rgba(0, 123, 255, 0.05);
             border-color: var(--primary-color);
         }

        /* Hide the actual file input, but keep it for click functionality */
        input[type="file"] {
            display: none; /* Hide the default input */
        }
         /* Style for the label that triggers the hidden file input */
         .drop-zone label {
             margin-top: 1rem;
             color: var(--primary-color); /* Make the "Click to Upload" text stand out */
             cursor: pointer;
             font-weight: bold;
         }
         .drop-zone label:hover {
             text-decoration: underline;
         }


        .image-info, .output-info {
            margin-top: 1.5rem;
            border-top: 1px solid #eee;
            padding-top: 1.5rem;
            display: none;
        }

         .image-info p, .output-info p {
             margin: 0.5rem 0;
         }

        .image-preview {
            margin-top: 1.5rem;
            text-align: center;
            padding-top: 1.5rem;
            border-top: 1px solid #eee;
            display: none;
        }

         /* Styles for the side-by-side comparison (Compressor) */
        .preview-comparison {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 1rem;
        }

        .preview-comparison > div {
            flex: 1 1 300px;
            max-width: 50%;
             text-align: center;
        }

        .image-preview img { /* General style for single preview images */
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            padding: 5px;
            background-color: var(--white-color);
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.05);
             display: none; /* Hidden by default */
             margin: 0 auto;
             border-radius: var(--border-radius); /* Rounded image corners */
        }
         .preview-comparison img { /* Override for comparison images to ensure block display */
             display: block;
         }


        .preview-comparison .preview-label {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: block;
        }


        .download-section {
            margin-top: 1.5rem;
            text-align: center;
        }

        .download-section a {
            margin-top: var(--margin-base);
        }

        /* Added Processing Message Style */
         .processing-message {
             text-align: center;
             margin-top: 1rem;
             font-style: italic;
             color: var(--gray-color);
             display: none; /* Hidden by default */
         }


        /* Specific Slider Style */
         input[type="range"] {
             width: 80%;
             max-width: 400px;
             vertical-align: middle;
             flex-grow: 1;
             min-width: 150px;
        }

         /* Specific Resizer/Crop Inputs */
         .dimension-inputs, .crop-inputs {
             display: flex;
             flex-wrap: wrap;
             gap: 1rem;
             align-items: center;
             justify-content: center;
         }
         .dimension-inputs input[type="number"], .crop-inputs input[type="number"] {
             width: 80px;
             padding: 0.5rem;
             border: 1px solid #ccc;
             border-radius: var(--border-radius);
             text-align: center;
             vertical-align: middle;
         }
         .dimension-inputs span, .crop-inputs span {
              vertical-align: middle;
         }
         .dimension-inputs label, .crop-inputs label {
             margin-right: 0;
         }


         /* Specific Converter Controls */
         .convert-controls {
             display: flex;
             flex-wrap: wrap;
             gap: 1rem;
             align-items: center;
             justify-content: center;
         }
         .convert-controls select {
             padding: 0.5rem;
             border: 1px solid #ccc;
             border-radius: var(--border-radius);
             font-size: 1rem;
             cursor: pointer;
             vertical-align: middle;
         }

         /* Specific Rotate/Flip Controls */
          .rotate-flip-controls {
             display: flex;
             flex-wrap: wrap;
             gap: 1rem;
             align-items: center;
             justify-content: center;
         }
          .rotate-flip-controls button {
             /* Style inherited from .btn */
          }

         /* Specific Filter Controls */
          .filter-controls {
             display: flex;
             flex-wrap: wrap;
             gap: 1rem;
             align-items: center;
             justify-content: center;
          }
          .filter-controls select {
              padding: 0.5rem;
              border: 1px solid #ccc;
              border-radius: var(--border-radius);
              font-size: 1rem;
              cursor: pointer;
              vertical-align: middle;
          }


         /* --- Cropper Specific Styles --- */
         /* Container for image and overlay */
         #cropImagePreview .cropper-container {
             position: relative;
             display: inline-block;
             max-width: 100%;
             vertical-align: top;
             /* Important: ensure it has positioning context for the overlay */
         }
          /* Ensure the image inside the cropper container is also responsive */
         #cropImagePreview .cropper-container img {
              display: block; /* Ensure img inside container takes up space */
             max-width: 100%;
             height: auto;
             border: 1px solid #ddd;
             padding: 5px;
             background-color: var(--white-color);
             box-shadow: 0 0 8px rgba(0, 0, 0, 0.05);
             border-radius: var(--border-radius); /* Rounded image corners */
             /* This image is for displaying the ORIGINAL within the crop area */
             /* Its display style is controlled by JS */
         }

         /* The selection overlay */
         #cropImagePreview .crop-selection-overlay {
             position: absolute;
             top: 0;
             left: 0;
             width: 0;
             height: 0;
             border: 1px dashed var(--primary-color);
             background-color: rgba(0, 123, 255, 0.1);
             box-sizing: border-box;
             pointer-events: none; /* Allow clicks to pass through to the image */
             display: none; /* Hidden by default */
             z-index: 10; /* Ensure it's above the image */
         }

         /* Style for the RESULT image in cropper preview */
          #cropImagePreview #croppedImage {
              /* Inherits general .image-preview img styles */
              /* This image is for displaying the CROPPED result */
              /* Its display style is controlled by JS */
          }


         /* --- Homepage Specific Styles --- */
         /* Homepage header & footer styles moved/adjusted */
         #homepage-section .hero {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem 1rem;
            background-color: var(--info-color);
            color: var(--white-color);
            border-radius: var(--border-radius);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        #homepage-section .hero h2 {
            color: var(--white-color);
            margin-top: 0;
            font-size: 1.8rem;
        }

        #homepage-section .hero p {
            font-size: 1.1rem;
        }

        #homepage-section .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 1.5rem;
        }

        #homepage-section .tool-card {
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            padding: var(--padding-base);
            text-align: center;
            background-color: var(--white-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); /* Subtle card shadow */
        }

        #homepage-section .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

         /* Style for the icon container in the tool card */
         .tool-card .icon-container {
             font-size: 3rem; /* Adjust icon size */
             margin-bottom: 0.5rem;
             color: var(--primary-color); /* Icon color */
         }


        #homepage-section .tool-card h3 {
            margin-top: 0;
            font-size: 1.3rem;
        }
        /* Styling for links within tool card h3 */
        #homepage-section .tool-card h3 a {
            color: inherit; /* Inherit color from h3 (var(--dark-color)) */
            text-decoration: none; /* Remove underline by default */
        }
        #homepage-section .tool-card h3 a:hover {
            text-decoration: underline; /* Add underline on hover */
            color: var(--primary-color); /* Change color on hover */
        }


        #homepage-section .tool-card p {
            font-size: 0.95rem;
            color: var(--gray-color);
            flex-grow: 1;
            margin-bottom: 1rem;
        }

         #homepage-section .tool-card .tool-link {
             margin-top: auto;
             display: block;
         }


         /* About, Contact, Privacy Styles */
         #about-section h2, #contact-section h2, #privacy-section h2 {
             margin-bottom: 1.5rem;
         }

         #about-section p, #privacy-section p {
             margin-bottom: 1rem;
             text-align: justify;
         }

         #contact-section form {
             max-width: 600px;
             margin: 0 auto;
             display: flex;
             flex-direction: column;
             gap: 1rem;
         }

         #contact-section label {
             font-weight: bold;
             margin-bottom: 0.2rem;
         }

         #contact-section input[type="text"],
         #contact-section input[type="email"],
         #contact-section textarea {
             padding: 0.7rem;
             border: 1px solid #ccc;
             border-radius: var(--border-radius);
             font-size: 1rem;
             width: 100%;
             box-sizing: border-box;
         }

          #contact-section textarea {
              min-height: 150px;
              resize: vertical;
          }

         #contact-section button[type="submit"] {
             align-self: center;
             margin-top: 0.5rem;
         }


        /* --- Footer (Shared) --- */
        footer {
            margin-top: 2rem;
            padding: 1.5rem var(--padding-base);
            background-color: var(--dark-color);
            color: var(--white-color);
            text-align: center;
        }

        footer p {
            margin: 0.5rem 0;
        }

        footer a {
            color: var(--info-color);
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            body {
                 padding-top: 100px; /* More padding if header wraps */
            }

            header .container {
                 flex-direction: column;
                 gap: 0.5rem; /* Adjust gap for stacked layout */
                 align-items: center; /* Center items when stacked */
                 justify-content: center; /* Center content when stacked */
            }
             header h1 {
                 text-align: center; /* Center title on small screens */
                 /* Color already set to --info-color */
             }
             header nav ul {
                 flex-direction: column;
                 gap: 0.5rem;
                 align-items: center; /* Center nav items */
             }


            .container {
                padding: var(--padding-base);
                margin: var(--padding-base); /* Reduce margin on smaller screens */
            }

            /* Ensure h1 inside container keeps its default color */
            .container h1 {
                color: var(--dark-color);
                font-size: 1.8rem;
            }


            h2 {
                font-size: 1.5rem;
            }

             #homepage-section .hero h2 {
                font-size: 1.6rem;
            }

             .tool-controls {
                flex-direction: column;
                align-items: stretch;
                justify-content: flex-start;
            }

             .tool-controls label {
                 margin-bottom: 0.5rem;
                 margin-right: 0;
             }

             input[type="range"] {
                 width: 100%;
                 max-width: none;
             }

             .dimension-inputs, .crop-inputs {
                 flex-direction: column;
                 align-items: stretch;
             }
             .dimension-inputs input[type="number"], .crop-inputs input[type="number"] {
                 width: 100%;
                 box-sizing: border-box;
             }

             .convert-controls select {
                 width: 100%;
                 box-sizing: border-box;
             }
             .rotate-flip-controls, .filter-controls {
                 flex-direction: column;
                 align-items: stretch;
             }
             .rotate-flip-controls button, .filter-controls button, .filter-controls select {
                 width: 100%;
                 box-sizing: border-box;
             }


             /* Stack images vertically on smaller screens */
             .preview-comparison {
                flex-direction: column;
                gap: var(--padding-base);
             }
             .preview-comparison > div {
                 flex: none; /* Prevent flex shrink/grow on small screens */
                 width: 100%; /* Take full width */
                 max-width: none; /* Remove max-width constraint */
             }

             /* Contact form adjustments */
             #contact-section form {
                 padding: 0 1rem;
             }

             /* Adjust drop zone size for small screens */
             .drop-zone {
                 max-width: 100%;
                 padding: 1.5rem;
             }
        }

    </style>

    <!-- JSON-LD Schema for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "FreeImagePDFTools",
      "url": "YOUR_WEBSITE_URL_HERE", <!-- REMOVE or replace with your actual URL -->
      "potentialAction": {
        "@type": "SearchAction",
        "target": "YOUR_WEBSITE_URL_HERE?q={search_term_string}", <!-- REMOVE or replace with your actual URL -->
        "query-input": "required name=search_term_string"
      }
    }
    </script>

</head>
<body>

    <header>
        <div class="container">
            <!-- Website name/title section -->
            <div class="site-title">
                <!-- Link the site title to the homepage -->
                <a href="#homepage-section" style="text-decoration: none;">
                    <h1>FreeImagePDFTools</h1>
                </a>
            </div>
            <!-- Navigation links -->
            <nav>
                <ul>
                    <li><a href="#homepage-section">Home</a></li>
                    <li><a href="#about-section">About</a></li>
                    <li><a href="#contact-section">Contact</a></li>
                    <li><a href="#privacy-section">Privacy</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main> <!-- Wrap tool and info sections in <main> -->

        <!-- Homepage Section -->
        <section id="homepage-section" class="container" data-aos="fade-up">
            <div class="hero">
                <h2>Unlock the Power of Free Online Tools</h2>
                <p>Discover our collection of easy-to-use tools for images, PDFs, and more!</p>
                 <a href="#image-compressor-section" class="btn">Get Started - Image Compressor</a>
            </div>

            <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Homepage Top -->
                <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Homepage Top Ad)</p>
            </div>

            <h3>Our Tools</h3>
            <div class="tools-grid">
                <!-- Image Tools -->
                <div class="tool-card">
                    <div class="icon-container">🖼️</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-compressor-section">Image Compressor</a></h3>
                    <p>Quickly reduce the file size of your images (JPG, PNG) while maintaining quality.</p>
                    <a href="#image-compressor-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card">
                    <div class="icon-container">📐</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-resizer-section">Image Resizer</a></h3>
                    <p>Change the dimensions of your images to fit your needs by specifying width and height.</p>
                    <a href="#image-resizer-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card">
                    <div class="icon-container">🔄</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-converter-section">Image Converter</a></h3>
                    <p>Convert images between different formats like JPG, PNG, and WebP.</p>
                    <a href="#image-converter-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card">
                     <div class="icon-container">✂️</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-cropper-section">Image Cropper</a></h3>
                    <p>Select and crop a specific area of your image using your mouse.</p>
                    <a href="#image-cropper-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card">
                     <div class="icon-container">↩️</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-rotate-flip-section">Rotate & Flip Image</a></h3>
                    <p>Rotate images by 90 degrees or flip them horizontally or vertically.</p>
                    <a href="#image-rotate-flip-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card">
                     <div class="icon-container">✨</div> <!-- Placeholder Icon -->
                    <h3><a href="#image-filters-section">Image Filters</a></h3>
                    <p>Apply basic filters like Grayscale to your images.</p>
                    <a href="#image-filters-section" class="tool-link btn">Use Tool</a>
                </div>


                <!-- PDF Tools (Placeholders) -->
                 <div class="tool-card">
                    <div class="icon-container">📄</div> <!-- Placeholder Icon -->
                    <h3><a href="#">Merge PDF</a></h3>
                    <p>Combine multiple PDF files into a single document.</p>
                    <a href="#" class="tool-link btn btn-secondary">Coming Soon</a>
                </div>
                 <div class="tool-card">
                    <div class="icon-container">📄</div> <!-- Placeholder Icon -->
                    <h3><a href="#">Split PDF</a></h3>
                    <p>Extract specific pages or page ranges from a PDF.</p>
                    <a href="#" class="tool-link btn btn-secondary">Coming Soon</a>
                </div>
                 <div class="tool-card">
                     <div class="icon-container">📄➡️🖼️</div> <!-- Placeholder Icon -->
                    <h3><a href="#">PDF to JPG</a></h3>
                    <p>Convert each page of a PDF file into individual JPG images.</p>
                    <a href="#" class="tool-link btn btn-secondary">Coming Soon</a>
                </div>
                 <div class="tool-card">
                     <div class="icon-container">🖼️➡️📄</div> <!-- Placeholder Icon -->
                    <h3><a href="#">JPG to PDF</a></h3>
                    <p>Combine multiple JPG images into a single PDF file.</p>
                    <a href="#" class="tool-link btn btn-secondary">Coming Soon</a>
                </div>
                 <!-- Add more tool cards here -->
            </div>

            <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Homepage Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Homepage Bottom Ad)</p>
            </div>
        </section>


        <!-- Image Compressor Tool Section -->
        <section id="image-compressor-section" class="container" data-aos="fade-up">
            <h2>Online Image Compressor</h2>
            <p>Reduce the file size of your images without losing noticeable quality. Supports JPG, PNG, and WebP.</p>

            <div class="file-input-container">
                 <!-- Drop Zone for Compressor -->
                 <div id="compressDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="compressImageFile">Click to Upload Image</label>
                    <input type="file" id="compressImageFile" accept="image/*" aria-label="Select image file for compression">
                 </div>
            </div>

            <div class="tool-controls">
                <label for="compressionQuality">Compression Level:</label>
                <input type="range" id="compressionQuality" min="10" max="100" value="80">
                <span id="qualityValue">80%</span>
                <button id="compressNowBtn" class="btn" disabled>Compress Now</button>
            </div>
            <p id="compressProcessingMsg" class="processing-message">Processing...</p>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Compressor Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Compressor Top Ad)</p>
            </div>

            <div id="compressImageInfo" class="image-info">
                <h3>Compression Info</h3>
                <p><strong>Filename:</strong> <span id="compressOriginalFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="compressOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="compressedSize">-</span></p>
                 <p><strong>Reduction:</strong> <span id="sizeReduction">-</span></p>
            </div>

            <div id="compressImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div>
                        <span class="preview-label">Original</span>
                        <img id="originalImagePreview" src="" alt="Original Image Preview">
                     </div>
                     <div>
                        <span class="preview-label">Compressed</span>
                        <img id="compressedImagePreview" src="" alt="Compressed Image Preview">
                     </div>
                 </div>
            </div>

            <div class="download-section">
                 <p id="compressDownloadMessage" style="display: none;">Your compressed image is ready!</p>
                <a id="compressDownloadLink" class="btn btn-success" style="display: none;">Download Compressed Image</a>
            </div>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Compressor Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Compressor Bottom Ad)</p>
            </div>

        </section>

         <!-- Image Resizer Tool Section -->
        <section id="image-resizer-section" class="container" data-aos="fade-up">
            <h2>Online Image Resizer</h2>
            <p>Easily change the dimensions of your images.</p>

            <div class="file-input-container">
                 <!-- Drop Zone for Resizer -->
                 <div id="resizeDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="resizeImageFile">Click to Upload Image</label>
                    <input type="file" id="resizeImageFile" accept="image/*" aria-label="Select image file for resizing">
                 </div>
            </div>

            <div class="tool-controls dimension-inputs">
                 <label>New Dimensions:</label>
                 <input type="number" id="resizeWidth" placeholder="Width" min="1">
                 <span>x</span>
                 <input type="number" id="resizeHeight" placeholder="Height" min="1">
                 <button id="applyResizeBtn" class="btn" disabled>Apply Resize</button>
            </div>
            <p id="resizeProcessingMsg" class="processing-message">Processing...</p>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Resizer Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Resizer Top Ad)</p>
            </div>

            <div id="resizeImageInfo" class="image-info">
                <h3>Resizer Info</h3>
                <p><strong>Filename:</strong> <span id="resizeOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalDimensions">-</span></p>
                 <p><strong>New Dimensions:</strong> <span id="newDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="resizeOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="resizedSize">-</span></p>
            </div>

            <div id="resizeImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <!-- Resizer preview will just show one image at a time - the result -->
                 <img id="resizedImage" src="" alt="Resized Image Preview">
            </div>

            <div class="download-section">
                 <p id="resizeDownloadMessage" style="display: none;">Your resized image is ready!</p>
                <a id="resizeDownloadLink" class="btn btn-success" style="display: none;">Download Resized Image</a>
            </div>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Resizer Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Resizer Bottom Ad)</p>
            </div>
        </section>

         <!-- Image Converter Tool Section -->
         <section id="image-converter-section" class="container" data-aos="fade-up">
            <h2>Online Image Converter</h2>
            <p>Convert your images between popular formats like JPG, PNG, and WebP.</p>

            <div class="file-input-container">
                <!-- Drop Zone for Converter -->
                 <div id="convertDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="convertImageFile">Click to Upload Image</label>
                    <input type="file" id="convertImageFile" accept="image/*" aria-label="Select image file for conversion">
                 </div>
            </div>

            <div class="tool-controls convert-controls">
                 <label for="outputFormat">Convert to:</label>
                 <select id="outputFormat">
                     <option value="image/jpeg">JPG</option>
                     <option value="image/png">PNG</option>
                     <option value="image/webp">WebP</option>
                 </select>
                 <button id="applyConvertBtn" class="btn" disabled>Convert Image</button>
            </div>
            <p id="convertProcessingMsg" class="processing-message">Processing...</p>


            <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Converter Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Converter Top Ad)</p>
            </div>

             <div id="convertImageInfo" class="image-info">
                <h3>Conversion Info</h3>
                <p><strong>Filename:</strong> <span id="convertOriginalFileName"></span></p>
                <p><strong>Original Format:</strong> <span id="originalFormat">-</span></p>
                 <p><strong>New Format:</strong> <span id="newFormat">-</span></p>
                <p><strong>Original Size:</strong> <span id="convertOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="convertedSize">-</span></p>
            </div>

            <div id="convertImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <!-- Converter preview will just show one image at a time - the result -->
                <img id="convertedImage" src="" alt="Converted Image Preview">
            </div>

            <div class="download-section">
                 <p id="convertDownloadMessage" style="display: none;">Your converted image is ready!</p>
                <a id="convertDownloadLink" class="btn btn-success" style="display: none;">Download Converted Image</a>
            </div>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Converter Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Converter Bottom Ad)</p>
            </div>
         </section>

        <!-- Image Cropper Tool Section -->
        <section id="image-cropper-section" class="container" data-aos="fade-up">
            <h2>Online Image Cropper</h2>
            <p>Click "Select Area" and then click and drag on the image to select the crop area. Click "Crop" to process.</p>

            <div class="file-input-container">
                 <!-- Drop Zone for Cropper -->
                 <div id="cropDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="cropImageFile">Click to Upload Image</label>
                    <input type="file" id="cropImageFile" accept="image/*" aria-label="Select image file for cropping">
                 </div>
            </div>

            <div class="tool-controls"> <!-- Controls moved -->
                 <button id="selectCropAreaBtn" class="btn" disabled>Select Area</button>
                 <button id="cropAndDownloadBtn" class="btn" disabled>Crop</button> <!-- Renamed button -->
            </div>
             <p id="cropProcessingMsg" class="processing-message">Processing...</p>

            <!-- Preview Section (moved UP) -->
            <div id="cropImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <!-- Container for image and interactive overlay -->
                 <div class="cropper-container">
                     <img id="cropOriginalImagePreview" src="" alt="Image to Crop"> <!-- Image for cropping -->
                     <div class="crop-selection-overlay"></div> <!-- Overlay for selection -->
                 </div>
                 <img id="croppedImage" src="" alt="Cropped Image Preview"> <!-- Cropped result -->

                 <!-- Download section moved INSIDE Preview -->
                 <div class="download-section">
                     <p id="cropDownloadMessage" style="display: none;">Your cropped image is ready!</p>
                    <a id="cropDownloadLink" class="btn btn-success" style="display: none;">Download Cropped Image</a>
                </div>
             </div>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Cropper Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Cropper Top Ad)</p>
            </div>

             <div id="cropImageInfo" class="image-info">
                <h3>Cropper Info</h3>
                <p><strong>Filename:</strong> <span id="cropOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="cropOriginalDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="cropOriginalSize"></span></p>
                 <p><strong>Cropped Dimensions:</strong> <span id="newCropDimensions">-</span></p>
                <p><strong>Cropped Size:</strong> <span id="croppedSize">-</span></p>
            </div>


            <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Cropper Bottom -->
                <p>Advertisement Area (Cropper Bottom Ad)</p>
            </div>
        </section>

        <!-- Image Rotate & Flip Tool Section -->
        <section id="image-rotate-flip-section" class="container" data-aos="fade-up">
            <h2>Online Image Rotate & Flip</h2>
            <p>Rotate your image by 90 degrees or flip it horizontally or vertically.</p>

             <div class="file-input-container">
                 <!-- Drop Zone for Rotate/Flip -->
                 <div id="rotateFlipDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="rotateFlipImageFile">Click to Upload Image</label>
                    <input type="file" id="rotateFlipImageFile" accept="image/*" aria-label="Select image file for rotate/flip">
                 </div>
            </div>

            <div class="tool-controls rotate-flip-controls">
                 <button id="rotateLeftBtn" class="btn" disabled>Rotate Left 90°</button>
                 <button id="rotateRightBtn" class="btn" disabled>Rotate Right 90°</button>
                 <button id="flipHorizontalBtn" class="btn" disabled>Flip Horizontal</button>
                 <button id="flipVerticalBtn" class="btn" disabled>Flip Vertical</button>
            </div>
             <p id="rotateFlipProcessingMsg" class="processing-message">Processing...</p>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Rotate/Flip Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Rotate/Flip Top Ad)</p>
            </div>

             <div id="rotateFlipImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="rotateFlipOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalRotateFlipDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="rotateFlipOriginalSize"></span></p>
                 <p><strong>New Dimensions:</strong> <span id="newRotateFlipDimensions">-</span></p>
                <p><strong>New Size:</strong> <span id="newRotateFlipSize">-</span></p>
            </div>

            <div id="rotateFlipImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <!-- Rotate/Flip preview shows the result -->
                <img id="rotatedFlippedImage" src="" alt="Rotated/Flipped Image Preview">
            </div>

            <div class="download-section">
                 <p id="rotateFlipDownloadMessage" style="display: none;">Your image is ready!</p>
                <a id="rotateFlipDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
            </div>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Rotate/Flip Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Rotate/Flip Bottom Ad)</p>
            </div>
        </section>

        <!-- Image Filters Tool Section -->
         <section id="image-filters-section" class="container" data-aos="fade-up">
            <h2>Online Image Filters</h2>
            <p>Apply filters to your image.</p>

            <div class="file-input-container">
                 <!-- Drop Zone for Filters -->
                 <div id="filterDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p>
                    <p>or</p>
                    <label for="filterImageFile">Click to Upload Image</label>
                    <input type="file" id="filterImageFile" accept="image/*" aria-label="Select image file for filtering">
                 </div>
            </div>

             <div class="tool-controls filter-controls">
                 <label for="filterType">Select Filter:</label>
                 <select id="filterType" disabled>
                     <option value="none">None</option>
                     <option value="grayscale">Grayscale</option>
                     <option value="sepia">Sepia</option>
                     <option value="invert">Invert</option>
                     <option value="red">Red Channel</option>
                     <option value="green">Green Channel</option>
                     <option value="blue">Blue Channel</option>
                      <!-- Add more filter options here -->
                 </select>
                 <button id="applyFilterBtn" class="btn" disabled>Apply Filter</button>
             </div>
             <p id="filterProcessingMsg" class="processing-message">Processing...</p>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Filters Top -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Filters Top Ad)</p>
            </div>

             <div id="filterImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="filterOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalFilterDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="filterOriginalSize"></span></p>
                 <p><strong>New Size:</strong> <span id="newFilterSize">-</span></p>
            </div>

            <div id="filterImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <!-- Filter preview shows the result -->
                <img id="filteredImage" src="" alt="Filtered Image Preview">
                 <!-- Download section moved INSIDE Preview -->
                 <div class="download-section">
                     <p id="filterDownloadMessage" style="display: none;">Your filtered image is ready!</p>
                    <a id="filterDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
                </div>
            </div>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Filters Bottom -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Filters Bottom Ad)</p>
            </div>
         </section>


         <!-- About Section -->
        <section id="about-section" class="container" data-aos="fade-up">
            <h2>About Us</h2>
            <p>Welcome to FreeImagePDFTools, your one-stop destination for free and easy-to-use online image and PDF tools. Our mission is to provide simple, fast, and effective tools to help you manage your digital files without needing to download complex software.</p>
            <p>We are constantly working on adding new tools and improving the existing ones based on your feedback. Whether you need to compress images for your website, resize a photo for social media, convert formats (JPG, PNG, WebP), crop, rotate, flip, apply filters, or perform operations on PDF documents, we aim to make it as straightforward as possible.</p>
            <p>Thank you for using our tools!</p>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - About Page -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (About Page Ad)</p>
            </div>
        </section>

         <!-- Contact Section -->
        <section id="contact-section" class="container" data-aos="fade-up">
            <h2>Contact Us</h2>
            <p>Have questions, feedback, or suggestions for new tools? We'd love to hear from you!</p>
            <!--
                IMPORTANT: To make this form send emails, you need a backend script or a
                third-party service (like Formspree, Getform, etc.).
                1. Sign up for a service.
                2. Get your unique form endpoint URL.
                3. Replace the 'action="#"' below with your endpoint URL.
                4. The method="POST" is already correct.
                5. Remove or comment out the JavaScript listener for contactForm below.
            -->
            <form id="contactForm" action="#" method="POST"> <!-- Replace action="#" with your form endpoint -->
                <div>
                    <label for="name">Name:</label>
                    <input type="text" id="name" name="name" required>
                </div>
                <div>
                    <label for="email">Email:</label>
                    <input type="email" id="email" name="email" required>
                </div>
                <div>
                    <label for="message">Message:</label>
                    <textarea id="message" name="message" required></textarea>
                </div>
                <button type="submit" class="btn">Send Message</button>
            </form>
             <!-- Remove this paragraph once the form is functional -->
             <p style="text-align: center; margin-top: 1rem; font-size: 0.9rem;">(Note: This form is a placeholder and requires server-side integration to send emails.)</p>


             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Contact Page -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Contact Page Ad)</p>
            </div>
        </section>

         <!-- Privacy Policy Section -->
        <section id="privacy-section" class="container" data-aos="fade-up">
            <h2>Privacy Policy</h2>
            <p>Your privacy is important to us. This policy explains how we handle information on our website.</p>
            <h3>What information do we collect?</h3>
            <p>We do not collect any personally identifiable information from you unless you voluntarily provide it (e.g., via the contact form). Our tools process files entirely in your browser; your files are not uploaded to our servers.</p>
            <h3>How do we use your information?</h3>
            <p>Any information you provide via the contact form is used solely to respond to your inquiry. We do not share, sell, or rent your personal information to third parties.</p>
             <h3>Cookies and Tracking</h3>
            <p>We may use standard website tracking technologies (like Google Analytics - if implemented) to understand how the site is used in aggregate, which helps us improve our services. These tools typically collect non-personally identifiable information such as browser type, pages visited, and time spent on the site.</p>
             <p>Advertisement partners (like Google AdSense) may use cookies to serve ads based on your visit to this and other sites. You can opt out of personalized advertising by visiting Ads Settings.</p>
            <h3>Third-Party Links</h3>
            <p>This website may contain links to other sites. We are not responsible for the privacy practices or the content of such other sites.</p>
            <h3>Your Consent</h3>
            <p>By using our site, you consent to our privacy policy.</p>
            <h3>Changes to our Privacy Policy</h3>
            <p>If we decide to change our privacy policy, we will post those changes on this page.</p>
            <p>This policy was last updated on [Date - e.g., May 5, 2023].</p>

             <div class="ad-container">
                <!-- Google AdSense Ad Unit Code - Privacy Page -->
                 <!-- REPLACE THIS COMMENT WITH YOUR ACTUAL GOOGLE ADSENSE AD CODE -->
                <p>Advertisement Area (Privacy Page Ad)</p>
            </div>
        </section>

    </main> <!-- End main content wrapper -->


    <footer>
        <div class="container"> <!-- Added container to footer -->
            <p>&copy; 2023 FreeImagePDFTools. All rights reserved.</p>
            <p>
                <a href="#privacy-section">Privacy Policy</a>
                &nbsp;|&nbsp; <!-- Use &nbsp; for space around separator -->
                <a href="#contact-section">Contact Us</a>
                &nbsp;|&nbsp;
                 <a href="#about-section">About</a>
            </p>
             <!-- Optional: Add footer ad here -->
        </div>
    </footer>

    <!-- AOS (Animate On Scroll) JS -->
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script>
        // Initialize AOS
        // Settings like `once: true` mean the animation only happens once on scroll down
        // You can customize these: https://github.com/michalsnik/aos
        AOS.init({
            duration: 800, // values from 0 to 3000, with step 50ms
            easing: 'ease-in-out', // default easing
            once: true, // whether animation should happen only once - while scrolling down
            mirror: false, // whether elements should animate out while scrolling past them
        });


        // --- Helper function to format file size ---
        function formatBytes(bytes, decimals = 2) {
            if (!bytes || bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            // Handle case where log(bytes) is negative or zero (bytes < 1)
            const i = bytes < 1 ? 0 : Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // --- Global Image Objects ---
        // These need to persist state while a tool section is active.
        // Declaring them with let/var at the top level makes them global.
        let originalCompressImage = new Image();
        let originalResizeImage = new Image();
        let originalConvertImage = new Image();
        let originalCropImage = new Image();
        let originalRotateFlipImage = new Image();
        let currentRotateFlipImage = new Image(); // For keeping state after transforms
        let originalFilterImage = new Image(); // Store the initially loaded image


        // --- Global File variables ---
        // Declaring explicitly on window to ensure consistent access via window[varName]
        window.originalCompressFile = null;
        window.originalResizeFile = null;
        window.originalConvertFile = null;
        window.originalCropFile = null;
        window.originalRotateFlipFile = null;
        window.originalFilterFile = null;


        // --- Global Cropper specific state ---
        // This also needs to persist outside the individual event handlers
        window.finalScaledCrop = null;


         // --- Prevent default behavior for drag events on the whole document ---
         // This stops the browser from opening dragged files directly.
         function preventDefaults(e) {
             e.preventDefault();
             e.stopPropagation();
         }

         // Add these global listeners once outside DOMContentLoaded
         document.addEventListener('dragover', preventDefaults, false);
         document.addEventListener('drop', preventDefaults, false);
         console.log("[GLOBAL] Added global dragover/drop preventDefault listeners.");


        // --- Main DOMContentLoaded Block ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[GLOBAL] DOM fully loaded. Initializing...");

            // --- SPA Navigation Logic ---
            const sections = document.querySelectorAll('main > section');
            const navLinks = document.querySelectorAll('header nav a, #homepage-section a.tool-link, #homepage-section .tool-card h3 a, footer a[href^="#"]'); // Added .tool-card h3 a

            function showSection(id) {
                console.log(`[NAV] Attempting to show section: ${id}`);
                sections.forEach(section => {
                    section.style.display = 'none';
                });
                const targetSection = document.getElementById(id);
                if (targetSection) {
                    targetSection.style.display = 'block';
                    document.querySelectorAll('header nav a').forEach(link => {
                         link.classList.remove('active');
                         if (link.getAttribute('href') === '#' + id) {
                             link.classList.add('active');
                         }
                     });
                     requestAnimationFrame(() => {
                         const headerHeight = document.querySelector('header')?.offsetHeight || 60;
                         const targetScrollTop = id === 'homepage-section' ? 0 : Math.max(0, targetSection.offsetTop - headerHeight);
                         window.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
                     });
                    console.log(`[NAV] Section shown: ${id}`);
                } else {
                    console.warn(`[NAV] Section with ID "${id}" not found. Showing homepage.`);
                    showSection('homepage-section');
                }
            }

            function getVisibleSectionId() {
                 for (let section of sections) {
                     const style = window.getComputedStyle(section);
                     if (style.display === 'block' && section.offsetParent !== null) {
                         return section.id;
                     }
                 }
                 const homepage = document.getElementById('homepage-section');
                 if(homepage && window.getComputedStyle(homepage).display === 'block') {
                    return 'homepage-section';
                 }
                 return null;
            }

            function handleNavigation() {
                console.log("[NAV] Handling navigation. Current hash:", window.location.hash);
                const currentHash = window.location.hash;
                const targetId = currentHash ? currentHash.substring(1) : 'homepage-section';
                showSection(targetId);
            }

            // --- General Tool Reset Function (moved inside DOMContentLoaded) ---
             function resetToolState(toolId) {
                 console.log(`[RESET] Attempting to reset tool: ${toolId}`);
                 const section = document.getElementById(toolId + '-section');
                 if (!section) { console.warn(`[RESET] Failed: Section for tool "${toolId}" not found.`); return; }

                 try {
                     // General cleanup for image elements within the section's preview
                     const previewSection = section.querySelector('.image-preview');
                      const imagesToClean = previewSection ? previewSection.querySelectorAll('img') : [];
                      imagesToClean.forEach(img => {
                          if (img.src && img.src.startsWith('blob:')) {
                              console.log(`[RESET:${toolId}] Revoking Blob URL: ${img.src}`);
                              try { URL.revokeObjectURL(img.src); } catch (e) { console.error(`[RESET:${toolId}] Error revoking Blob URL ${img.src}:`, e); }
                          }
                          img.src = '';
                          img.style.display = 'none';
                          img.alt = '';
                      });
                      if (previewSection) previewSection.style.display = 'none';

                      // General cleanup for download links within the section's download section
                      const downloadSection = section.querySelector('.download-section');
                      const downloadLink = downloadSection ? downloadSection.querySelector('a.btn') : null;
                      if (downloadLink) {
                          if (downloadLink.href && downloadLink.href.startsWith('blob:')) {
                               console.log(`[RESET:${toolId}] Revoking Blob URL from download link: ${downloadLink.href}`);
                              try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[RESET:${toolId}] Error revoking Blob URL ${downloadLink.href}:`, e); }
                          }
                          downloadLink.href = '#';
                          downloadLink.style.display = 'none';
                          downloadLink.removeAttribute('download');
                      }
                      if (downloadSection) {
                          const downloadMessage = downloadSection.querySelector('p');
                          if(downloadMessage) downloadMessage.style.display = 'none';
                      }


                     const infoDiv = section.querySelector('.image-info'); if (infoDiv) infoDiv.style.display = 'none';
                     const processingMsg = section.querySelector('.processing-message');
                     if (processingMsg) processingMsg.style.display = 'none';

                     // Tool-specific resets
                     switch(toolId) {
                        case 'image-compressor':
                             const csSpan = section.querySelector('#compressedSize'); if(csSpan) csSpan.textContent = '-';
                             const srSpan = section.querySelector('#sizeReduction'); if(srSpan) srSpan.textContent = '-';
                             const qs = section.querySelector('#compressionQuality'); if(qs) qs.value = 80;
                             const qvSpan = section.querySelector('#qualityValue'); if(qvSpan) qvSpan.textContent = '80%';
                             const cnb = section.querySelector('#compressNowBtn'); if(cnb) cnb.disabled = true;
                             const cofnSpan = section.querySelector('#compressOriginalFileName'); if(cofnSpan) cofnSpan.textContent = '';
                             const cosSpan = section.querySelector('#compressOriginalSize'); if(cosSpan) cosSpan.textContent = '';
                             // Explicitly revoke original image object's src if it's a blob
                             if (originalCompressImage.src && originalCompressImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalCompressImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalCompressImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalCompressImage.src}:`, e); } } originalCompressImage.src = ''; originalCompressImage.onload = null; originalCompressImage.onerror = null; // Clear image object src and handlers
                             window.originalCompressFile = null; // Reset global file variable
                             break;
                        case 'image-resizer':
                             const odSpan = section.querySelector('#originalDimensions'); if(odSpan) odSpan.textContent = '-';
                             const ndSpan = section.querySelector('#newDimensions'); if(ndSpan) ndSpan.textContent = '-';
                             const rzSizeSpan = section.querySelector('#resizedSize'); if(rzSizeSpan) rzSizeSpan.textContent = '-';
                             const wi = section.querySelector('#resizeWidth'); if(wi) wi.value = '';
                             const hi = section.querySelector('#resizeHeight'); if(hi) hi.value = '';
                             const arb = section.querySelector('#applyResizeBtn'); if(arb) arb.disabled = true;
                             const rzosSpan = section.querySelector('#resizeOriginalSize'); if(rzosSpan) rzosSpan.textContent = '';
                             const rzofnSpan = section.querySelector('#resizeOriginalFileName'); if(rzofnSpan) rzofnSpan.textContent = '';
                              if (originalResizeImage.src && originalResizeImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalResizeImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalResizeImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalResizeImage.src}:`, e); } } originalResizeImage.src = ''; originalResizeImage.onload = null; originalResizeImage.onerror = null;
                             window.originalResizeFile = null; // Reset global file variable
                             break;
                        case 'image-converter':
                             const ofSpan = section.querySelector('#originalFormat'); if(ofSpan) ofSpan.textContent = '-';
                             const nfSpan = section.querySelector('#newFormat'); if(nfSpan) nfSpan.textContent = '-';
                             const cvSizeSpan = section.querySelector('#convertedSize'); if(cvSizeSpan) cvSizeSpan.textContent = '-';
                             const fos = section.querySelector('#outputFormat'); if(fos) fos.value = 'image/jpeg';
                             const acb = section.querySelector('#applyConvertBtn'); if(acb) acb.disabled = true;
                             const cvosSpan = section.querySelector('#convertOriginalSize'); if(cvosSpan) cvosSpan.textContent = '';
                             const cvofnSpan = section.querySelector('#convertOriginalFileName'); if(cvofnSpan) cvofnSpan.textContent = '';
                              if (originalConvertImage.src && originalConvertImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalConvertImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalConvertImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalConvertImage.src}:`, e); } } originalConvertImage.src = ''; originalConvertImage.onload = null; originalConvertImage.onerror = null;
                             window.originalConvertFile = null; // Reset global file variable
                             break;
                        case 'image-cropper':
                             const coDimSpan = section.querySelector('#cropOriginalDimensions'); if(coDimSpan) coDimSpan.textContent = '-';
                             const coszSpan = section.querySelector('#cropOriginalSize'); if(coszSpan) coszSpan.textContent = '-';
                             const ncDimSpan = section.querySelector('#newCropDimensions'); if(ncDimSpan) ncDimSpan.textContent = '-';
                             const crszSpan = section.querySelector('#croppedSize'); if(crszSpan) crszSpan.textContent = '-';
                             const cadb = section.querySelector('#cropAndDownloadBtn'); if(cadb) cadb.disabled = true;
                             const sab = section.querySelector('#selectCropAreaBtn'); if(sab) sab.disabled = true;
                             const crofnSpan = section.querySelector('#cropOriginalFileName'); if(crofnSpan) crofnSpan.textContent = '';
                             window.finalScaledCrop = null; // Reset global cropper selection data
                             const co = section.querySelector('.crop-selection-overlay');
                             if (co) co.style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                             const cc = section.querySelector('.cropper-container');
                             if(cc) cc.style.cursor = 'default';
                              if (originalCropImage.src && originalCropImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalCropImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalCropImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalCropImage.src}:`, e); } } originalCropImage.src = ''; originalCropImage.onload = null; originalCropImage.onerror = null;
                             window.originalCropFile = null; // Reset global file variable
                             break;
                        case 'image-rotate-flip':
                             const orfDimSpan = section.querySelector('#originalRotateFlipDimensions'); if(orfDimSpan) orfDimSpan.textContent = '-';
                             const orfSizeSpan = section.querySelector('#rotateFlipOriginalSize'); if(orfSizeSpan) orfSizeSpan.textContent = '-';
                             const nrfDimSpan = section.querySelector('#newRotateFlipDimensions'); if(nrfDimSpan) nrfDimSpan.textContent = '-';
                             const nrfSizeSpan = section.querySelector('#newRotateFlipSize'); if(nrfSizeSpan) nrfSizeSpan.textContent = '-';
                             section.querySelectorAll('.rotate-flip-controls button').forEach(btn => btn.disabled = true);
                             const orffnSpan = section.querySelector('#rotateFlipOriginalFileName'); if(orffnSpan) orffnSpan.textContent = '';
                             // Explicitly revoke original/current image object's src if it's a blob
                             if (originalRotateFlipImage.src && originalRotateFlipImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalRotateFlipImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalRotateFlipImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalRotateFlipImage.src}:`, e); } } originalRotateFlipImage.src = ''; originalRotateFlipImage.onload = null; originalRotateFlipImage.onerror = null;
                             if (currentRotateFlipImage.src && currentRotateFlipImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(currentRotateFlipImage.src); console.log(`[RESET:${toolId}] Revoked current image blob: ${currentRotateFlipImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking current image blob ${currentRotateFlipImage.src}:`, e); } } currentRotateFlipImage.src = ''; currentRotateFlipImage.onload = null; currentRotateFlipImage.onerror = null;
                             window.originalRotateFlipFile = null; // Reset global file variable
                             break;
                        case 'image-filters':
                             const ofDimSpan = section.querySelector('#originalFilterDimensions'); if(ofDimSpan) ofDimSpan.textContent = '-';
                             const ofszSpan = section.querySelector('#filterOriginalSize'); if(ofszSpan) ofszSpan.textContent = '-';
                             const nfSizeSpan = section.querySelector('#newFilterSize'); if(nfSizeSpan) nfSizeSpan.textContent = '-';
                             const fis = section.querySelector('#filterType');
                             if(fis) { fis.value = 'none'; fis.disabled = true; }
                             const afb = section.querySelector('#applyFilterBtn'); if(afb) afb.disabled = true;
                             const offnSpan = section.querySelector('#filterOriginalFileName'); if(offnSpan) offnSpan.textContent = '';
                             // Note: filteredImage img src is cleared by the general loop above.
                             // originalFilterImage src needs explicit revocation if it's a blob URL
                             if (originalFilterImage.src && originalFilterImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(originalFilterImage.src); console.log(`[RESET:${toolId}] Revoked original image blob: ${originalFilterImage.src}`); } catch (e) { console.error(`[RESET:${toolId}] Error revoking original image blob ${originalFilterImage.src}:`, e); } } originalFilterImage.src = ''; originalFilterImage.onload = null; originalFilterImage.onerror = null;
                             // No need for currentFilterImage cleanup as it was removed for this tool
                             window.originalFilterFile = null; // Reset global file variable
                             break;
                     }
                     const fileInput = section.querySelector('input[type="file"]');
                     if (fileInput) fileInput.value = '';
                     console.log(`[RESET] Finished resetting tool: ${toolId}`);

                 } catch (error) {
                     console.error(`[RESET] FATAL ERROR during reset of tool ${toolId}:`, error);
                     alert(`An unexpected error occurred while resetting the previous tool (${toolId}). Please try refreshing the page.`);
                 }
             }


            // --- Add drop zone and file input listeners for a given tool ---
            // --- Pass explicit element IDs ---
            function addDropZoneListeners(toolId, dropZoneId, fileInputId) {
                 console.log(`[LISTENERS] Setting up drop zone listeners for: ${toolId} (IDs: ${dropZoneId}, ${fileInputId})`);
                 const dropZone = document.getElementById(dropZoneId);
                 const fileInput = document.getElementById(fileInputId);

                 if (!dropZone || !fileInput) {
                     console.error(`[LISTENERS] REQUIRED elements not found for tool: ${toolId}. Drop zone ID: ${dropZoneId}, File input ID: ${fileInputId}. Cannot add listeners.`);
                     return;
                 }

                 ['dragenter', 'dragover'].forEach(eventName => {
                     dropZone.addEventListener(eventName, (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         dropZone.classList.add('drag-over');
                         console.log(`[LISTENERS:${toolId}] Drag event: ${eventName}`);
                     }, false);
                 });

                 ['dragleave', 'drop'].forEach(eventName => {
                     dropZone.addEventListener(eventName, (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         dropZone.classList.remove('drag-over');
                         console.log(`[LISTENERS:${toolId}] Drag event: ${eventName}`);
                     }, false);
                 });

                 dropZone.addEventListener('drop', (e) => {
                     e.preventDefault();
                     e.stopPropagation();
                     console.log(`[LISTENERS:${toolId}] Drop event fired.`);
                     const dt = e.dataTransfer;
                     const files = dt.files;

                     if (files.length > 0) {
                          const file = files[0];
                          console.log(`[LISTENERS:${toolId}] Dropped files found. First file: ${file.name} (${file.type})`);
                          if (file.type.startsWith('image/')) {
                               handleImageFile(file, toolId);
                          } else {
                               console.warn(`[LISTENERS:${toolId}] Non-image file dropped: ${file.name} (${file.type})`);
                               alert(`Please drop a valid image file (like JPG, PNG, WebP) for ${toolId.replace('image-', '').replace('-', ' ').toUpperCase()}.`);
                               resetToolState(toolId);
                          }
                     } else {
                          console.log(`[LISTENERS:${toolId}] Drop event occurred but no files found in dataTransfer.`);
                          alert(`No image file found in the drop data for ${toolId.replace('image-', '').replace('-', ' ').toUpperCase()}.`);
                          resetToolState(toolId);
                     }
                 }, false);

                 fileInput.addEventListener('change', (event) => {
                     console.log(`[LISTENERS:${toolId}] File input change event fired.`);
                     const files = event.target.files;
                     if (files.length > 0) {
                          const file = files[0];
                           console.log(`[LISTENERS:${toolId}] Files selected via input. First file: ${file.name} (${file.type})`);
                           if (file.type.startsWith('image/')) {
                               handleImageFile(file, toolId);
                           } else {
                               console.warn(`[LISTENERS:${toolId}] Non-image file selected via input: ${file.name} (${file.type})`);
                               alert(`Please select a valid image file (like JPG, PNG, WebP) for ${toolId.replace('image-', '').replace('-', ' ').toUpperCase()}.`);
                               resetToolState(toolId);
                           }
                     } else {
                          console.log(`[LISTENERS:${toolId}] File input cleared or no file selected.`);
                          resetToolState(toolId);
                     }
                 });

                 console.log(`[LISTENERS] Drop zone listeners attached for: ${toolId}`);
            }


            // *** CORE FILE HANDLING LOGIC (moved inside DOMContentLoaded) ***
            function handleImageFile(file, toolId) {
                console.log(`[HANDLE_FILE] handleImageFile called for tool: ${toolId}, file: ${file.name}`);

                if (!file || !file.type.startsWith('image/')) {
                     console.error("[HANDLE_FILE] Invalid file type passed.");
                     alert("Internal error: Invalid file type.");
                     resetToolState(toolId);
                     return;
                }

                 console.log(`[HANDLE_FILE] Calling resetToolState(${toolId})`);
                 resetToolState(toolId); // Reset the state of the current tool

                let objectUrl = null;
                try {
                    objectUrl = URL.createObjectURL(file);
                    console.log(`[HANDLE_FILE] Created object URL: ${objectUrl}`);
                } catch (e) {
                    console.error("[HANDLE_FILE] Error creating object URL:", e);
                    alert(`Error preparing file ${file.name}. It might be too large or corrupted.`);
                    resetToolState(toolId);
                    return;
                }


                let originalImageObj;
                let originalFileVarName; // String name to access window property
                let toolSpecificLoadHandler;

                switch (toolId) {
                    case 'image-compressor':
                        originalImageObj = originalCompressImage;
                        originalFileVarName = 'originalCompressFile';
                        toolSpecificLoadHandler = setupCompressUI;
                        break;
                    case 'image-resizer':
                        originalImageObj = originalResizeImage;
                        originalFileVarName = 'originalResizeFile';
                        toolSpecificLoadHandler = setupResizeUI;
                        break;
                    case 'image-converter':
                        originalImageObj = originalConvertImage;
                        originalFileVarName = 'originalConvertFile';
                        toolSpecificLoadHandler = setupConvertUI;
                        break;
                    case 'image-cropper':
                        originalImageObj = originalCropImage;
                        originalFileVarName = 'originalCropFile';
                        toolSpecificLoadHandler = setupCropUI;
                        break;
                    case 'image-rotate-flip':
                        originalImageObj = originalRotateFlipImage;
                        originalFileVarName = 'originalRotateFlipFile';
                        toolSpecificLoadHandler = setupRotateFlipUI;
                        break;
                    case 'image-filters':
                        originalImageObj = originalFilterImage;
                        originalFileVarName = 'originalFilterFile';
                        toolSpecificLoadHandler = setupFilterUI;
                        break;
                    default:
                        console.error(`[HANDLE_FILE] Unknown toolId: ${toolId}`);
                        if (objectUrl) { try { URL.revokeObjectURL(objectUrl); } catch (e) { console.error(`[HANDLE_FILE] Error revoking object URL ${objectUrl}:`, e); } }
                        alert("Internal error: Unknown tool.");
                        return;
                }

                // --- Store the file object in the global window property ---
                window[originalFileVarName] = file;
                console.log(`[HANDLE_FILE] Stored file in window['${originalFileVarName}']`);


                originalImageObj.onload = () => {
                    console.log(`[HANDLE_FILE:ONLOAD] Image loaded into ${originalFileVarName}. naturalWidth: ${originalImageObj.naturalWidth}, naturalHeight: ${originalImageObj.naturalHeight}, complete: ${originalImageObj.complete}`);
                    originalImageObj.onerror = null; // Clear onerror handler after successful load

                    if (originalImageObj.naturalWidth > 0 && originalImageObj.naturalHeight > 0) {
                        console.log(`[HANDLE_FILE:ONLOAD] Image successfully loaded data for ${toolId}. Calling setup UI.`);
                        if (toolSpecificLoadHandler && typeof toolSpecificLoadHandler === 'function') {
                           try {
                              toolSpecificLoadHandler(file, originalImageObj.src); // Pass file and the newly loaded image's src
                           } catch (setupError) {
                              console.error(`[HANDLE_FILE:ONLOAD] Error during tool setup (${toolId}):`, setupError);
                              alert(`An error occurred setting up the tool for ${file.name}. Please try a different file or refresh the page.`);
                              // Revoke the objectUrl if setup fails after load
                               if (objectUrl) { try { URL.revokeObjectURL(objectUrl); } catch (e) { console.error(`[HANDLE_FILE:ONLOAD] Error revoking object URL ${objectUrl} after setup fail:`, e); } }
                              resetToolState(toolId);
                           }
                        } else {
                           console.error(`[HANDLE_FILE:ONLOAD] No valid tool specific load handler found for ${toolId}.`);
                           alert(`Internal error setting up tool: ${toolId}`);
                           // Revoke the objectUrl if no setup handler
                            if (objectUrl) { try { URL.revokeObjectURL(objectUrl); } catch (e) { console.error(`[HANDLE_FILE:ONLOAD] Error revoking object URL ${objectUrl} after missing handler:`, e); } }
                           resetToolState(toolId);
                        }
                    } else {
                         console.error(`[HANDLE_FILE:ONLOAD] Image loaded but dimensions are 0 for ${toolId}: ${file.name}`);
                         alert(`Could not load image data from ${file.name}. It might be corrupted or an unsupported format (dimensions are zero).`);
                         // Revoke the objectUrl here as onload succeeded but dimensions are bad
                         if (objectUrl) { try { URL.revokeObjectURL(objectUrl); } catch (e) { console.error(`[HANDLE_FILE:ONLOAD] Error revoking object URL ${objectUrl} after zero dimensions:`, e); } }
                         resetToolState(toolId);
                    }
                };

                originalImageObj.onerror = (e) => {
                    console.error(`[HANDLE_FILE:ONERROR] Error loading image into ${originalFileVarName} from ${objectUrl}:`, e);
                    originalImageObj.onload = null; // Clear onload handler after error
                    alert(`Error loading image file ${file.name}. It might be corrupted or an unsupported format.`);
                    // Revoke the objectUrl here as onerror happened
                    if (objectUrl) { try { URL.revokeObjectURL(objectUrl); } catch (e) { console.error(`[HANDLE_FILE:ONERROR] Error revoking object URL ${objectUrl} after load error:`, e); } }
                    resetToolState(toolId);
                };

                // Set the src. This triggers the load or error process.
                // The blob URL for the original image is now held by originalImageObj.src AFTER it loads.
                // Setting it here makes the Image object start loading the data from the blob URL.
                console.log(`[HANDLE_FILE] Setting src for ${originalFileVarName}: ${objectUrl}. Waiting for onload/onerror...`);
                originalImageObj.src = objectUrl;
            }


            // --- Tool-Specific UI Setup Functions (moved inside DOMContentLoaded) ---
            // These functions are called *after* the image file has successfully loaded into the corresponding originalImageObj
            function setupCompressUI(file, imgUrl) {
                 console.log("[SETUP:COMPRESSOR] started.");
                 const imageInfoDiv = document.getElementById('compressImageInfo');
                 const originalFileNameSpan = document.getElementById('compressOriginalFileName');
                 const originalSizeSpan = document.getElementById('compressOriginalSize');
                 const compressedSizeSpan = document.getElementById('compressedSize');
                 const sizeReductionSpan = document.getElementById('sizeReduction');
                 const previewSection = document.getElementById('compressImagePreview');
                 const originalImagePreview = document.getElementById('originalImagePreview');
                 const compressedImagePreview = document.getElementById('compressedImagePreview');
                 const compressNowBtn = document.getElementById('compressNowBtn');
                 const qualitySlider = document.getElementById('compressionQuality');
                 const qualityValueSpan = document.getElementById('qualityValue');

                 if (!imageInfoDiv || !originalFileNameSpan || !originalSizeSpan || !compressedSizeSpan || !sizeReductionSpan || !previewSection || !originalImagePreview || !compressedImagePreview || !compressNowBtn || !qualitySlider || !qualityValueSpan) { console.error("[SETUP:COMPRESSOR] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }

                 originalFileNameSpan.textContent = file.name;
                 originalSizeSpan.textContent = formatBytes(file.size);
                 compressedSizeSpan.textContent = '-'; sizeReductionSpan.textContent = '-';
                 imageInfoDiv.style.display = 'block'; console.log("[SETUP:COMPRESSOR] Info updated.");

                 // originalImagePreview should show the source from the originalImageObj
                 // Its blob URL is managed by handleImageFile and resetToolState
                 originalImagePreview.src = originalCompressImage.src;
                 originalImagePreview.alt = `Original Image (${file.name})`;
                 originalImagePreview.style.display = 'block'; console.log("[SETUP:COMPRESSOR] Original preview image set and displayed.");

                 // compressedImagePreview should be cleared initially
                 // Revoke old blob URL before clearing
                 if (compressedImagePreview.src && compressedImagePreview.src.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) { console.error(`[SETUP:COMPRESSOR] Error revoking old compressed preview blob ${compressedImagePreview.src}:`, e); } }
                 compressedImagePreview.src = ''; compressedImagePreview.alt = ''; compressedImagePreview.style.display = 'none'; console.log("[SETUP:COMPRESSOR] Compressed preview image cleared and hidden.");

                 previewSection.style.display = 'block'; console.log("[SETUP:COMPRESSOR] Preview section displayed.");

                 // Download link cleared by general reset logic

                 compressNowBtn.disabled = false; console.log("[SETUP:COMPRESSOR] Compress button enabled.");
                 qualityValueSpan.textContent = qualitySlider.value + '%';

                 console.log("[SETUP:COMPRESSOR] complete.");
             }

            function setupResizeUI(file, imgUrl) {
                 console.log("[SETUP:RESIZER] started.");
                 const imageInfoDiv = document.getElementById('resizeImageInfo');
                 const originalFileNameSpan = document.getElementById('resizeOriginalFileName');
                 const originalDimensionsSpan = document.getElementById('originalDimensions');
                 const newDimensionsSpan = document.getElementById('newDimensions');
                 const originalSizeSpan = document.getElementById('resizeOriginalSize');
                 const resizedSizeSpan = document.getElementById('resizedSize');
                 const previewSection = document.getElementById('resizeImagePreview');
                 const resizedImage = document.getElementById('resizedImage');
                 const widthInput = document.getElementById('resizeWidth');
                 const heightInput = document.getElementById('resizeHeight');
                 const applyBtn = document.getElementById('applyResizeBtn');


                 if (!imageInfoDiv || !originalFileNameSpan || !originalDimensionsSpan || !originalSizeSpan || !newDimensionsSpan || !resizedSizeSpan || !previewSection || !resizedImage || !widthInput || !heightInput || !applyBtn) { console.error("[SETUP:RESIZER] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }
                 if (!originalResizeImage || !(originalResizeImage.naturalWidth > 0) || !(originalResizeImage.naturalHeight > 0)) { console.error("[SETUP:RESIZER] originalResizeImage not ready."); alert("Error loading image dimensions."); return; }
                 const originalResizeWidth = originalResizeImage.naturalWidth; const originalResizeHeight = originalResizeImage.naturalHeight; console.log(`[SETUP:RESIZER] Original dimensions ${originalResizeWidth}x${originalResizeHeight}.`);

                 originalFileNameSpan.textContent = file.name; originalDimensionsSpan.textContent = `${originalResizeWidth}x${originalResizeHeight}`; originalSizeSpan.textContent = formatBytes(file.size); newDimensionsSpan.textContent = '-'; resizedSizeSpan.textContent = '-'; imageInfoDiv.style.display = 'block'; console.log("[SETUP:RESIZER] Info updated.");

                 // resizedImage should be cleared initially
                 // Revoke old blob URL before clearing
                 if (resizedImage.src && resizedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImage.src); } catch (e) { console.error(`[SETUP:RESIZER] Error revoking old resized preview blob ${resizedImage.src}:`, e); } }
                 resizedImage.src = ''; resizedImage.alt = ''; resizedImage.style.display = 'none'; console.log("[SETUP:RESIZER] Preview image cleared and hidden.");

                 const previewSectionEl = document.getElementById('resizeImagePreview'); if(previewSectionEl) { previewSectionEl.style.display = 'none'; console.log("[SETUP:RESIZER] Preview section hidden."); } else console.warn("[SETUP:RESIZER] resizeImagePreview section not found.");
                 widthInput.value = originalResizeWidth; widthInput.min = 1; heightInput.value = originalResizeHeight; heightInput.min = 1; console.log(`[SETUP:RESIZER] Dimension inputs pre-filled with ${widthInput.value}x${heightInput.value}.`);

                 // Download link cleared by general reset logic

                 const w = parseInt(widthInput.value); const h = parseInt(heightInput.value); applyBtn.disabled = !(!isNaN(w) && w > 0 && !isNaN(h) && h > 0); console.log(`[SETUP:RESIZER] Apply button enabled status: ${!applyBtn.disabled}`);
                 console.log("[SETUP:RESIZER] complete.");
             }

            function setupConvertUI(file, imgUrl) {
                 console.log("[SETUP:CONVERTER] started.");
                 const imageInfoDiv = document.getElementById('convertImageInfo');
                 const originalFileNameSpan = document.getElementById('convertOriginalFileName');
                 const originalFormatSpan = document.getElementById('originalFormat');
                 const newFormatSpan = document.getElementById('newFormat');
                 const originalSizeSpan = document.getElementById('convertOriginalSize');
                 const convertedSizeSpan = document.getElementById('convertedSize');
                 const previewSection = document.getElementById('convertImagePreview');
                 const convertedImage = document.getElementById('convertedImage');
                 const formatSelect = document.getElementById('outputFormat');
                 const applyBtn = document.getElementById('applyConvertBtn');


                 if (!imageInfoDiv || !originalFileNameSpan || !originalFormatSpan || !originalSizeSpan || !newFormatSpan || !convertedSizeSpan || !previewSection || !convertedImage || !formatSelect || !applyBtn) { console.error("[SETUP:CONVERTER] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }

                 originalFileNameSpan.textContent = file.name; originalFormatSpan.textContent = file.type.split('/')[1]?.toUpperCase() || 'Unknown'; originalSizeSpan.textContent = formatBytes(file.size); newFormatSpan.textContent = '-'; convertedSizeSpan.textContent = '-'; imageInfoDiv.style.display = 'block'; console.log("[SETUP:CONVERTER] Info updated.");

                 // convertedImage should be cleared initially
                 // Revoke old blob URL before clearing
                 if (convertedImage.src && convertedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(convertedImage.src); } catch (e) { console.error(`[SETUP:CONVERTER] Error revoking old converted preview blob ${convertedImage.src}:`, e); } }
                 convertedImage.src = ''; convertedImage.alt = ''; convertedImage.style.display = 'none'; console.log("[SETUP:CONVERTER] Preview image cleared and hidden.");

                 const previewSectionEl = document.getElementById('convertImagePreview'); if(previewSectionEl) { previewSectionEl.style.display = 'none'; console.log("[SETUP:CONVERTER] Preview section hidden."); } else console.warn("[SETUP:CONVERTER] convertImagePreview section not found.");
                 formatSelect.value = 'image/jpeg'; console.log("[SETUP:CONVERTER] Format select reset to JPG.");

                 // Download link cleared by general reset logic

                 applyBtn.disabled = false; console.log("[SETUP:CONVERTER] Convert button enabled.");
                 console.log("[SETUP:CONVERTER] complete.");
             }

            function setupCropUI(file, imgUrl) {
                 console.log("[SETUP:CROPPER] started.");
                 const imageInfoDiv = document.getElementById('cropImageInfo'); const originalFileNameSpan = document.getElementById('cropOriginalFileName'); const originalDimensionsSpan = document.getElementById('cropOriginalDimensions'); const originalSizeSpan = document.getElementById('cropOriginalSize'); const newCropDimensionsSpan = document.getElementById('newCropDimensions'); const croppedSizeSpan = document.getElementById('croppedSize'); const previewSection = document.getElementById('cropImagePreview'); const cropperContainer = previewSection?.querySelector('.cropper-container'); const cropOriginalImagePreview = document.getElementById('cropOriginalImagePreview'); const cropSelectionOverlay = previewSection?.querySelector('.crop-selection-overlay'); const croppedImage = document.getElementById('croppedImage'); const selectAreaBtn = document.getElementById('selectCropAreaBtn'); const cropAndDownloadBtn = document.getElementById('cropAndDownloadBtn');

                 if (!imageInfoDiv || !originalFileNameSpan || !originalDimensionsSpan || !originalSizeSpan || !newCropDimensionsSpan || !croppedSizeSpan || !previewSection || !cropperContainer || !cropOriginalImagePreview || !cropSelectionOverlay || !croppedImage || !selectAreaBtn || !cropAndDownloadBtn) { console.error("[SETUP:CROPPER] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }
                 if (!originalCropImage || !(originalCropImage.naturalWidth > 0) || !(originalCropImage.naturalHeight > 0)) { console.error("[SETUP:CROPPER] originalCropImage not ready."); alert("Error loading image dimensions."); return; }
                 const originalCropWidth = originalCropImage.naturalWidth; const originalCropHeight = originalCropImage.naturalHeight; console.log(`[SETUP:CROPPER] Original dimensions ${originalCropWidth}x${originalCropHeight}.`);

                 originalFileNameSpan.textContent = file.name; originalDimensionsSpan.textContent = `${originalCropWidth}x${originalCropHeight}`; originalSizeSpan.textContent = formatBytes(file.size); newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-'; imageInfoDiv.style.display = 'block'; console.log("[SETUP:CROPPER] Info updated.");

                 // cropOriginalImagePreview should show the source from the originalImageObj
                 // Its blob URL is managed by handleImageFile and resetToolState
                 cropOriginalImagePreview.src = originalCropImage.src;
                 cropOriginalImagePreview.alt = `Image to Crop (${file.name})`;
                 cropOriginalImagePreview.style.display = 'block'; console.log("[SETUP:CROPPER] Original preview image set and displayed.");

                 // croppedImage should be cleared initially
                 // Revoke old blob URL before clearing
                 if (croppedImage.src && croppedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(croppedImage.src); } catch (e) { console.error(`[SETUP:CROPPER] Error revoking old cropped preview blob ${croppedImage.src}:`, e); } }
                 croppedImage.src = ''; croppedImage.alt = ''; croppedImage.style.display = 'none'; console.log("[SETUP:CROPPER] Cropped preview image cleared and hidden.");

                 previewSection.style.display = 'block'; console.log("[SETUP:CROPPER] Preview section displayed.");

                 // Download link cleared by general reset logic

                 selectAreaBtn.disabled = false; console.log("[SETUP:CROPPER] 'Select Area' button enabled.");
                 cropAndDownloadBtn.disabled = true; console.log("[SETUP:CROPPER] 'Crop' button disabled.");

                 // isSelectingCropArea, isDragging, startX, startY are now local here
                 let isSelectingCropArea = false;
                 let isDragging = false;
                 let startX = 0, startY = 0;
                 // window.finalScaledCrop is global

                 cropperContainer.style.cursor = 'default'; cropSelectionOverlay.style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;'; console.log("[SETUP:CROPPER] State and overlay reset.");

                console.log("[SETUP:CROPPER] complete.");
                // Return local state needed by listeners (implicitly handled by closure)
            }


            function setupRotateFlipUI(file, imgUrl) {
                 console.log("[SETUP:ROTATEFLIP] started.");
                 const imageInfoDiv = document.getElementById('rotateFlipImageInfo');
                 const originalFileNameSpan = document.getElementById('rotateFlipOriginalFileName');
                 const originalDimensionsSpan = document.getElementById('originalRotateFlipDimensions');
                 const originalSizeSpan = document.getElementById('rotateFlipOriginalSize');
                 const newRotateFlipDimensionsSpan = document.getElementById('newRotateFlipDimensions');
                 const newRotateFlipSizeSpan = document.getElementById('newRotateFlipSize');
                 const previewSection = document.getElementById('rotateFlipImagePreview');
                 const rotatedFlippedImage = document.getElementById('rotatedFlippedImage');
                 const rotateLeftBtn = document.getElementById('rotateLeftBtn');
                 const rotateRightBtn = document.getElementById('rotateRightBtn');
                 const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
                 const flipVerticalBtn = document.getElementById('flipVerticalBtn');

                if (!imageInfoDiv || !originalFileNameSpan || !originalDimensionsSpan || !originalSizeSpan || !newRotateFlipDimensionsSpan || !newRotateFlipSizeSpan || !previewSection || !rotatedFlippedImage || !rotateLeftBtn || !rotateRightBtn || !flipHorizontalBtn || !flipVerticalBtn) { console.error("[SETUP:ROTATEFLIP] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }

                originalFileNameSpan.textContent = file.name; originalDimensionsSpan.textContent = `${originalRotateFlipImage.naturalWidth}x${originalRotateFlipImage.naturalHeight}`; originalSizeSpan.textContent = formatBytes(file.size); newRotateFlipDimensionsSpan.textContent = '-'; newRotateFlipSizeSpan.textContent = '-'; imageInfoDiv.style.display = 'block'; console.log("[SETUP:ROTATEFLIP] Info updated.");

                // currentRotateFlipImage and rotatedFlippedImage should initially show the original image source
                 // Revoke old blob URL before setting new one
                 if (currentRotateFlipImage.src && currentRotateFlipImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(currentRotateFlipImage.src); } catch (e) { console.error(`[SETUP:ROTATEFLIP] Error revoking old current image blob ${currentRotateFlipImage.src}:`, e); } }
                 currentRotateFlipImage.src = originalRotateFlipImage.src; console.log("[SETUP:ROTATEFLIP] currentRotateFlipImage src set to original.");

                 // Revoke old blob URL before setting new one
                 if (rotatedFlippedImage.src && rotatedFlippedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(rotatedFlippedImage.src); } catch (e) { console.error(`[SETUP:ROTATEFLIP] Error revoking old rotated preview blob ${rotatedFlippedImage.src}:`, e); } }
                 rotatedFlippedImage.src = currentRotateFlipImage.src; rotatedFlippedImage.alt = `Original Image (${file.name})`; rotatedFlippedImage.style.display = 'block'; console.log("[SETUP:ROTATEFLIP] Preview image src set and displayed.");

                previewSection.style.display = 'block'; console.log("[SETUP:ROTATEFLIP] Preview section displayed.");

                // Download link cleared by general reset logic

                rotateLeftBtn.disabled = false; rotateRightBtn.disabled = false; flipHorizontalBtn.disabled = false; flipVerticalBtn.disabled = false; console.log("[SETUP:ROTATEFLIP] Transform buttons enabled.");
               console.log("[SETUP:ROTATEFLIP] complete.");
            }


            function setupFilterUI(file, imgUrl) {
                 console.log("[SETUP:FILTERS] started.");
                 const imageInfoDiv = document.getElementById('filterImageInfo'); const originalFileNameSpan = document.getElementById('filterOriginalFileName'); const originalDimensionsSpan = document.getElementById('originalFilterDimensions'); const originalSizeSpan = document.getElementById('filterOriginalSize'); const newFilterSizeSpan = document.getElementById('newFilterSize'); const previewSection = document.getElementById('filterImagePreview'); const filteredImage = document.getElementById('filteredImage'); const filterTypeSelect = document.getElementById('filterType'); const applyFilterBtn = document.getElementById('applyFilterBtn');

                 if (!imageInfoDiv || !originalFileNameSpan || !originalDimensionsSpan || !originalSizeSpan || !newFilterSizeSpan || !previewSection || !filteredImage || !filterTypeSelect || !applyFilterBtn) { console.error("[SETUP:FILTERS] Missing required UI elements."); alert("Error: Tool UI could not be initialized."); return; }

                 originalFileNameSpan.textContent = file.name; originalDimensionsSpan.textContent = `${originalFilterImage.naturalWidth}x${originalFilterImage.naturalHeight}`; originalSizeSpan.textContent = formatBytes(file.size); newFilterSizeSpan.textContent = '-'; imageInfoDiv.style.display = 'block'; console.log("[SETUP:FILTERS] Info updated.");

                 // filteredImage should initially show the source from the originalImageObj
                 // Its blob URL is managed by handleImageFile and resetToolState
                 filteredImage.src = originalFilterImage.src;
                 filteredImage.alt = `Original Image (${file.name})`;
                 filteredImage.style.display = 'block'; console.log("[SETUP:FILTERS] Preview image src set and displayed.");

                 previewSection.style.display = 'block'; console.log("[SETUP:FILTERS] Preview section displayed.");

                 // Download link cleared by general reset logic

                 filterTypeSelect.disabled = false; filterTypeSelect.value = 'none'; console.log("[SETUP:FILTERS] Select enabled and reset.");
                 applyFilterBtn.disabled = filterTypeSelect.value === 'none'; // Apply button starts disabled for 'none'
                 console.log(`[SETUP:FILTERS] Apply button enabled status: ${!applyFilterBtn.disabled}`);

                console.log("[SETUP:FILTERS] complete.");
            }


             // --- Helper to get a Blob from an Image object using a canvas ---
             function getBlobFromCanvas(canvas, mimeType, quality) {
                 return new Promise((resolve, reject) => {
                      if (!canvas || !canvas.getContext) { reject(new Error("Invalid canvas element.")); return; }
                      canvas.toBlob(resolve, mimeType, quality);
                  });
             }


            // --- Image Compressor JavaScript ---
            function setupImageCompressorListeners() {
                 console.log("[INIT:COMPRESSOR] Setting up listeners.");
                 const qualitySlider = document.getElementById('compressionQuality');
                 const qualityValueSpan = document.getElementById('qualityValue');
                 const compressNowBtn = document.getElementById('compressNowBtn');
                 const compressedSizeSpan = document.getElementById('compressedSize');
                 const sizeReductionSpan = document.getElementById('sizeReduction');
                 const originalImagePreview = document.getElementById('originalImagePreview');
                 const compressedImagePreview = document.getElementById('compressedImagePreview');
                 const downloadLink = document.getElementById('compressDownloadLink');
                 const downloadMessage = document.getElementById('compressDownloadMessage');
                 const processingMsg = document.getElementById('compressProcessingMsg');

                if (!qualitySlider || !qualityValueSpan || !compressNowBtn || !compressedSizeSpan || !sizeReductionSpan || !originalImagePreview || !compressedImagePreview || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:COMPRESSOR] Missing required UI elements for listeners. Skipping listener setup."); return; }

                 qualitySlider.addEventListener('input', (event) => { qualityValueSpan.textContent = event.target.value + '%'; });

                compressNowBtn.addEventListener('click', () => {
                     // Use the global file variable and the loaded original image object
                     if (window.originalCompressFile && originalCompressImage && originalCompressImage.complete && originalCompressImage.naturalWidth > 0) {
                         processCompressImage(window.originalCompressFile, originalCompressImage, qualitySlider.value);
                     } else { alert("Please select an image file first."); console.warn("[COMPRESSOR] Compress button clicked but image not ready."); }
                });

                compressNowBtn.disabled = true; // Disabled by default until file is loaded

                addDropZoneListeners('image-compressor', 'compressDropZone', 'compressImageFile'); console.log("[INIT:COMPRESSOR] finished.");

                 function processCompressImage(file, imageObj, quality) {
                     console.log(`[COMPRESSOR] processCompressImage started with quality: ${quality}`);
                     if (!file || !imageObj || !imageObj.src || !imageObj.complete || !(imageObj.naturalWidth > 0) || !(imageObj.naturalHeight > 0)) { console.error("[COMPRESSOR] Compression prerequisites not met inside process function."); alert("Cannot compress: Image not selected or not fully loaded. Please re-select the image."); compressNowBtn.disabled = !(window.originalCompressFile && originalCompressImage.complete && originalCompressImage.naturalHeight > 0); processingMsg.style.display = 'none'; return; }

                     compressNowBtn.disabled = true; processingMsg.style.display = 'block'; console.log("[COMPRESSOR] Processing message shown.");
                     compressedSizeSpan.textContent = '-'; sizeReductionSpan.textContent = '-';

                     // Revoke old blob URL before clearing
                     if (compressedImagePreview.src && compressedImagePreview.src.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) { console.error(`[COMPRESSOR] Error revoking old compressed preview blob ${compressedImagePreview.src}:`, e); } }
                     compressedImagePreview.src = ''; compressedImagePreview.style.display = 'none'; compressedImagePreview.alt = '';

                     // Revoke old blob URL before clearing download link
                     if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[COMPRESSOR] Error revoking old download blob ${downloadLink.href}:`, e); } }
                     downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none'; console.log("[COMPRESSOR] Previous output cleared.");

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight; console.log(`[COMPRESSOR] Canvas created: ${canvas.width}x${canvas.height}.`);

                     const mimeType = file.type === 'image/png' ? 'image/png' : file.type === 'image/webp' ? 'image/webp' : 'image/jpeg';
                     // For non-transparent formats, draw white background before drawing image
                     if (mimeType !== 'image/png' && mimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                         ctx.fillStyle = '#fff';
                         ctx.fillRect(0, 0, canvas.width, canvas.height);
                         console.log("[COMPRESSOR] Canvas filled white for non-PNG/WebP output.");
                     } else {
                          ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                         console.log("[COMPRESSOR] Canvas cleared for PNG/WebP output.");
                     }

                     ctx.drawImage(imageObj, 0, 0); console.log("[COMPRESSOR] Image drawn.");

                     const outputQuality = quality / 100;

                     canvas.toBlob((blob) => {
                         console.log("[COMPRESSOR] Canvas toBlob callback fired.");
                         if (blob) {
                             console.log("[COMPRESSOR] Blob created. Size:", blob.size);
                             updateCompressOutput(blob, file.name, file.size, mimeType);
                         } else {
                             console.error("[COMPRESSOR] canvas.toBlob failed.");
                             alert("Image compression failed.");
                             compressedSizeSpan.textContent = 'Failed'; sizeReductionSpan.textContent = 'Failed';
                         }
                         // Re-enable button and hide message regardless of success/failure
                         compressNowBtn.disabled = !(window.originalCompressFile && originalCompressImage.complete && originalCompressImage.naturalHeight > 0);
                         processingMsg.style.display = 'none'; console.log("[COMPRESSOR] Processing finished.");
                     }, mimeType, outputQuality); console.log(`[COMPRESSOR] Calling canvas.toBlob with type ${mimeType}, quality ${outputQuality}...`);
                 }

                 function updateCompressOutput(compressedBlob, originalName, originalSize, mimeType) {
                    console.log("[COMPRESSOR] updateCompressOutput started."); if (!compressedBlob) { console.error("[COMPRESSOR] updateCompressOutput called with no blob."); return; }

                    // Revoke old blob URLs before setting new ones
                    if (compressedImagePreview.src && compressedImagePreview.src.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) { console.error(`[COMPRESSOR] Error revoking old compressed preview blob ${compressedImagePreview.src}:`, e); } }
                    if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[COMPRESSOR] Error revoking old download blob ${downloadLink.href}:`, e); } }

                    const compressedSize = compressedBlob.size; const objectUrl = URL.createObjectURL(compressedBlob); const reduction = originalSize > 0 ? ((originalSize - compressedSize) / originalSize) * 100 : 0;
                    compressedSizeSpan.textContent = formatBytes(compressedSize); sizeReductionSpan.textContent = reduction >= 0 ? `${reduction.toFixed(2)}%` : 'N/A'; console.log(`[COMPRESSOR] Compressed size: ${formatBytes(compressedSize)}.`);

                    compressedImagePreview.src = objectUrl; compressedImagePreview.alt = `Compressed Image (${originalName})`; compressedImagePreview.style.display = 'block';
                    // Ensure original preview is also shown for comparison
                    const originalImagePreview = document.getElementById('originalImagePreview');
                    if (originalImagePreview) originalImagePreview.style.display = 'block';

                    console.log("[COMPRESSOR] Compressed preview displayed.");

                    downloadLink.href = objectUrl; const baseName = originalName.replace(/\.[^/.]+$/, ""); let finalExtension = mimeType.split('/')[1]; if (finalExtension === 'jpeg') finalExtension = 'jpg'; downloadLink.download = `compressed_${baseName}.${finalExtension}`; downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block'; console.log(`[COMPRESSOR] Download link set.`);
                    console.log("[COMPRESSOR] updateCompressOutput finished.");
                 }
            }

            // --- Image Resizer JavaScript ---
             function setupImageResizerListeners() {
                  console.log("[INIT:RESIZER] Setting up listeners.");
                 const widthInput = document.getElementById('resizeWidth'); const heightInput = document.getElementById('resizeHeight'); const applyBtn = document.getElementById('applyResizeBtn'); const originalDimensionsSpan = document.getElementById('originalDimensions'); const newDimensionsSpan = document.getElementById('newDimensions'); const resizedSizeSpan = document.getElementById('resizedSize'); const resizedImage = document.getElementById('resizedImage'); const downloadLink = document.getElementById('resizeDownloadLink'); const downloadMessage = document.getElementById('resizeDownloadMessage'); const processingMsg = document.getElementById('resizeProcessingMsg');
                if (!widthInput || !heightInput || !applyBtn || !originalDimensionsSpan || !newDimensionsSpan || !resizedSizeSpan || !resizedImage || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:RESIZER] Missing required UI elements."); return; }
                 // originalResizeWidth, originalResizeHeight are effectively captured via closure in setupResizeUI which is called by handleImageFile

                 function performResize(file, imageObj, newWidth, newHeight) {
                     console.log(`[RESIZER] performResize started to ${newWidth}x${newHeight}.`);
                      if (!file || !imageObj || !imageObj.src || !imageObj.complete || !(imageObj.naturalWidth > 0) || !(imageObj.naturalHeight > 0)) { console.error("[RESIZER] Resize prerequisites not met."); alert("Cannot resize: Image not selected or not fully loaded."); const w = parseInt(widthInput?.value); const h = parseInt(heightInput?.value); if(applyBtn) applyBtn.disabled = !(window.originalResizeFile && originalResizeImage.complete && originalResizeImage.naturalHeight > 0 && !isNaN(w) && w > 0 && !isNaN(h) && h > 0); if(processingMsg) processingMsg.style.display = 'none'; return; }
                      if (newWidth <= 0 || newHeight <= 0 || isNaN(newWidth) || isNaN(newHeight)) { console.error(`[RESIZER] Invalid dimensions provided: ${newWidth}x${newHeight}`); alert("Please enter valid positive dimensions."); const w = parseInt(widthInput?.value); const h = parseInt(heightInput?.value); if(applyBtn) applyBtn.disabled = !(window.originalResizeFile && originalResizeImage.complete && originalResizeImage.naturalHeight > 0 && !isNaN(w) && w > 0 && !isNaN(h) && h > 0); if(processingMsg) processingMsg.style.display = 'none'; return; }

                      applyBtn.disabled = true; processingMsg.style.display = 'block'; console.log("[RESIZER] Processing message shown.");

                      // Revoke old blob URL before clearing
                      if (resizedImage.src && resizedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImage.src); } catch (e) { console.error(`[RESIZER] Error revoking old resized preview blob ${resizedImage.src}:`, e); } }
                      resizedImage.src = ''; resizedImage.alt = ''; resizedImage.style.display = 'none';

                       // Revoke old blob URL before clearing download link
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[RESIZER] Error revoking old download blob ${downloadLink.href}:`, e); } }
                      downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';

                      newDimensionsSpan.textContent = '-'; resizedSizeSpan.textContent = '-'; console.log("[RESIZER] Previous output cleared.");

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = newWidth; canvas.height = newHeight; console.log(`[RESIZER] Canvas created: ${canvas.width}x${canvas.height}.`);

                      const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                      // For non-transparent formats, draw white background
                      if (mimeType !== 'image/png' && mimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                          ctx.fillStyle = '#fff';
                          ctx.fillRect(0, 0, canvas.width, canvas.height);
                          console.log("[RESIZER] Canvas filled white for non-PNG/WebP output.");
                      } else {
                           ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                          console.log("[RESIZER] Canvas cleared for PNG/WebP output.");
                      }

                      // Draw the original image scaled to the new dimensions
                      ctx.drawImage(imageObj, 0, 0, newWidth, newHeight); console.log("[RESIZER] Image drawn.");

                      canvas.toBlob((blob) => {
                          console.log("[RESIZER] Canvas toBlob callback fired.");
                          if (blob) {
                              console.log("[RESIZER] Blob created. Size:", blob.size);
                              updateResizeOutput(blob, file.name, newWidth, newHeight, file.size, mimeType);
                          } else {
                              console.error("[RESIZER] canvas.toBlob failed.");
                              alert("Image resizing failed.");
                              newDimensionsSpan.textContent = 'Failed'; resizedSizeSpan.textContent = 'Failed';
                          }
                          // Re-enable button and hide message regardless of success/failure
                          const w = parseInt(widthInput?.value); const h = parseInt(heightInput?.value);
                          if(applyBtn) applyBtn.disabled = !(window.originalResizeFile && originalResizeImage.complete && originalResizeImage.naturalHeight > 0 && !isNaN(w) && w > 0 && !isNaN(h) && h > 0);
                          if(processingMsg) processingMsg.style.display = 'none'; console.log("[RESIZER] Processing finished.");
                      }, mimeType); console.log(`[RESIZER] Calling canvas.toBlob with type ${mimeType}...`);
                 }

                 function updateResizeOutput(resizedBlob, originalName, newWidth, newHeight, originalSize, mimeType) {
                     console.log("[RESIZER] updateResizeOutput started."); if (!resizedBlob) { console.error("[RESIZER] updateResizeOutput called with no blob."); return; }

                      // Revoke old blob URLs before setting new ones
                      if (resizedImage.src && resizedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImage.src); } catch (e) { console.error(`[RESIZER] Error revoking old resized preview blob ${resizedImage.src}:`, e); } }
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[RESIZER] Error revoking old download blob ${downloadLink.href}:`, e); } }

                      const resizedSize = resizedBlob.size; const objectUrl = URL.createObjectURL(resizedBlob);
                      newDimensionsSpan.textContent = `${newWidth}x${newHeight}`; resizedSizeSpan.textContent = formatBytes(resizedSize); console.log(`[RESIZER] Resized size: ${formatBytes(resizedSize)}.`);

                      resizedImage.src = objectUrl; resizedImage.style.display = 'block'; resizedImage.alt = `Resized Image (${originalName})`; console.log("[RESIZER] Preview image displayed.");
                      const previewSection = document.getElementById('resizeImagePreview'); if(previewSection) { previewSection.style.display = 'block'; console.log("[RESIZER] Preview section displayed."); } else console.warn("[RESIZER] resizeImagePreview section not found.");

                      downloadLink.href = objectUrl; const baseName = originalName.replace(/\.[^/.]+$/, ""); let finalExtension = mimeType.split('/')[1]; if (finalExtension === 'jpeg') finalExtension = 'jpg'; downloadLink.download = `resized_${baseName}.${finalExtension}`; downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block'; console.log(`[RESIZER] Download link set.`);
                     console.log("[RESIZER] updateResizeOutput finished.");
                 }

                 const dimensionInputHandler = () => {
                      console.log("[RESIZER] Dimension input changed.");
                      const isImageReady = originalResizeImage && originalResizeImage.complete && originalResizeImage.naturalHeight > 0;
                      if (!isImageReady) { if(applyBtn) applyBtn.disabled = true; return; }
                     const w = parseInt(widthInput.value); const h = parseInt(heightInput.value);
                     if(applyBtn) applyBtn.disabled = !(!isNaN(w) && w > 0 && !isNaN(h) && h > 0); console.log(`[RESIZER] Apply button enabled status: ${!applyBtn.disabled}`);
                 };
                 widthInput.addEventListener('input', dimensionInputHandler); heightInput.addEventListener('input', dimensionInputHandler);

                applyBtn.addEventListener('click', () => {
                   console.log("[RESIZER] Apply Resize button clicked.");
                    const newWidth = parseInt(widthInput.value); const newHeight = parseInt(heightInput.value);
                    // Use the global file variable and the loaded original image object
                    if (window.originalResizeFile && originalResizeImage && originalResizeImage.complete && originalResizeImage.naturalHeight > 0 && !isNaN(newWidth) && newWidth > 0 && !isNaN(newHeight) && newHeight > 0) {
                        performResize(window.originalResizeFile, originalResizeImage, newWidth, newHeight);
                    } else { console.warn("[RESIZER] Apply button clicked with invalid state."); alert("Please select a file and enter valid positive dimensions."); }
                });

                applyBtn.disabled = true; // Disabled by default until inputs are valid AND image is loaded

                addDropZoneListeners('image-resizer', 'resizeDropZone', 'resizeImageFile'); console.log("[INIT:RESIZER] finished.");
             }

            // --- Image Converter JavaScript ---
            function setupImageConverterListeners() {
                console.log("[INIT:CONVERTER] Setting up listeners.");
                 const formatSelect = document.getElementById('outputFormat'); const applyBtn = document.getElementById('applyConvertBtn'); const originalFormatSpan = document.getElementById('originalFormat'); const newFormatSpan = document.getElementById('newFormat'); const convertedSizeSpan = document.getElementById('convertedSize'); const convertedImage = document.getElementById('convertedImage'); const downloadLink = document.getElementById('convertDownloadLink'); const downloadMessage = document.getElementById('convertDownloadMessage'); const processingMsg = document.getElementById('convertProcessingMsg');
                if (!formatSelect || !applyBtn || !originalFormatSpan || !newFormatSpan || !convertedSizeSpan || !convertedImage || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:CONVERTER] Missing required UI elements."); return; }

                 function performConversion(file, imageObj, outputMimeType) {
                     console.log(`[CONVERTER] performConversion started to type: ${outputMimeType}`);
                      if (!file || !imageObj || !imageObj.src || !imageObj.complete || !(imageObj.naturalWidth > 0) || !(imageObj.naturalHeight > 0) || !outputMimeType) { console.error("[CONVERTER] Conversion prerequisites not met."); alert("Cannot convert: Image not selected/loaded or output format not selected."); if(applyBtn) applyBtn.disabled = !(window.originalConvertFile && originalConvertImage.complete && originalConvertImage.naturalHeight > 0 && formatSelect.value); if(processingMsg) processingMsg.style.display = 'none'; return; }

                      applyBtn.disabled = true; processingMsg.style.display = 'block'; console.log("[CONVERTER] Processing message shown.");

                      // Revoke old blob URL before clearing
                      if (convertedImage.src && convertedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(convertedImage.src); } catch (e) { console.error(`[CONVERTER] Error revoking old converted preview blob ${convertedImage.src}:`, e); } }
                      convertedImage.src = ''; convertedImage.alt = ''; convertedImage.style.display = 'none';

                       // Revoke old blob URL before clearing download link
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[CONVERTER] Error revoking old download blob ${downloadLink.href}:`, e); } }
                      downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';

                      newFormatSpan.textContent = '-'; convertedSizeSpan.textContent = '-'; console.log("[CONVERTER] Previous output cleared.");

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight; console.log(`[CONVERTER] Canvas created: ${canvas.width}x${canvas.height}.`);

                       // For non-transparent formats, draw white background
                      if (outputMimeType !== 'image/png' && outputMimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                          ctx.fillStyle = '#fff';
                          ctx.fillRect(0, 0, canvas.width, canvas.height);
                          console.log("[CONVERTER] Canvas filled white for non-PNG/WebP output.");
                      } else {
                           ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                          console.log("[CONVERTER] Canvas cleared for PNG/WebP output.");
                      }

                      ctx.drawImage(imageObj, 0, 0); console.log("[CONVERTER] Image drawn.");

                      const outputQuality = 0.8; // Default quality for conversion where applicable

                      canvas.toBlob((blob) => {
                          console.log("[CONVERTER] Canvas toBlob callback fired.");
                          if (blob) {
                              console.log("[CONVERTER] Blob created. Size:", blob.size);
                              updateConvertOutput(blob, file.name, outputMimeType, file.size, file.type);
                          } else {
                              console.error("[CONVERTER] canvas.toBlob failed.");
                              alert("Image conversion failed.");
                              newFormatSpan.textContent = 'Failed'; convertedSizeSpan.textContent = 'Failed';
                          }
                          // Re-enable button and hide message regardless of success/failure
                          if(applyBtn) applyBtn.disabled = !(window.originalConvertFile && originalConvertImage.complete && originalConvertImage.naturalHeight > 0 && formatSelect.value);
                          if(processingMsg) processingMsg.style.display = 'none'; console.log("[CONVERTER] Processing finished.");
                      }, outputMimeType, outputQuality); console.log(`[CONVERTER] Calling canvas.toBlob with type ${outputMimeType}...`);
                 }

                 function updateConvertOutput(convertedBlob, originalName, outputMimeType, originalSize, originalMimeType) {
                     console.log("[CONVERTER] updateConvertOutput started."); if (!convertedBlob) { console.error("[CONVERTER] updateConvertOutput called with no blob."); return; }

                      // Revoke old blob URLs before setting new ones
                      if (convertedImage.src && convertedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(convertedImage.src); } catch (e) { console.error(`[CONVERTER] Error revoking old converted preview blob ${convertedImage.src}:`, e); } }
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[CONVERTER] Error revoking old download blob ${downloadLink.href}:`, e); } }

                      const convertedSize = convertedBlob.size; const objectUrl = URL.createObjectURL(convertedBlob);
                      originalFormatSpan.textContent = originalMimeType.split('/')[1]?.toUpperCase() || 'Unknown'; newFormatSpan.textContent = outputMimeType.split('/')[1]?.toUpperCase() || 'Unknown'; convertedSizeSpan.textContent = formatBytes(convertedSize); console.log(`[CONVERTER] Converted size: ${formatBytes(convertedSize)}.`);

                      convertedImage.src = objectUrl; convertedImage.style.display = 'block'; convertedImage.alt = `Converted Image (${originalName} to ${newFormatSpan.textContent})`; console.log("[CONVERTER] Preview displayed.");
                      const previewSection = document.getElementById('convertImagePreview'); if(previewSection) { previewSection.style.display = 'block'; console.log("[CONVERTER] Preview section displayed."); } else console.warn("[CONVERTER] convertImagePreview section not found.");

                      downloadLink.href = objectUrl; const baseName = originalName.replace(/\.[^/.]+$/, ""); let finalExtension = outputMimeType.split('/')[1]; if (finalExtension === 'jpeg') finalExtension = 'jpg'; downloadLink.download = `converted_${baseName}.${finalExtension}`; downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block'; console.log(`[CONVERTER] Download link set.`);
                    console.log("[CONVERTER] updateConvertOutput finished.");
                 }

                 formatSelect.addEventListener('change', () => {
                      console.log("[CONVERTER] Format select changed.");
                      const isImageReady = window.originalConvertFile && originalConvertImage && originalConvertImage.complete && originalConvertImage.naturalHeight > 0;
                      if (applyBtn) { applyBtn.disabled = !(isImageReady); console.log(`[CONVERTER] Apply button enabled status: ${!applyBtn.disabled}`); }
                 });

                applyBtn.addEventListener('click', () => {
                   console.log("[CONVERTER] Convert button clicked.");
                    const outputMimeType = formatSelect.value;
                    // Use the global file variable and the loaded original image object
                    if (window.originalConvertFile && originalConvertImage && originalConvertImage.complete && originalConvertImage.naturalHeight > 0 && outputMimeType) {
                        performConversion(window.originalConvertFile, originalConvertImage, outputMimeType);
                    } else { console.warn("[CONVERTER] Convert button clicked with invalid state."); alert("Please select a file and an output format."); }
                });

                applyBtn.disabled = true; // Disabled by default until file is loaded

                addDropZoneListeners('image-converter', 'convertDropZone', 'convertImageFile'); console.log("[INIT:CONVERTER] finished.");
            }

            // --- Image Cropper JavaScript ---
            function setupImageCropperListeners() {
                 console.log("[INIT:CROPPER] Setting up listeners.");
                 const selectAreaBtn = document.getElementById('selectCropAreaBtn'); const cropAndDownloadBtn = document.getElementById('cropAndDownloadBtn'); const originalDimensionsSpan = document.getElementById('cropOriginalDimensions'); const originalSizeSpan = document.getElementById('cropOriginalSize'); const newCropDimensionsSpan = document.getElementById('newCropDimensions'); const croppedSizeSpan = document.getElementById('croppedSize'); const previewSection = document.getElementById('cropImagePreview'); const cropperContainer = previewSection?.querySelector('.cropper-container'); const cropOriginalImagePreview = document.getElementById('cropOriginalImagePreview'); const cropSelectionOverlay = previewSection?.querySelector('.crop-selection-overlay'); const croppedImage = document.getElementById('croppedImage'); const downloadLink = document.getElementById('cropDownloadLink'); const downloadMessage = document.getElementById('cropDownloadMessage'); const processingMsg = document.getElementById('cropProcessingMsg');
                if (!selectAreaBtn || !cropAndDownloadBtn || !originalDimensionsSpan || !originalSizeSpan || !newCropDimensionsSpan || !croppedSizeSpan || !previewSection || !cropperContainer || !cropOriginalImagePreview || !cropSelectionOverlay || !croppedImage || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:CROPPER] Missing required UI elements."); return; }

                let isSelectingCropArea = false; let isDragging = false; let startX = 0, startY = 0;
                // window.finalScaledCrop is global

                function getMouseCoords(event) {
                    if (!cropperContainer || !cropOriginalImagePreview || !(originalCropImage.naturalWidth > 0) || !(originalCropImage.naturalHeight > 0)) { console.warn("[CROPPER] getMouseCoords called before image or container ready."); return { x: 0, y: 0, displayX: 0, displayY: 0 }; }
                    const imgRect = cropOriginalImagePreview.getBoundingClientRect(); const containerRect = cropperContainer.getBoundingClientRect();
                    let rawX = event.clientX - containerRect.left; let rawY = event.clientY - containerRect.top;
                    const imgOffsetX = imgRect.left - containerRect.left; const imgOffsetY = imgRect.top - containerRect.top;
                    let xInDisplayedImage = rawX - imgOffsetX; let yInDisplayedImage = rawY - imgOffsetY;
                    xInDisplayedImage = Math.max(0, Math.min(xInDisplayedImage, imgRect.width)); yInDisplayedImage = Math.max(0, Math.min(yInDisplayedImage, imgRect.height));
                    const scaleX = originalCropImage.naturalWidth / imgRect.width; const scaleY = originalCropImage.naturalHeight / imgRect.height;
                    const originalX = Math.round(xInDisplayedImage * scaleX); const originalY = Math.round(yInDisplayedImage * scaleY);
                    return { x: Math.max(0, Math.min(originalX, originalCropImage.naturalWidth)), y: Math.max(0, Math.min(originalY, originalCropImage.naturalHeight)), displayX: xInDisplayedImage + imgOffsetX, displayY: yInDisplayedImage + imgOffsetY };
                }

                function performCrop(file, imageObj) {
                    console.log("[CROPPER] performCrop started.");
                     // Use the global file variable and the loaded original image object
                     if (!file || !imageObj || !imageObj.src || !imageObj.complete || !(imageObj.naturalWidth > 0) || !(imageObj.naturalHeight > 0) || !window.finalScaledCrop || window.finalScaledCrop.width <= 0 || window.finalScaledCrop.height <= 0) { console.error("[CROPPER] Crop prerequisites not met."); alert("Please select a valid crop area first."); if(selectAreaBtn) selectAreaBtn.disabled = !(window.originalCropFile && originalCropImage.complete && originalCropImage.naturalHeight > 0); if(cropAndDownloadBtn) cropAndDownloadBtn.disabled = true; if(processingMsg) processingMsg.style.display = 'none'; return; }
                     const { x, y, width, height } = window.finalScaledCrop; console.log(`[CROPPER] Cropping area (original pixels): x=${x}, y=${y}, w=${width}, h=${height}`);
                      if (x < 0 || y < 0 || (x + width) > imageObj.naturalWidth || (y + height) > imageObj.naturalHeight) { console.error("[CROPPER] Calculated crop area is outside original bounds."); alert("An error occurred with the selected crop area."); if(selectAreaBtn) selectAreaBtn.disabled = !(window.originalCropFile && originalCropImage.complete && originalCropImage.naturalHeight > 0); if(cropAndDownloadBtn) cropAndDownloadBtn.disabled = true; if(processingMsg) processingMsg.style.display = 'none'; return; }

                     cropAndDownloadBtn.disabled = true; selectAreaBtn.disabled = true; processingMsg.style.display = 'block'; console.log("[CROPPER] Processing message shown.");

                     // Revoke old blob URL before clearing
                      if (croppedImage.src && croppedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(croppedImage.src); } catch (e) { console.error(`[CROPPER] Error revoking old cropped preview blob ${croppedImage.src}:`, e); } }
                     croppedImage.src = ''; croppedImage.alt = ''; croppedImage.style.display = 'none';

                     if (cropSelectionOverlay) cropSelectionOverlay.style.display = 'none';
                     // Keep cropOriginalImagePreview displayed until cropped image is ready? Or hide it?
                     // Let's hide it for now to show the result clearly.
                     if (cropOriginalImagePreview) cropOriginalImagePreview.style.display = 'none'; console.log("[CROPPER] Original preview image hidden.");

                      // Revoke old blob URL before clearing download link
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[CROPPER] Error revoking old download blob ${downloadLink.href}:`, e); } }
                     downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';

                     newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-'; console.log("[CROPPER] Previous output cleared.");

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     canvas.width = width; canvas.height = height; console.log(`[CROPPER] Canvas created: ${canvas.width}x${canvas.height}.`);

                     const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                     // For non-transparent formats, draw white background
                     if (mimeType !== 'image/png' && mimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                          ctx.fillStyle = '#fff';
                          ctx.fillRect(0, 0, canvas.width, canvas.height);
                          console.log("[CROPPER] Canvas filled white for non-PNG/WebP output.");
                     } else {
                          ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                         console.log("[CROPPER] Canvas cleared for PNG/WebP output.");
                     }


                     ctx.drawImage(imageObj, x, y, width, height, 0, 0, width, height); console.log("[CROPPER] Image drawn.");

                     canvas.toBlob((blob) => {
                         console.log("[CROPPER] Canvas toBlob callback fired.");
                         if (blob) {
                             console.log("[CROPPER] Blob created. Size:", blob.size);
                             updateCropOutput(blob, file.name, width, height, file.size, mimeType);
                         } else {
                             console.error("[CROPPER] canvas.toBlob failed.");
                             alert("Image cropping failed.");
                             newCropDimensionsSpan.textContent = 'Failed'; croppedSizeSpan.textContent = 'Failed';
                         }
                         // Re-enable buttons and hide message regardless of success/failure
                         if(selectAreaBtn) selectAreaBtn.disabled = !(window.originalCropFile && originalCropImage.complete && originalCropImage.naturalHeight > 0);
                         if(cropAndDownloadBtn) cropAndDownloadBtn.disabled = true; // Always disable crop button until new area selected
                         if(processingMsg) processingMsg.style.display = 'none'; console.log("[CROPPER] Processing finished.");
                     }, mimeType); console.log(`[CROPPER] Calling canvas.toBlob with type ${mimeType}...`);
                }

                 function updateCropOutput(croppedBlob, originalName, newWidth, newHeight, originalSize, mimeType) {
                     console.log("[CROPPER] updateCropOutput started."); if (!croppedBlob) { console.error("[CROPPER] updateCropOutput called with no blob."); return; }

                      // Revoke old blob URLs before setting new ones
                      if (croppedImage.src && croppedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(croppedImage.src); } catch (e) { console.error(`[CROPPER] Error revoking old cropped preview blob ${croppedImage.src}:`, e); } }
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[CROPPER] Error revoking old download blob ${downloadLink.href}:`, e); } }

                      const croppedSize = croppedBlob.size; const objectUrl = URL.createObjectURL(croppedBlob);
                      newCropDimensionsSpan.textContent = `${newWidth}x${newHeight}`; croppedSizeSpan.textContent = formatBytes(croppedSize); console.log(`[CROPPER] Cropped size: ${formatBytes(croppedSize)}.`);

                      croppedImage.src = objectUrl; croppedImage.style.display = 'block'; croppedImage.alt = `Cropped Image (${originalName})`; console.log("[CROPPER] Cropped preview displayed.");
                      const previewSection = document.getElementById('cropImagePreview'); if(previewSection) previewSection.style.display = 'block'; else console.warn("[CROPPER] cropImagePreview section not found");
                      if (cropOriginalImagePreview) cropOriginalImagePreview.style.display = 'none'; else console.warn("[CROPPER] cropOriginalImagePreview not found"); // Ensure original is hidden after crop
                      if (cropSelectionOverlay) cropSelectionOverlay.style.display = 'none'; else console.warn("[CROPPER] cropSelectionOverlay not found");

                      // isSelectingCropArea, isDragging, startX, startY are local and reset implicitly or by select area button
                      window.finalScaledCrop = null; if(cropperContainer) cropperContainer.style.cursor = 'default'; console.log("[CROPPER] State reset after crop.");

                      downloadLink.href = objectUrl; const baseName = originalName.replace(/\.[^/.]+$/, ""); let finalExtension = mimeType.split('/')[1]; if (finalExtension === 'jpeg') finalExtension = 'jpg'; downloadLink.download = `cropped_${baseName}.${finalExtension}`; downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block'; console.log(`[CROPPER] Download link set.`);
                     console.log("[CROPPER] updateCropOutput finished.");
                 }


                 selectAreaBtn.addEventListener('click', () => {
                      console.log("[CROPPER] Select Area button clicked.");
                      // Use the global file variable and the loaded original image object
                      if (window.originalCropFile && originalCropImage && originalCropImage.complete && originalCropImage.naturalHeight > 0) {
                          isSelectingCropArea = true; isDragging = false; console.log("[CROPPER] Selection mode activated.");
                          if (cropSelectionOverlay) cropSelectionOverlay.style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;'; // Reset overlay size/position
                          if (cropOriginalImagePreview) { cropOriginalImagePreview.style.display = 'block'; console.log("[CROPPER] Original preview displayed for selection."); } else console.warn("[CROPPER] cropOriginalImagePreview not found.");

                           // Revoke old blob URL before clearing cropped image preview
                           if (croppedImage.src && croppedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(croppedImage.src); } catch (e) { console.error(`[CROPPER] Error revoking old cropped preview blob ${croppedImage.src}:`, e); } }
                           croppedImage.src = ''; croppedImage.alt = ''; croppedImage.style.display = 'none'; console.log("[CROPPER] Cropped preview hidden.");

                          newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';

                          // Revoke old blob URL before clearing download link
                          if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[CROPPER] Error revoking old download blob ${downloadLink.href}:`, e); } }
                          downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';

                          window.finalScaledCrop = null; cropAndDownloadBtn.disabled = true;
                          cropperContainer.style.cursor = 'crosshair'; selectAreaBtn.disabled = true; // Disable select button during selection mode
                      } else { alert("Please select an image file first."); console.warn("[CROPPER] Select Area clicked but image not ready."); }
                 });

                 cropperContainer.addEventListener('mousedown', (e) => {
                      if (!isSelectingCropArea || isDragging || e.button !== 0) return; e.preventDefault(); e.stopPropagation(); console.log("[CROPPER] Mouse down event.");
                      isDragging = true;
                      // Get mouse coordinates relative to the cropper container
                      const containerRect = cropperContainer.getBoundingClientRect();
                      const rawX = e.clientX - containerRect.left;
                      const rawY = e.clientY - containerRect.top;
                      // Clamp start position to container bounds (which wraps the image)
                      startX = Math.max(0, Math.min(rawX, containerRect.width));
                      startY = Math.max(0, Math.min(rawY, containerRect.height));

                      console.log(`[CROPPER] Drag started at (${startX}, ${startY}) display coords.`);
                      cropSelectionOverlay.style.left = `${startX}px`; cropSelectionOverlay.style.top = `${startY}px`; cropSelectionOverlay.style.width = '0'; cropSelectionOverlay.style.height = '0'; cropSelectionOverlay.style.display = 'block'; console.log("[CROPPER] Selection overlay shown.");
                      newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-'; cropAndDownloadBtn.disabled = true; window.finalScaledCrop = null;
                 });

                 cropperContainer.addEventListener('mousemove', (e) => {
                      if (!isDragging) return; e.preventDefault(); e.stopPropagation();
                      const containerRect = cropperContainer.getBoundingClientRect();
                      const rawX = e.clientX - containerRect.left;
                      const rawY = e.clientY - containerRect.top;
                      // Clamp current position to container bounds
                      const cx = Math.max(0, Math.min(rawX, containerRect.width));
                      const cy = Math.max(0, Math.min(rawY, containerRect.height));

                      const x = Math.min(cx, startX); const y = Math.min(cy, startY);
                      const w = Math.abs(cx - startX); const h = Math.abs(cy - startY);

                      cropSelectionOverlay.style.left = `${x}px`; cropSelectionOverlay.style.top = `${y}px`; cropSelectionOverlay.style.width = `${w}px`; cropSelectionOverlay.style.height = `${h}px`;

                      // Enable Crop button only if a selection area with dimensions > 0 exists
                      cropAndDownloadBtn.disabled = !(w > 0 && h > 0);
                 });

                 document.addEventListener('mouseup', (e) => {
                      if (!isDragging) return; isDragging = false; console.log("[CROPPER] Drag finished.");
                      // Ensure we are still in selection mode after drag ends
                      if (!isSelectingCropArea) { console.warn("[CROPPER] Drag ended, but not in selection mode."); return; }

                      const fw = cropSelectionOverlay.offsetWidth || 0; const fh = cropSelectionOverlay.offsetHeight || 0; console.log(`[CROPPER] Final overlay size (display pixels): ${fw}x${fh}.`);

                      // Check if a valid area was selected
                      if (fw > 0 && fh > 0 && cropperContainer && cropOriginalImagePreview && originalCropImage && originalCropImage.naturalWidth > 0) {
                          const overlayRect = cropSelectionOverlay.getBoundingClientRect();
                          const imgRect = cropOriginalImagePreview.getBoundingClientRect();

                          // Calculate overlay position relative to the image within the container (in displayed pixels)
                          const overlayLeftInImage = overlayRect.left - imgRect.left;
                          const overlayTopInImage = overlayRect.top - imgRect.top;

                          // Clamp overlay position and size to image bounds (in displayed pixels)
                          // This handles cases where selection starts/ends outside the visible image area but within the container
                          const clampedOverlayX = Math.max(0, overlayLeftInImage);
                          const clampedOverlayY = Math.max(0, overlayTopInImage);

                          const clampedWidth = Math.min(fw, imgRect.width - clampedOverlayX);
                          const clampedHeight = Math.min(fh, imgRect.height - clampedOverlayY);

                          // Scale clamped dimensions back to original image pixel dimensions
                          const scaleX = originalCropImage.naturalWidth / imgRect.width;
                          const scaleY = originalCropImage.naturalHeight / imgRect.height;

                          const scaledOriginX = Math.round(clampedOverlayX * scaleX);
                          const scaledOriginY = Math.round(clampedOverlayY * scaleY);
                          const scaledWidth = Math.round(clampedWidth * scaleX);
                          const scaledHeight = Math.round(clampedHeight * scaleY);

                           // Final clamping against original image bounds (should be redundant if previous clamping is correct, but good safeguard)
                           // Also ensures min 1px dimension for edge cases
                          const finalX = Math.max(0, Math.min(scaledOriginX, originalCropImage.naturalWidth - 1));
                          const finalY = Math.max(0, Math.min(scaledOriginY, originalCropImage.naturalHeight - 1));
                          const finalWidth = Math.max(1, Math.min(scaledWidth, originalCropImage.naturalWidth - finalX));
                          const finalHeight = Math.max(1, Math.min(scaledHeight, originalCropImage.naturalHeight - finalY));

                          console.log(`[CROPPER] Scaled crop area (original pixels): x=${finalX}, y=${finalY}, w=${finalWidth}, h=${finalHeight}`);


                          if (finalWidth > 0 && finalHeight > 0) {
                              window.finalScaledCrop = { x: finalX, y: finalY, width: finalWidth, height: finalHeight };
                              newCropDimensionsSpan.textContent = `${window.finalScaledCrop.width}x${window.finalScaledCrop.height}`;
                              croppedSizeSpan.textContent = '-'; // Size will be calculated after crop
                              cropAndDownloadBtn.disabled = false;
                              console.log("[CROPPER] Area selected and validated.", window.finalScaledCrop);
                              isSelectingCropArea = false; // Exit selection mode after valid selection
                              cropperContainer.style.cursor = 'default'; // Change cursor back
                          } else {
                              // Invalid selection (clamped dimensions became 0 or less)
                              window.finalScaledCrop = null;
                              cropSelectionOverlay.style.display = 'none'; // Hide overlay if selection is invalid
                              cropAndDownloadBtn.disabled = true;
                              newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                              console.log("[CROPPER] Invalid selection (dimensions became <= 0 after clamping).");
                              alert("Please select a valid crop area with positive width and height.");
                              // Stay in selection mode? Or exit? Let's exit and require re-clicking Select Area.
                              isSelectingCropArea = false;
                              cropperContainer.style.cursor = 'default';
                              selectAreaBtn.disabled = !(window.originalCropFile && originalCropImage.complete && originalCropImage.naturalHeight > 0); // Re-enable Select Area button
                           }
                      } else {
                          // No area selected (width or height was 0) or missing elements
                          window.finalScaledCrop = null;
                          cropSelectionOverlay.style.display = 'none'; // Hide overlay
                          cropAndDownloadBtn.disabled = true;
                          newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                          console.log("[CROPPER] No area selected or elements missing (width/height 0).");
                          // Stay in selection mode? Or exit? Let's exit and require re-clicking Select Area.
                          isSelectingCropArea = false;
                          cropperContainer.style.cursor = 'default';
                           selectAreaBtn.disabled = !(window.originalCropFile && originalCropImage.complete && originalCropImage.naturalHeight > 0); // Re-enable Select Area button
                           // Only show alert if they were actually dragging to select
                           if (e.clientX !== startX || e.clientY !== startY) { // Crude check if there was movement
                               alert("Please drag to select a crop area.");
                           }
                      }
                 });


                cropAndDownloadBtn.addEventListener('click', () => {
                    console.log("[CROPPER] Crop button clicked.");
                     // Use the global file variable and the loaded original image object
                     if (window.originalCropFile && originalCropImage && originalCropImage.complete && originalCropImage.naturalWidth > 0 && window.finalScaledCrop) {
                         performCrop(window.originalCropFile, originalCropImage);
                     } else { console.warn("[CROPPER] Crop button clicked with invalid state."); alert("Please select an image file and define a crop area first."); }
                });

                selectAreaBtn.disabled = true; // Disabled by default until file is loaded
                cropAndDownloadBtn.disabled = true; // Disabled by default until area is selected

                addDropZoneListeners('image-cropper', 'cropDropZone', 'cropImageFile'); console.log("[INIT:CROPPER] finished.");
            }


            function setupImageRotateFlipListeners() {
                 console.log("[INIT:ROTATEFLIP] Setting up listeners.");
                 const rotateLeftBtn = document.getElementById('rotateLeftBtn'); const rotateRightBtn = document.getElementById('rotateRightBtn'); const flipHorizontalBtn = document.getElementById('flipHorizontalBtn'); const flipVerticalBtn = document.getElementById('flipVerticalBtn'); const originalDimensionsSpan = document.getElementById('originalRotateFlipDimensions'); const originalSizeSpan = document.getElementById('rotateFlipOriginalSize'); const newRotateFlipDimensionsSpan = document.getElementById('newRotateFlipDimensions'); const newRotateFlipSizeSpan = document.getElementById('newRotateFlipSize'); const rotatedFlippedImage = document.getElementById('rotatedFlippedImage'); const downloadLink = document.getElementById('rotateFlipDownloadLink'); const downloadMessage = document.getElementById('rotateFlipDownloadMessage'); const processingMsg = document.getElementById('rotateFlipProcessingMsg');
                if (!rotateLeftBtn || !rotateRightBtn || !flipHorizontalBtn || !flipVerticalBtn || !originalDimensionsSpan || !originalSizeSpan || !newRotateFlipDimensionsSpan || !newRotateFlipSizeSpan || !rotatedFlippedImage || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:ROTATEFLIP] Missing required UI elements."); return; }

                 function performTransform(transformType) {
                     console.log(`[ROTATEFLIP] performTransform started: ${transformType}`);
                      // Use the global file variable and the loaded current image object
                      if (!window.originalRotateFlipFile || !currentRotateFlipImage || !currentRotateFlipImage.src || !currentRotateFlipImage.complete || !(currentRotateFlipImage.naturalWidth > 0) || !(currentRotateFlipImage.naturalHeight > 0)) { console.error("[ROTATEFLIP] Transform prerequisites not met."); alert("Please select and load an image first."); const buttons = document.querySelectorAll('#image-rotate-flip-section .rotate-flip-controls button'); buttons.forEach(btn => btn.disabled = !(window.originalRotateFlipFile && originalRotateFlipImage.complete && originalRotateFlipImage.naturalHeight > 0)); if(processingMsg) processingMsg.style.display = 'none'; return; }

                      const buttons = document.querySelectorAll('#image-rotate-flip-section .rotate-flip-controls button'); buttons.forEach(btn => btn.disabled = true); processingMsg.style.display = 'block'; console.log("[ROTATEFLIP] Processing message shown.");

                      // Revoke old blob URL before clearing
                       if (rotatedFlippedImage.src && rotatedFlippedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(rotatedFlippedImage.src); } catch (e) { console.error(`[ROTATEFLIP] Error revoking old rotated preview blob ${rotatedFlippedImage.src}:`, e); } }
                      rotatedFlippedImage.src = ''; rotatedFlippedImage.alt = ''; rotatedFlippedImage.style.display = 'none';

                       // Revoke old blob URL before clearing download link
                       if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[ROTATEFLIP] Error revoking old download blob ${downloadLink.href}:`, e); } }
                      downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';

                      newRotateFlipDimensionsSpan.textContent = '-'; newRotateFlipSizeSpan.textContent = '-'; console.log("[ROTATEFLIP] Previous output cleared.");

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      let iw = currentRotateFlipImage.naturalWidth; let ih = currentRotateFlipImage.naturalHeight; let ow, oh;

                      // Determine canvas dimensions based on transform
                      if (transformType === 'rotateLeft' || transformType === 'rotateRight') {
                          ow = ih; oh = iw;
                      } else { // flipHorizontal or flipVertical
                          ow = iw; oh = ih;
                      }
                      canvas.width = ow; canvas.height = oh; console.log(`[ROTATEFLIP] Canvas created: ${ow}x${oh}.`);

                       // For non-transparent formats, draw white background
                       const mimeType = window.originalRotateFlipFile.type.startsWith('image/') ? window.originalRotateFlipFile.type : 'image/jpeg';
                       if (mimeType !== 'image/png' && mimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                           ctx.fillStyle = '#fff';
                           ctx.fillRect(0, 0, canvas.width, canvas.height);
                           console.log("[ROTATEFLIP] Canvas filled white for non-PNG/WebP output.");
                       } else {
                            ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                           console.log("[ROTATEFLIP] Canvas cleared for PNG/WebP output.");
                       }

                      // Apply transform and draw
                      ctx.translate(ow / 2, oh / 2); // Move origin to center
                      if (transformType === 'rotateRight') ctx.rotate(90 * Math.PI / 180);
                      else if (transformType === 'rotateLeft') ctx.rotate(-90 * Math.PI / 180);
                      else if (transformType === 'flipHorizontal') ctx.scale(-1, 1);
                      else if (transformType === 'flipVertical') ctx.scale(1, -1);

                      ctx.drawImage(currentRotateFlipImage, -iw / 2, -ih / 2); // Draw image centered

                      ctx.setTransform(1, 0, 0, 1, 0, 0); console.log("[ROTATEFLIP] Canvas transform reset.");


                      canvas.toBlob((blob) => {
                          console.log("[ROTATEFLIP] Canvas toBlob callback fired.");
                          if (blob) {
                              console.log("[ROTATEFLIP] Blob created. Size:", blob.size);
                              const newUrl = URL.createObjectURL(blob);
                              const previousCurrentUrl = currentRotateFlipImage.src; // Capture URL *before* setting new src
                              currentRotateFlipImage.onload = () => {
                                   console.log(`[ROTATEFLIP] currentRotateFlipImage loaded from new blob URL: ${newUrl}`);
                                   // Update UI *after* the new current image is loaded
                                  updateRotateFlipOutput(blob, newUrl, window.originalRotateFlipFile.name, currentRotateFlipImage.naturalWidth, currentRotateFlipImage.naturalHeight, window.originalRotateFlipFile.size, mimeType);

                                  buttons.forEach(btn => btn.disabled = false); // Re-enable buttons

                                  // Revoke the *previous* current image blob URL after the *new* one has successfully loaded
                                  if (previousCurrentUrl && previousCurrentUrl.startsWith('blob:')) {
                                      try { URL.revokeObjectURL(previousCurrentUrl); console.log(`[ROTATEFLIP] Revoked previous current blob: ${previousCurrentUrl}`); } catch (e) { console.error(`[ROTATEFLIP] Error revoking previous current blob ${previousCurrentUrl}:`, e); }
                                  }
                                   console.log(`[ROTATEFLIP] Transform (${transformType}) successful.`);
                              };
                              currentRotateFlipImage.onerror = (e) => {
                                   console.error("[ROTATEFLIP] Error loading transformed state into currentRotateFlipImage.", e);
                                   alert("Error displaying transformed image.");
                                   buttons.forEach(btn => btn.disabled = false); // Re-enable buttons on error
                                   // Revoke the new blob URL we failed to load
                                   if (newUrl && newUrl.startsWith('blob:')) { try { URL.revokeObjectURL(newUrl); } catch (e) { console.error(`[ROTATEFLIP] Error revoking new blob URL ${newUrl} after load error:`, e); } }
                                   // The rotatedFlippedImage src will be broken, resetToolState can clean it up later.
                                   if(processingMsg) processingMsg.style.display = 'none';
                              };
                               // Set the src of currentRotateFlipImage to the new blob URL. This triggers its onload/onerror.
                              currentRotateFlipImage.src = newUrl;
                              console.log(`[ROTATEFLIP] Set currentImage src to new blob URL: ${currentRotateFlipImage.src}. Waiting for onload...`);

                          } else {
                              console.error("[ROTATEFLIP] canvas.toBlob failed.");
                              alert("Image transformation failed.");
                              newRotateFlipDimensionsSpan.textContent = 'Failed'; newRotateFlipSizeSpan.textContent = 'Failed';
                              buttons.forEach(btn => btn.disabled = false); // Re-enable buttons on failure
                              if(processingMsg) processingMsg.style.display = 'none'; console.log("[ROTATEFLIP] Processing finished (toBlob failed).");
                          }

                      }, mimeType); console.log(`[ROTATEFLIP] Calling canvas.toBlob with type ${mimeType}...`);
                 }

                 function updateRotateFlipOutput(resultBlob, objectUrl, originalName, newWidth, newHeight, originalSize, mimeType) {
                     console.log("[ROTATEFLIP] updateRotateFlipOutput started.");
                     if (!resultBlob || !objectUrl) { console.error("[ROTATEFLIP] updateRotateFlipOutput called with no blob or objectUrl."); return; }

                      // Revoke old blob URLs before setting new ones
                       if (rotatedFlippedImage.src && rotatedFlippedImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(rotatedFlippedImage.src); } catch (e) { console.error(`[ROTATEFLIP] Error revoking old rotated preview blob ${rotatedFlippedImage.src}:`, e); } }
                       if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[ROTATEFLIP] Error revoking old download blob ${downloadLink.href}:`, e); } }


                      const resultSize = resultBlob.size;
                      newRotateFlipSizeSpan.textContent = formatBytes(resultSize); console.log(`[ROTATEFLIP] New size: ${newRotateFlipSizeSpan.textContent}`);
                      newRotateFlipDimensionsSpan.textContent = `${newWidth}x${newHeight}`; console.log(`[ROTATEFLIP] New dimensions: ${newWidth}x${newHeight}.`);

                      // rotatedFlippedImage should display the content of currentRotateFlipImage
                      rotatedFlippedImage.src = currentRotateFlipImage.src;
                      rotatedFlippedImage.style.display = 'block';
                      rotatedFlippedImage.alt = `Transformed Image (${originalName})`; console.log("[ROTATEFLIP] Preview image displayed.");

                      const previewSection = document.getElementById('rotateFlipImagePreview'); if(previewSection) previewSection.style.display = 'block'; else console.warn("[ROTATEFLIP] preview section not found");

                      // Download link should point to the content of currentRotateFlipImage
                      downloadLink.href = currentRotateFlipImage.src;
                      const baseName = originalName.replace(/\.[^/.]+$/, "");
                      let finalExtension = mimeType.split('/')[1];
                      if (finalExtension === 'jpeg') finalExtension = 'jpg';
                      downloadLink.download = `transformed_${baseName}.${finalExtension}`;
                      downloadLink.style.display = 'inline-block';
                      downloadMessage.style.display = 'block'; console.log(`[ROTATEFLIP] Download link set: ${currentRotateFlipImage.src}`);

                     console.log("[ROTATEFLIP] updateRotateFlipOutput finished.");
                 }

                 rotateLeftBtn.addEventListener('click', () => performTransform('rotateLeft'));
                 rotateRightBtn.addEventListener('click', () => performTransform('rotateRight'));
                 flipHorizontalBtn.addEventListener('click', () => performTransform('flipHorizontal'));
                 flipVerticalBtn.addEventListener('click', () => performTransform('flipVertical'));

                 rotateLeftBtn.disabled = true; rotateRightBtn.disabled = true; flipHorizontalBtn.disabled = true; flipVerticalBtn.disabled = true; // Disabled by default

                 addDropZoneListeners('image-rotate-flip', 'rotateFlipDropZone', 'rotateFlipImageFile'); console.log("[INIT:ROTATEFLIP] finished.");
             }


            // --- Image Filters JavaScript ---
             function setupImageFiltersListeners() {
                  console.log("[INIT:FILTERS] Setting up listeners.");
                 const filterTypeSelect = document.getElementById('filterType'); const applyFilterBtn = document.getElementById('applyFilterBtn'); const originalDimensionsSpan = document.getElementById('originalFilterDimensions'); const originalSizeSpan = document.getElementById('filterOriginalSize'); const newFilterSizeSpan = document.getElementById('newFilterSize'); const filteredImage = document.getElementById('filteredImage'); const downloadLink = document.getElementById('filterDownloadLink'); const downloadMessage = document.getElementById('filterDownloadMessage'); const processingMsg = document.getElementById('filterProcessingMsg');

                 if (!filterTypeSelect || !applyFilterBtn || !originalDimensionsSpan || !originalSizeSpan || !newFilterSizeSpan || !filteredImage || !downloadLink || !downloadMessage || !processingMsg) { console.error("[INIT:FILTERS] Missing required UI elements."); return; }

                 function applyFilter(filterType) {
                     console.log(`[FILTERS] applyFilter started: ${filterType}`);
                     const file = window.originalFilterFile;
                     const imageObj = originalFilterImage; // Always filter from the original loaded image

                      const isImageReady = file && imageObj && imageObj.src && imageObj.complete && imageObj.naturalWidth > 0;

                      if (!isImageReady) {
                          console.error("[FILTERS] Filter prerequisites not met.");
                          alert("Please select and load an image first.");
                           // Re-enable controls regardless of error state after alert
                          if(filterTypeSelect) filterTypeSelect.disabled = !isImageReady;
                          if(applyFilterBtn) applyFilterBtn.disabled = !(isImageReady && filterTypeSelect.value !== 'none');
                          if(processingMsg) processingMsg.style.display = 'none';
                          return;
                      }

                       // Revoke the previously displayed blob URL *before* creating or setting a new one
                       const prevFilteredSrc = filteredImage.src;
                       if (prevFilteredSrc && prevFilteredSrc.startsWith('blob:')) {
                           console.log(`[FILTERS] Revoking previous filtered blob URL: ${prevFilteredSrc}`);
                           try { URL.revokeObjectURL(prevFilteredSrc); } catch (e) { console.error(`[FILTERS] Error revoking previous filtered blob ${prevFilteredSrc}:`, e); }
                       }

                      if (filterType === 'none') {
                           console.log("[FILTERS] 'None' selected, reverting.");
                           // Create a *new* blob URL from the original file for reversion
                           if (file) {
                               try {
                                   const originalBlobUrlForRevert = URL.createObjectURL(file);
                                    console.log(`[FILTERS] Created new blob URL from original file for revert: ${originalBlobUrlForRevert}`);

                                    filteredImage.src = originalBlobUrlForRevert;
                                    filteredImage.alt = `Original Image (${file.name})`;
                                    filteredImage.style.display = 'block';

                                    // Update download link to the original source
                                    downloadLink.href = originalBlobUrlForRevert;
                                    const baseName = file.name.replace(/\.[^/.]+$/, "");
                                    const mimeType = file.type; // Use original file type
                                    let finalExtension = mimeType.split('/')[1]; if (finalExtension === 'jpeg') finalExtension = 'jpg';
                                    downloadLink.download = `${baseName}.${finalExtension}`; // Use original file name
                                    downloadLink.style.display = 'inline-block';
                                    downloadMessage.style.display = 'block';
                                    newFilterSizeSpan.textContent = formatBytes(file.size); // Use original size
                                    console.log("[FILTERS] Reverted to original state using new blob URL from file.");
                               } catch (e) {
                                    console.error("[FILTERS] Error creating blob URL from original file for revert:", e);
                                    alert("Error reverting to original image.");
                                    newFilterSizeSpan.textContent = 'Error';
                                    // Hide download link and clear preview src on error
                                    if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking error download blob ${downloadLink.href}:`, e); } }
                                    downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                                    filteredImage.src = '';
                                    filteredImage.style.display = 'none';
                               }
                          } else {
                              console.error("[FILTERS] Original file object is not available when reverting to 'None'. Cannot revert.");
                               alert("Cannot revert: Original file data missing.");
                               newFilterSizeSpan.textContent = 'Error';
                               // Hide download link and clear preview src
                               if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking error download blob ${downloadLink.href}:`, e); } }
                               downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                               filteredImage.src = '';
                               filteredImage.style.display = 'none';
                           }

                           filterTypeSelect.disabled = false; // Re-enable select regardless of revert success
                           applyFilterBtn.disabled = true; // Disable Apply button as 'None' doesn't need re-applying

                           if(processingMsg) processingMsg.style.display = 'none'; console.log("[FILTERS] Processing finished (None).");
                           return; // Exit function after handling 'none'
                      }

                      // Process filter (non-'none' filter)
                      filterTypeSelect.disabled = true; applyFilterBtn.disabled = true; processingMsg.style.display = 'block'; console.log("[FILTERS] Processing message shown.");

                      filteredImage.src = ''; filteredImage.alt = ''; filteredImage.style.display = 'none'; // Hide preview during processing
                      // Download link hidden by revocation at the start of the function
                      newFilterSizeSpan.textContent = '-'; console.log("[FILTERS] Previous output cleared.");

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      const width = imageObj.naturalWidth; const height = imageObj.naturalHeight; canvas.width = width; canvas.height = height; console.log(`[FILTERS] Canvas created: ${width}x${height}.`);

                       const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                       // For non-transparent formats, draw white background
                       if (mimeType !== 'image/png' && mimeType !== 'image/webp') { // Only fill white if target is not PNG/WebP
                           ctx.fillStyle = '#fff';
                           ctx.fillRect(0, 0, canvas.width, canvas.height);
                           console.log("[FILTERS] Canvas filled white for non-PNG/WebP output.");
                       } else {
                            ctx.clearRect(0, 0, canvas.width, canvas.height); // Ensure transparency is preserved
                           console.log("[FILTERS] Canvas cleared for PNG/WebP output.");
                       }


                      // Draw the *original* image onto the canvas for filtering
                      ctx.drawImage(imageObj, 0, 0, width, height); console.log("[FILTERS] Original image drawn to canvas.");

                      try {
                           let imageData = ctx.getImageData(0, 0, width, height); let pixels = imageData.data;
                           switch(filterType) {
                               case 'grayscale': for (let i = 0; i < pixels.length; i += 4) { const avg = Math.round(0.2126 * pixels[i] + 0.7152 * pixels[i + 1] + 0.0722 * pixels[i + 2]); pixels[i] = avg; pixels[i + 1] = avg; pixels[i + 2] = avg; } break;
                               case 'sepia': for (let i = 0; i < pixels.length; i += 4) { const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2]; pixels[i] = Math.min(255, Math.round(0.393 * r + 0.769 * g + 0.189 * b)); pixels[i + 1] = Math.min(255, Math.round(0.349 * r + 0.686 * g + 0.168 * b)); pixels[i + 2] = Math.min(255, Math.round(0.272 * r + 0.534 * g + 0.131 * b)); } break;
                               case 'invert': for (let i = 0; i < pixels.length; i += 4) { pixels[i] = 255 - pixels[i]; pixels[i + 1] = 255 - pixels[i + 1]; pixels[i + 2] = 255 - pixels[i + 2]; } break;
                               case 'red': for (let i = 0; i < pixels.length; i += 4) { pixels[i + 1] = 0; pixels[i + 2] = 0; } break; // Keep Red, remove Green and Blue
                               case 'green': for (let i = 0; i < pixels.length; i += 4) { pixels[i] = 0; pixels[i + 2] = 0; } break; // Keep Green, remove Red and Blue
                               case 'blue': for (let i = 0; i < pixels.length; i += 4) { pixels[i] = 0; pixels[i + 1] = 0; } break; // Keep Blue, remove Red and Green
                                // Add more filter implementations here
                                default: console.warn(`[FILTERS] Unknown filter type: ${filterType}`); break;
                           } ctx.putImageData(imageData, 0, 0); console.log(`[FILTERS] Filter '${filterType}' applied to canvas.`);
                       } catch (error) {
                           console.error(`[FILTERS] Error applying filter '${filterType}':`, error);
                           alert(`Could not apply filter: ${error.message}`);
                            // Re-enable controls and hide processing message on error
                           const isImageReady = window.originalFilterFile && originalFilterImage.complete && originalFilterImage.naturalHeight > 0;
                           if(filterTypeSelect) filterTypeSelect.disabled = !isImageReady;
                           if(applyFilterBtn) applyFilterBtn.disabled = !(isImageReady && filterTypeSelect.value !== 'none');
                           if(processingMsg) processingMsg.style.display = 'none';
                           return;
                       }

                       const outputMimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg'; // Use original type or default to jpeg
                       const outputQuality = 0.85; // Quality for lossy formats (JPG, WebP)

                       getBlobFromCanvas(canvas, outputMimeType, outputQuality).then(blob => {
                           console.log("[FILTERS] Canvas toBlob callback fired.");
                           if (blob) {
                                console.log("[FILTERS] Blob created. Size:", blob.size);
                                const newObjectUrl = URL.createObjectURL(blob);
                                console.log(`[FILTERS] Created new blob URL for filtered image: ${newObjectUrl}`);

                                // Update the preview image src directly
                                filteredImage.src = newObjectUrl;
                                filteredImage.alt = `Filtered Image (${file.name})`;
                                filteredImage.style.display = 'block';

                                // Update download link and info
                                updateFilterOutput(blob, newObjectUrl, file.name, file.size, outputMimeType);

                                filterTypeSelect.disabled = false;
                                applyFilterBtn.disabled = filterTypeSelect.value === 'none'; // Should be false here
                                console.log(`[FILTERS] Filter (${filterType}) applied, new blob URL set to preview.`);

                           } else {
                                console.error("[FILTERS] canvas.toBlob failed during filtering.");
                                alert("Image filtering failed.");
                                newFilterSizeSpan.textContent = 'Failed';
                                // Ensure preview is hidden/cleared on failure
                                if (filteredImage.src && filteredImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(filteredImage.src); } catch (e) { console.error(`[FILTERS] Error revoking failed blob ${filteredImage.src}:`, e); } }
                                filteredImage.src = ''; filteredImage.style.display = 'none';
                                // Hide download link
                                if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking failed download blob ${downloadLink.href}:`, e); } }
                                downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                           }
                            // Re-enable controls and hide processing message regardless of success/failure
                           const isImageReady = window.originalFilterFile && originalFilterImage.complete && originalFilterImage.naturalHeight > 0;
                           if(filterTypeSelect) filterTypeSelect.disabled = !isImageReady;
                           if(applyFilterBtn) applyFilterBtn.disabled = !(isImageReady && filterTypeSelect.value !== 'none');
                           if(processingMsg) processingMsg.style.display = 'none'; console.log("[FILTERS] Processing finished (toBlob callback).");

                       }).catch(error => {
                           console.error("[FILTERS] Error converting canvas to blob:", error);
                           alert("An error occurred during image processing.");
                           newFilterSizeSpan.textContent = 'Error';
                            // Ensure preview is hidden/cleared on error
                           if (filteredImage.src && filteredImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(filteredImage.src); } catch (e) { console.error(`[FILTERS] Error revoking error blob ${filteredImage.src}:`, e); } }
                           filteredImage.src = ''; filteredImage.style.display = 'none';
                            // Hide download link
                            if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking error download blob ${downloadLink.href}:`, e); } }
                            downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                           // Re-enable controls and hide processing message
                           const isImageReady = window.originalFilterFile && originalFilterImage.complete && originalFilterImage.naturalHeight > 0;
                           if(filterTypeSelect) filterTypeSelect.disabled = !isImageReady;
                           if(applyFilterBtn) applyFilterBtn.disabled = !(isImageReady && filterTypeSelect.value !== 'none');
                           if(processingMsg) processingMsg.style.display = 'none'; console.log("[FILTERS] Processing finished (catch block).");
                       });
                       console.log(`[FILTERS] Calling getBlobFromCanvas...`);
                 }

                 // This function now primarily updates the info/download link for NON-'none' filters
                 function updateFilterOutput(resultBlob, objectUrl, originalName, originalSize, mimeType) {
                     console.log("[FILTERS] updateFilterOutput started (for non-'none' filter results).");
                     if (!resultBlob || !objectUrl) { console.error("[FILTERS] updateFilterOutput called with no blob or objectUrl."); return; }

                      // Revoke old download blob URL before setting new one
                      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking old download blob ${downloadLink.href}:`, e); } }

                      const resultSize = resultBlob.size;
                      newFilterSizeSpan.textContent = formatBytes(resultSize); console.log(`[FILTERS] New size: ${newFilterSizeSpan.textContent}`);

                      // The filteredImage src is already set by applyFilter

                      const previewSection = document.getElementById('filterImagePreview'); if(previewSection) previewSection.style.display = 'block'; else console.warn("[FILTERS] preview section not found");

                      // Check if a valid blob URL was provided (should be for non-none)
                      if (objectUrl && objectUrl.startsWith('blob:')) {
                         downloadLink.href = objectUrl;
                         const baseName = originalName.replace(/\.[^/.]+$/, "");
                         let finalExtension = mimeType.split('/')[1];
                         if (finalExtension === 'jpeg') finalExtension = 'jpg';
                         downloadLink.download = `filtered_${baseName}.${finalExtension}`; // Use 'filtered_' prefix
                         downloadLink.style.display = 'inline-block';
                         downloadMessage.style.display = 'block';
                         console.log(`[FILTERS] Download link set: ${objectUrl}`);
                      } else {
                         // This case should not happen for non-'none' successful results, but good fallback
                         downloadLink.href = '#';
                         downloadLink.style.display = 'none';
                         downloadLink.removeAttribute('download');
                         downloadMessage.style.display = 'none';
                         console.warn("[FILTERS] Download link hidden (invalid objectUrl).");
                      }
                     console.log("[FILTERS] updateFilterOutput finished.");
                 }

                 filterTypeSelect.addEventListener('change', () => {
                      console.log("[FILTERS] Filter select changed.");
                      const selectedFilter = filterTypeSelect.value;
                      const isImageReady = window.originalFilterFile && originalFilterImage && originalFilterImage.src && originalFilterImage.complete && originalFilterImage.naturalHeight > 0;

                      // Enable/disable apply button
                      // Apply button is only for non-'none' filters
                      applyFilterBtn.disabled = !(isImageReady && selectedFilter !== 'none');
                      console.log(`[FILTERS] Apply button enabled status: ${!applyFilterBtn.disabled}`);

                      // Automatically apply 'none' filter if selected and image is ready
                      if (isImageReady && selectedFilter === 'none') {
                          console.log("[FILTERS] 'None' filter selected, applying...");
                          applyFilter('none'); // This will handle UI updates and download link
                      } else if (isImageReady && selectedFilter !== 'none') {
                           // If a non-'none' filter is selected, clear previous output and wait for Apply button click
                           console.log(`[FILTERS] Non-'none' filter '${selectedFilter}' selected. Ready to apply.`);
                            // Clear previous output and download link state here, similar to start of applyFilter
                            const prevFilteredSrc = filteredImage.src;
                            if (prevFilteredSrc && prevFilteredSrc.startsWith('blob:')) {
                                console.log(`[FILTERS] Revoking previous filtered blob URL on filter change: ${prevFilteredSrc}`);
                                try { URL.revokeObjectURL(prevFilteredSrc); } catch (e) { console.error(`[FILTERS] Error revoking previous filtered blob ${prevFilteredSrc}:`, e); }
                            }
                            filteredImage.src = ''; filteredImage.alt = ''; filteredImage.style.display = 'none';
                            if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking download blob ${downloadLink.href}:`, e); } }
                            downloadLink.style.display = 'none'; downloadLink.removeAttribute('download'); downloadMessage.style.display = 'none';
                            newFilterSizeSpan.textContent = '-';

                      } else {
                          // Image is not ready, disable apply button and ensure no preview/download
                           console.log("[FILTERS] Image not ready, controls disabled.");
                           if(applyFilterBtn) applyFilterBtn.disabled = true;
                           if (filteredImage.src && filteredImage.src.startsWith('blob:')) { try { URL.revokeObjectURL(filteredImage.src); } catch (e) { console.error(`[FILTERS] Error revoking preview blob ${filteredImage.src}:`, e); } }
                           filteredImage.src = ''; filteredImage.style.display = 'none';
                           if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) { console.error(`[FILTERS] Error revoking download blob ${downloadLink.href}:`, e); } }
                           downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                           newFilterSizeSpan.textContent = '-';
                      }
                 });

                 applyFilterBtn.addEventListener('click', () => {
                      console.log("[FILTERS] Apply Filter button clicked.");
                      const selectedFilter = filterTypeSelect.value;
                      const isImageReady = window.originalFilterFile && originalFilterImage && originalFilterImage.src && originalFilterImage.complete && originalFilterImage.naturalHeight > 0;

                      if (isImageReady && selectedFilter && selectedFilter !== 'none' && !applyFilterBtn.disabled) {
                           applyFilter(selectedFilter); // Apply the selected non-'none' filter
                      } else {
                           console.warn("[FILTERS] Apply Filter button clicked with invalid state.");
                           alert("Please select an image and a filter other than 'None', then click Apply.");
                      }
                 });

                 filterTypeSelect.disabled = true; applyFilterBtn.disabled = true; // Disabled by default

                 addDropZoneListeners('image-filters', 'filterDropZone', 'filterImageFile'); console.log("[INIT:FILTERS] finished.");
             }


            // --- Setup all tool listeners (called inside DOMContentLoaded) ---
            setupImageCompressorListeners();
            setupImageResizerListeners();
            setupImageConverterListeners();
            setupImageCropperListeners();
            setupImageRotateFlipListeners();
            setupImageFiltersListeners();
             console.log("[GLOBAL] All tool listener setup functions called.");


            // Initial load: Handle the current hash or show homepage
            handleNavigation();

            // Listen for hash changes
            window.addEventListener('hashchange', handleNavigation);

            // Add explicit click handlers for navigation links
            navLinks.forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    const targetHash = anchor.getAttribute('href');
                    if (targetHash && targetHash.startsWith('#')) {
                        if (window.location.hash !== targetHash) {
                             e.preventDefault();
                             console.log(`[NAV] Nav link clicked (${targetHash}). Preventing default scroll, updating hash.`);
                             window.location.hash = targetHash;
                        } else {
                             console.log(`[NAV] Nav link clicked (${targetHash}) for current section. Allowing default scroll.`);
                             // If it's the same hash, still scroll to the top of the section, after header
                             if (targetHash !== '#homepage-section') { // Don't re-scroll for homepage if already there
                                const targetSection = document.getElementById(targetHash.substring(1));
                                if (targetSection) {
                                    e.preventDefault(); // Prevent default jump
                                    const headerHeight = document.querySelector('header')?.offsetHeight || 60;
                                    const targetScrollTop = Math.max(0, targetSection.offsetTop - headerHeight);
                                    window.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
                                }
                             }
                        }
                    }
                });
            });


            // Optional: Clean up Blob URLs when the page is closed or navigated away
            window.addEventListener('beforeunload', () => {
                console.log("[GLOBAL] Attempting to revoke Blob URLs before unload.");
                // Collect all potential blob URLs currently in use by img src or a href
                const urlsToRevoke = new Set();

                // Check img elements currently visible or potentially holding blobs
                document.querySelectorAll('img[src^="blob:"]').forEach(img => { if(img.src) urlsToRevoke.add(img.src); });
                 // Check a elements (download links) currently visible or potentially holding blobs
                document.querySelectorAll('a[href^="blob:"]').forEach(a => { if(a.href) urlsToRevoke.add(a.href); });

                // Check global Image object sources
                 [originalCompressImage, originalResizeImage, originalConvertImage, originalCropImage, originalRotateFlipImage, currentRotateFlipImage, originalFilterImage].forEach(imgObj => {
                     if (imgObj && typeof imgObj.src === 'string' && imgObj.src.startsWith('blob:')) { urlsToRevoke.add(imgObj.src); }
                 });

                // Revoke all collected unique blob URLs
                urlsToRevoke.forEach(url => {
                     try { URL.revokeObjectURL(url); console.log(`[GLOBAL] Revoked blob URL: ${url}`); } catch (e) { console.error(`[GLOBAL] Failed to revoke Blob URL ${url}:`, e); }
                });
                 console.log("[GLOBAL] Blob URL cleanup attempted.");
            });


             // Contact Form Placeholder - Prevent default submission
             const contactForm = document.getElementById('contactForm');
             if (contactForm) {
                 // Keep the listener but remove the preventDefault and alert/reset
                 contactForm.addEventListener('submit', function(e) {
                     // Only prevent default if the action hasn't been set to a real endpoint
                     if (contactForm.action === window.location.href + '#contactForm' || contactForm.action === '#' || contactForm.action === window.location.href) {
                          e.preventDefault();
                          alert("The contact form is not yet configured to send messages. Please see the note below the form for instructions.");
                          console.warn("Contact form submission prevented because action is not configured.");
                     } else {
                         console.log("Contact form submitting to configured endpoint:", contactForm.action);
                         // Allow default form submission to the 'action' URL
                         // The third-party service or backend script will handle the rest
                     }
                 });
             }

        }); // End of DOMContentLoaded


    </script>

</body>
</html>
