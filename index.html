<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeImagePDFTools - Modern UI (DEBUG v2)</title> <!-- Changed Title -->
    <meta name="description" content="Free online tools for image compression, resizing, conversion, cropping, filters, JPG to PDF, PDF to JPG, PDF Merge, and PDF Split with previews. Optimize photos & documents.">
    <meta name="keywords" content="online tools, free tools, image compressor, image resizer, image converter, JPG, PNG, WebP, image crop, rotate image, image filters, JPG to PDF, PDF to JPG, merge PDF, split PDF, PDF tools, optimize photos, image preview, pdf preview, side-by-side preview">
    <meta name="author" content="FreeImagePDFTools">

    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">

    <meta property="og:title" content="FreeImagePDFTools | Free Image & PDF Tools">
    <meta property="og:description" content="Free online tools for image compression, resizing, conversion, cropping, filters, JPG to PDF, PDF to JPG, PDF Merge, PDF Split with previews, and more.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="YOUR_WEBSITE_URL_HERE"> <!-- Replace with your URL -->

    <style>
        /* --- MODERN UI STYLES --- */
        :root {
            --primary-color: #1abc9c; /* Teal */
            --primary-darker: #16a085;
            --secondary-color: #7f8c8d; /* Gray */
            --secondary-darker: #606f70;
            --accent-color: #e67e22; /* Orange */
            --light-bg: #f4f7f6; /* Very light grey-green */
            --content-bg: #ffffff;
            --dark-text: #2c3e50; /* Dark blue/gray */
            --light-text: #ffffff;
            --gray-text: #95a5a6; /* Lighter gray */
            --border-color: #ecf0f1; /* Light border */
            --success-color: #2ecc71; /* Green */
            --danger-color: #e74c3c; /* Red */
            --info-color: #3498db; /* Blue */

            --header-bg: var(--dark-text);
            --header-link-color: var(--primary-color);
            --header-link-hover: var(--light-text);

            --border-radius-sm: 0.3rem;
            --border-radius-md: 0.6rem;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 5px 15px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.1);

            --font-base-size: 16px;
            --line-height-base: 1.7;
            --padding-base: 1.5rem;
            --margin-base: 1.5rem;
        }

        /* --- Base & Reset --- */
        *, *::before, *::after { box-sizing: border-box; }
        html { font-size: var(--font-base-size); scroll-behavior: smooth; }
        body {
            font-family: 'Roboto', sans-serif;
            line-height: var(--line-height-base);
            margin: 0; padding: 0;
            background-color: var(--light-bg);
            color: var(--dark-text);
            padding-top: 70px; /* Adjust based on final header height */
            font-weight: 400;
        }

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            color: var(--light-text);
            padding: 0.8rem 0; /* Reduced vertical padding */
            position: fixed; width: 100%; top: 0; left: 0; z-index: 1000;
            box-shadow: var(--shadow-sm);
            transition: background-color 0.3s ease;
        }
        header .container {
            display: flex;
            justify-content: space-between; /* Align title left, nav right */
            align-items: center;
            max-width: 1200px; margin: 0 auto; padding: 0 var(--padding-base);
            box-shadow: none; /* Removed inner shadow */
        }
        header h1 {
            margin: 0; font-size: 1.6rem; color: var(--header-link-color); font-weight: 700;
        }
        header h1 a { color: inherit; text-decoration: none; }
        header nav ul { list-style: none; margin: 0; padding: 0; display: flex; gap: 1.5rem; }
        header nav a {
            color: var(--header-link-color);
            text-decoration: none; font-weight: 500;
            transition: color 0.3s ease, transform 0.2s ease;
            padding: 0.3rem 0;
            position: relative;
        }
        header nav a:hover { color: var(--header-link-hover); transform: translateY(-1px); }
        header nav a::after { /* Underline effect on hover */
            content: '';
            position: absolute;
            bottom: 0; left: 0;
            width: 0; height: 2px;
            background-color: var(--header-link-hover);
            transition: width 0.3s ease;
        }
        header nav a:hover::after { width: 100%; }

        /* --- General Layout & Typography --- */
        .container {
            max-width: 1140px; /* Slightly wider */
            margin: var(--margin-base) auto;
            padding: calc(var(--padding-base) * 1.5); /* More padding */
            background-color: var(--content-bg);
            box-shadow: var(--shadow-md);
            border-radius: var(--border-radius-md);
        }
        h1, h2, h3, h4 { color: var(--dark-text); margin-bottom: var(--margin-base); text-align: center; font-weight: 500; }
        h1 { font-size: 2.5rem; font-weight: 700;}
        h2 { font-size: 2rem; margin-top: calc(var(--margin-base) * 1.5); }
        h3 { font-size: 1.5rem; }
        p { color: var(--dark-text); margin-bottom: var(--margin-base); font-weight: 300; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.3s ease; }
        a:hover { color: var(--primary-darker); text-decoration: underline; }

        main > section { display: none; }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: var(--light-text);
            padding: 0.8rem 1.8rem;
            border-radius: var(--border-radius-md);
            text-align: center; border: none; cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            font-size: 1rem; line-height: 1.5; font-weight: 500;
            vertical-align: middle; text-decoration: none;
            box-shadow: var(--shadow-sm);
        }
        .btn:hover {
            background-color: var(--primary-darker);
            color: var(--light-text); transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        .btn-secondary { background-color: var(--secondary-color); }
        .btn-secondary:hover { background-color: var(--secondary-darker); }
        .btn-success { background-color: var(--success-color); }
        .btn-success:hover { background-color: #27ae60; } /* Slightly darker green */
        .btn:disabled {
            background-color: #bdc3c7; /* Lighter gray for disabled */
            color: #7f8c8d; cursor: not-allowed; transform: none; box-shadow: none;
        }

        /* --- Forms & Inputs --- */
        .tool-controls {
            margin-bottom: calc(var(--margin-base) * 1.5);
            display: flex; flex-wrap: wrap; gap: 1.5rem; /* Increased gap */
            align-items: center; justify-content: center;
            padding: var(--padding-base);
            background-color: var(--light-bg);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        .tool-controls label { font-weight: 500; margin-right: 0.5rem; color: var(--dark-text); }

        input[type="text"], input[type="number"], input[type="email"], select, textarea {
            padding: 0.8rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            font-size: 1rem; font-family: inherit;
            background-color: var(--content-bg);
            color: var(--dark-text);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            vertical-align: middle;
        }
        input[type="text"]:focus, input[type="number"]:focus, input[type="email"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(26, 188, 156, 0.2); /* Teal focus ring */
        }
        input[type="range"] {
            width: 100%; max-width: 300px; cursor: pointer; vertical-align: middle;
            accent-color: var(--primary-color); /* Modern way to style slider color */
        }
        select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 1rem center; background-size: 1em; padding-right: 3rem; cursor: pointer; }

        /* --- Drop Zone --- */
        .file-input-container { margin-bottom: var(--margin-base); text-align: center; }
        .drop-zone {
            border: 2px dashed var(--border-color); /* Lighter dash */
            border-radius: var(--border-radius-md);
            padding: 2.5rem; /* More padding */
            text-align: center; cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            color: var(--gray-text);
            max-width: 550px; margin: 1.5rem auto; /* Increased margin */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 180px; /* Taller */
            background-color: var(--content-bg);
        }
        .drop-zone p { margin: 0.5rem 0; font-weight: 300; }
        .drop-zone label {
             margin-top: 1rem; color: var(--primary-color); cursor: pointer; font-weight: 500; display: inline-block; padding: 0.5rem 1rem; border: 1px solid transparent; border-radius: var(--border-radius-sm); transition: background-color 0.2s ease, color 0.2s ease;
        }
        .drop-zone label:hover { background-color: rgba(26, 188, 156, 0.1); color: var(--primary-darker); }
        .drop-zone.drag-over {
            background-color: rgba(26, 188, 156, 0.05); /* Light teal background */
            border-color: var(--primary-color);
            border-style: solid;
        }
        input[type="file"] { display: none; }

        /* --- Info & Preview Sections --- */
        .image-info, .output-info, .file-list-display {
            margin-top: var(--margin-base);
            border-top: 1px solid var(--border-color);
            padding-top: var(--margin-base);
            display: none; /* JS controls visibility */
            background-color: var(--light-bg); /* Subtle background difference */
            padding: var(--padding-base);
            border-radius: var(--border-radius-md);
        }
        .image-info p, .output-info p { margin: 0.6rem 0; font-size: 0.95rem; }
        .image-info strong, .output-info strong { font-weight: 500; min-width: 150px; display: inline-block;}
        .file-list-display h4 { margin-bottom: 0.8rem; font-size: 1.1rem; font-weight: 500; }
        .file-list-display ul { list-style: decimal; padding-left: 25px; text-align: left; max-height: 180px; overflow-y: auto; border: 1px solid var(--border-color); padding: 15px; border-radius: var(--border-radius-sm); background-color: var(--content-bg); margin-top: 0.5rem;}
        .file-list-display li { margin-bottom: 0.5rem; font-size: 0.9rem; color: var(--secondary-color); }

        .image-preview, .pdf-tool-preview {
            margin-top: var(--margin-base); text-align: center; padding-top: var(--margin-base);
            border-top: 1px solid var(--border-color); display: none; /* JS controls visibility */
        }
         .image-preview + .image-info, /* Remove top border if info immediately follows */
         .pdf-tool-preview + .output-info,
         .pdf-tool-preview + .image-info {
             border-top: none; padding-top: 0; margin-top: 0; border-radius: 0 0 var(--border-radius-md) var(--border-radius-md); /* Adjust radius */
         }

        .preview-comparison { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 2rem; margin-top: 1rem; }
        .preview-comparison > div {
            flex: 1 1 350px; /* Allow more space */
            max-width: 48%; /* Slightly less than 50% for gap */
            text-align: center; min-height: 250px;
            background-color: var(--light-bg); /* Background for each pane */
            padding: var(--padding-base);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        .preview-comparison .preview-label { font-weight: 500; margin-bottom: 1rem; display: block; font-size: 1.1rem; color: var(--secondary-color); }

        .image-preview img, .pdf-tool-preview img {
            max-width: 100%; height: auto; border: 1px solid #ddd; padding: 5px;
            background-color: var(--content-bg); box-shadow: var(--shadow-sm);
            display: none; margin: 10px auto; border-radius: var(--border-radius-sm);
            vertical-align: middle;
        }
        .preview-comparison img {
            max-width: 100%; /* Allow image to fill its pane */ max-height: 450px; display: block; margin: 0 auto 1rem auto;
        }

        /* PDF specific previews */
        .pdf-thumbnails-container { max-height: 400px; overflow-y: auto; padding: 10px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); margin-top: 5px; min-height: 100px; background-color: var(--content-bg); }
        .pdf-thumbnails-container img { display: inline-block; max-height: 100px; max-width: 75px; margin: 5px; border: 1px solid #ccc; border-radius: var(--border-radius-sm); }
        .pdf-embed-preview { border: 1px solid var(--border-color); display: none; width: 100%; height: 500px; margin-top: 10px; background-color: var(--light-bg); border-radius: var(--border-radius-sm); }
        .preview-success-message { /* Used for download messages too */
            display: none;
            color: var(--success-color);
            margin-top: 15px; text-align: center; font-style: normal; font-weight: 500;
            padding: 0.8rem;
            border: 1px solid var(--success-color);
            border-radius: var(--border-radius-sm);
            background-color: #eafaf1; /* Lighter green */
            font-size: 0.95rem;
        }

        /* --- Image Cropper Tool Section --- */
        .cropper-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
            vertical-align: middle;
        }
        .crop-selection-overlay {
            position: absolute;
            border: 1px dashed var(--primary-darker);
            background-color: rgba(26, 188, 156, 0.2);
            box-sizing: border-box;
            display: none;
        }


        /* --- Homepage --- */
        #homepage-section .hero {
            text-align: center; margin-bottom: calc(var(--margin-base) * 2);
            padding: 3rem 1.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-darker));
            color: var(--light-text);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-lg);
        }
        #homepage-section .hero h2 { color: var(--light-text); margin-top: 0; font-size: 2.2rem; font-weight: 700; }
        #homepage-section .hero p { font-size: 1.2rem; opacity: 0.9; font-weight: 300; max-width: 700px; margin-left: auto; margin-right: auto; }
        #homepage-section .hero .btn { background-color: var(--light-text); color: var(--primary-darker); font-weight: 700; margin-top: 1rem; }
        #homepage-section .hero .btn:hover { background-color: #f8f9fa; color: var(--primary-color); }

        #homepage-section .tools-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem; margin-top: calc(var(--margin-base) * 1.5);
        }
        #homepage-section .tool-card {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            padding: calc(var(--padding-base) * 1.2);
            text-align: center; background-color: var(--content-bg);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex; flex-direction: column; justify-content: space-between;
            box-shadow: var(--shadow-sm);
        }
        #homepage-section .tool-card:hover { transform: translateY(-6px); box-shadow: var(--shadow-lg); }
        .tool-card .icon-container { font-size: 3.5rem; margin-bottom: 1rem; color: var(--primary-color); line-height: 1; }
        #homepage-section .tool-card h3 { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.3rem; font-weight: 700; }
        #homepage-section .tool-card h3 a { color: var(--dark-text); text-decoration: none; }
        #homepage-section .tool-card h3 a:hover { color: var(--primary-color); text-decoration: none;}
        #homepage-section .tool-card p { font-size: 0.9rem; color: var(--secondary-color); flex-grow: 1; margin-bottom: 1.5rem; font-weight: 300; }
        #homepage-section .tool-card .tool-link { margin-top: auto; display: block; }

        /* --- Other Sections (About, Contact, Privacy) --- */
        #about-section p, #privacy-section p { text-align: left; font-weight: 400; }
        #contact-section form { max-width: 600px; margin: 0 auto; display: flex; flex-direction: column; gap: 1.2rem; }
        #contact-section label { font-weight: 500; margin-bottom: 0.3rem; display: block; }
        #contact-section input[type="text"], #contact-section input[type="email"], #contact-section textarea { width: 100%; }
        #contact-section textarea { min-height: 150px; resize: vertical; }
        #contact-section button[type="submit"] { align-self: center; margin-top: 0.5rem; }

        /* --- Footer --- */
        footer { margin-top: calc(var(--margin-base) * 2); padding: 2rem var(--padding-base); background-color: var(--dark-text); color: var(--light-bg); text-align: center; }
        footer p { margin: 0.5rem 0; font-size: 0.9rem; opacity: 0.8; font-weight: 300; }
        footer a { color: var(--primary-color); }
        footer a:hover { color: var(--header-link-hover); }

        /* --- Ads Placeholder --- */
        .ad-container {
            width: 100%; margin: 2.5rem auto; text-align: center;
            background-color: var(--light-bg); padding: 1.5rem;
            border: 1px dashed var(--gray-text);
            min-height: 90px; display: flex; justify-content: center; align-items: center;
            font-size: 0.9rem; color: var(--gray-text); border-radius: var(--border-radius-sm);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            body { padding-top: 110px; /* Increased for potentially taller header */ }
            html { font-size: 15px; } /* Slightly smaller base font */
            .container { padding: var(--padding-base); margin: var(--padding-base); }
            h1 { font-size: 2rem; } h2 { font-size: 1.7rem; }
            #homepage-section .hero h2 { font-size: 1.8rem; }
            #homepage-section .hero p { font-size: 1rem; }

            header .container { flex-direction: column; gap: 0.8rem; padding-top: 0.5rem; padding-bottom: 0.5rem; }
            header h1 { text-align: center; }
            header nav ul { flex-direction: row; /* Keep horizontal on mobile */ flex-wrap: wrap; justify-content: center; gap: 1rem; }

            .tool-controls { flex-direction: column; align-items: stretch; gap: 1rem; padding: 1rem; }
            .tool-controls label { margin-bottom: 0.5rem; margin-right: 0; }
            input[type="range"] { max-width: none; }
            .dimension-inputs, .crop-inputs, .split-controls { flex-direction: column; align-items: stretch; }
            .dimension-inputs input[type="number"], .crop-inputs input[type="number"], .split-controls input[type="text"] { width: 100%; }
            .convert-controls select, .filter-controls select { width: 100%; }
            .rotate-flip-controls, .filter-controls { flex-direction: column; align-items: stretch; }
            .rotate-flip-controls button, .filter-controls button { width: 100%; }

            .preview-comparison { flex-direction: column; gap: var(--margin-base); }
            .preview-comparison > div { max-width: 100%; padding: 1rem; }
            #contact-section form { padding: 0; }
            .drop-zone { padding: 1.5rem; min-height: 150px; }
            .pdf-embed-preview { height: 400px; }
        }
        .processing-message {
            display: none;
            text-align: center;
            margin: 1rem 0;
            color: var(--info-color);
            font-style: italic;
        }

    </style>

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    { "@context": "https://schema.org", "@type": "WebSite", "name": "FreeImagePDFTools", "url": "YOUR_WEBSITE_URL_HERE" }
    </script>
</head>
<body>

    <header>
        <div class="container">
            <div class="site-title"><a href="#homepage-section"><h1>FreeImagePDFTools</h1></a></div>
            <nav>
                <ul>
                    <li><a href="#homepage-section">Home</a></li>
                    <li><a href="#about-section">About</a></li>
                    <li><a href="#contact-section">Contact</a></li>
                    <li><a href="#privacy-section">Privacy</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <!-- Homepage Section -->
        <section id="homepage-section" class="container" data-aos="fade-up">
            <div class="hero">
                <h2>Your Free Online Image & PDF Toolkit</h2>
                <p>Compress, resize, convert, crop, filter images, and manage PDFs with ease. Fast, free, and right in your browser.</p>
                 <a href="#image-compressor-section" class="btn">Explore Tools</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Homepage Top Ad)</p></div>
            <h3>Our Tools</h3>
            <div class="tools-grid">
                 <!-- Image Tools -->
                <div class="tool-card" data-aos="fade-up" data-aos-delay="100">
                    <div class="icon-container">üñºÔ∏è</div>
                    <h3><a href="#image-compressor-section">Image Compressor</a></h3>
                    <p>Reduce JPG, PNG, WebP file sizes while preserving quality.</p>
                    <a href="#image-compressor-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="150">
                    <div class="icon-container">üìê</div>
                    <h3><a href="#image-resizer-section">Image Resizer</a></h3>
                    <p>Change image dimensions by pixels or percentage easily.</p>
                    <a href="#image-resizer-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="200">
                    <div class="icon-container">üîÑ</div>
                    <h3><a href="#image-converter-section">Image Converter</a></h3>
                    <p>Convert images between JPG, PNG, and WebP formats.</p>
                    <a href="#image-converter-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="250">
                     <div class="icon-container">‚úÇÔ∏è</div>
                    <h3><a href="#image-cropper-section">Image Cropper</a></h3>
                    <p>Visually select and crop a specific area of your image.</p>
                    <a href="#image-cropper-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="300">
                     <div class="icon-container">‚Ü©Ô∏è</div>
                    <h3><a href="#image-rotate-flip-section">Rotate & Flip Image</a></h3>
                    <p>Rotate by 90¬∞ increments or flip horizontally/vertically.</p>
                    <a href="#image-rotate-flip-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="350">
                     <div class="icon-container">‚ú®</div>
                    <h3><a href="#image-filters-section">Image Filters</a></h3>
                    <p>Apply simple effects like Grayscale, Sepia, Invert etc.</p>
                    <a href="#image-filters-section" class="tool-link btn">Use Tool</a>
                </div>
                 <!-- PDF Tools -->
                <div class="tool-card" data-aos="fade-up" data-aos-delay="400">
                    <div class="icon-container">üñºÔ∏èüìÑ</div>
                    <h3><a href="#jpg-to-pdf-section">JPG to PDF</a></h3>
                    <p>Combine multiple JPG images into a single PDF document.</p>
                    <a href="#jpg-to-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                <div class="tool-card" data-aos="fade-up" data-aos-delay="450">
                    <div class="icon-container">üìÑüñºÔ∏è</div>
                    <h3><a href="#pdf-to-jpg-section">PDF to JPG</a></h3>
                    <p>Convert each PDF page into separate JPG images (ZIP).</p>
                    <a href="#pdf-to-jpg-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="500">
                    <div class="icon-container">üìÑ‚ûï</div>
                    <h3><a href="#merge-pdf-section">Merge PDF</a></h3>
                    <p>Combine several PDF files into one single document.</p>
                    <a href="#merge-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
                 <div class="tool-card" data-aos="fade-up" data-aos-delay="550">
                    <div class="icon-container">üìÑ‚úÇÔ∏è</div>
                    <h3><a href="#split-pdf-section">Split PDF</a></h3>
                    <p>Extract specific pages or ranges from a PDF file.</p>
                    <a href="#split-pdf-section" class="tool-link btn">Use Tool</a>
                </div>
            </div>
            <div class="ad-container"><p>Advertisement Area (Homepage Bottom Ad)</p></div>
        </section>

        <!-- Image Compressor Tool Section -->
        <section id="image-compressor-section" class="container" data-aos="fade-up">
            <h2>Online Image Compressor</h2>
            <p>Reduce the file size of your images without losing noticeable quality. Supports JPG, PNG, and WebP.</p>
            <div class="file-input-container">
                 <div id="compressDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="compressImageFile">Click to Upload Image</label>
                    <input type="file" id="compressImageFile" accept="image/*" aria-label="Select image file for compression">
                 </div>
            </div>
            <div class="tool-controls">
                <label for="compressionQuality">Compression Level:</label>
                <input type="range" id="compressionQuality" min="10" max="100" value="80">
                <span id="qualityValue">80%</span>
                <button id="compressNowBtn" class="btn" disabled>Compress Now</button>
            </div>
            <p id="compressProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Compressor Top Ad)</p></div>
            <div id="compressImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="originalImagePreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Compressed</span><img id="compressedImagePreview" src="" alt="Compressed Image Preview"></div>
                 </div>
            </div>
            <div id="compressImageInfo" class="image-info">
                <h3>Compression Info</h3>
                <p><strong>Filename:</strong> <span id="compressOriginalFileName"></span></p>
                <p><strong>Original Size:</strong> <span id="compressOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="compressedSize">-</span></p>
                <p><strong>Reduction:</strong> <span id="sizeReduction">-</span></p>
            </div>
            <div class="download-section">
                 <p id="compressDownloadMessage" class="preview-success-message" style="display: none;">Your compressed image is ready!</p>
                <a id="compressDownloadLink" class="btn btn-success" style="display: none;">Download Compressed Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Compressor Bottom Ad)</p></div>
        </section>

        <!-- Image Resizer Tool Section -->
        <section id="image-resizer-section" class="container" data-aos="fade-up">
            <h2>Online Image Resizer</h2>
            <p>Easily change the dimensions of your images.</p>
            <div class="file-input-container">
                 <div id="resizeDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="resizeImageFile">Click to Upload Image</label>
                    <input type="file" id="resizeImageFile" accept="image/*" aria-label="Select image file for resizing">
                 </div>
            </div>
            <div class="tool-controls dimension-inputs">
                 <label>New Dimensions:</label>
                 <input type="number" id="resizeWidth" placeholder="Width" min="1"><span>x</span>
                 <input type="number" id="resizeHeight" placeholder="Height" min="1">
                 <button id="applyResizeBtn" class="btn" disabled>Apply Resize</button>
            </div>
            <p id="resizeProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Resizer Top Ad)</p></div>
            <div id="resizeImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="resizeOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Resized</span><img id="resizedImage" src="" alt="Resized Image Preview"></div>
                 </div>
            </div>
            <div id="resizeImageInfo" class="image-info">
                <h3>Resizer Info</h3>
                <p><strong>Filename:</strong> <span id="resizeOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalDimensions">-</span></p>
                <p><strong>New Dimensions:</strong> <span id="newDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="resizeOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="resizedSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="resizeDownloadMessage" class="preview-success-message" style="display: none;">Your resized image is ready!</p>
                <a id="resizeDownloadLink" class="btn btn-success" style="display: none;">Download Resized Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Resizer Bottom Ad)</p></div>
        </section>

        <!-- Image Converter Tool Section -->
        <section id="image-converter-section" class="container" data-aos="fade-up">
            <h2>Online Image Converter</h2>
            <p>Convert your images between popular formats like JPG, PNG, and WebP.</p>
            <div class="file-input-container">
                 <div id="convertDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="convertImageFile">Click to Upload Image</label>
                    <input type="file" id="convertImageFile" accept="image/*" aria-label="Select image file for conversion">
                 </div>
            </div>
            <div class="tool-controls convert-controls">
                 <label for="outputFormat">Convert to:</label>
                 <select id="outputFormat">
                     <option value="image/jpeg">JPG</option><option value="image/png">PNG</option><option value="image/webp">WebP</option>
                 </select>
                 <button id="applyConvertBtn" class="btn" disabled>Convert Image</button>
            </div>
            <p id="convertProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Converter Top Ad)</p></div>
            <div id="convertImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="convertOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Converted</span><img id="convertedImage" src="" alt="Converted Image Preview"></div>
                 </div>
            </div>
            <div id="convertImageInfo" class="image-info">
                <h3>Conversion Info</h3>
                <p><strong>Filename:</strong> <span id="convertOriginalFileName"></span></p>
                <p><strong>Original Format:</strong> <span id="originalFormat">-</span></p>
                <p><strong>New Format:</strong> <span id="newFormat">-</span></p>
                <p><strong>Original Size:</strong> <span id="convertOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="convertedSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="convertDownloadMessage" class="preview-success-message" style="display: none;">Your converted image is ready!</p>
                <a id="convertDownloadLink" class="btn btn-success" style="display: none;">Download Converted Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Converter Bottom Ad)</p></div>
        </section>

        <!-- Image Cropper Tool Section -->
        <section id="image-cropper-section" class="container" data-aos="fade-up">
            <h2>Online Image Cropper</h2>
            <p>Click "Select Area" and then click and drag on the image to select the crop area. Click "Crop" to process.</p>
            <div class="file-input-container">
                 <div id="cropDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="cropImageFile">Click to Upload Image</label>
                    <input type="file" id="cropImageFile" accept="image/*" aria-label="Select image file for cropping">
                 </div>
            </div>
            <div class="tool-controls">
                 <button id="selectCropAreaBtn" class="btn" disabled>Select Area</button>
                 <button id="cropAndDownloadBtn" class="btn" disabled>Crop</button>
            </div>
            <p id="cropProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Cropper Top Ad)</p></div>
            <div id="cropImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="cropper-container">
                     <img id="cropOriginalImagePreview" src="" alt="Image to Crop"><div class="crop-selection-overlay"></div>
                 </div>
                  <div class="preview-comparison" style="display: none;">
                     <div><span class="preview-label">Original</span><img id="cropCompareOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Cropped</span><img id="croppedImage" src="" alt="Cropped Image Preview"></div>
                 </div>
                 <div class="download-section">
                     <p id="cropDownloadMessage" class="preview-success-message" style="display: none;">Your cropped image is ready!</p>
                    <a id="cropDownloadLink" class="btn btn-success" style="display: none;">Download Cropped Image</a>
                </div>
            </div>
            <div id="cropImageInfo" class="image-info">
                <h3>Cropper Info</h3>
                <p><strong>Filename:</strong> <span id="cropOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="cropOriginalDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="cropOriginalSize"></span></p>
                <p><strong>Cropped Dimensions:</strong> <span id="newCropDimensions">-</span></p>
                <p><strong>Cropped Size:</strong> <span id="croppedSize">-</span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Cropper Bottom Ad)</p></div>
        </section>

        <!-- Image Rotate & Flip Tool Section -->
        <section id="image-rotate-flip-section" class="container" data-aos="fade-up">
            <h2>Online Image Rotate & Flip</h2>
            <p>Rotate your image by 90 degrees or flip it horizontally or vertically.</p>
            <div class="file-input-container">
                 <div id="rotateFlipDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="rotateFlipImageFile">Click to Upload Image</label>
                    <input type="file" id="rotateFlipImageFile" accept="image/*" aria-label="Select image file for rotate/flip">
                 </div>
            </div>
            <div class="tool-controls rotate-flip-controls">
                 <button id="rotateLeftBtn" class="btn" disabled>Rotate Left 90¬∞</button>
                 <button id="rotateRightBtn" class="btn" disabled>Rotate Right 90¬∞</button>
                 <button id="flipHorizontalBtn" class="btn" disabled>Flip Horizontal</button>
                 <button id="flipVerticalBtn" class="btn" disabled>Flip Vertical</button>
            </div>
            <p id="rotateFlipProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Rotate/Flip Top Ad)</p></div>
            <div id="rotateFlipImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="rotateFlipOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Result</span><img id="rotatedFlippedImage" src="" alt="Rotated/Flipped Image Preview"></div>
                 </div>
            </div>
            <div id="rotateFlipImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="rotateFlipOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalRotateFlipDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="rotateFlipOriginalSize"></span></p>
                <p><strong>New Dimensions:</strong> <span id="newRotateFlipDimensions">-</span></p>
                <p><strong>New Size:</strong> <span id="newRotateFlipSize">-</span></p>
            </div>
            <div class="download-section">
                 <p id="rotateFlipDownloadMessage" class="preview-success-message" style="display: none;">Your image is ready!</p>
                <a id="rotateFlipDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Rotate/Flip Bottom Ad)</p></div>
        </section>

        <!-- Image Filters Tool Section -->
        <section id="image-filters-section" class="container" data-aos="fade-up">
            <h2>Online Image Filters</h2>
            <p>Apply filters to your image.</p>
            <div class="file-input-container">
                 <div id="filterDropZone" class="drop-zone">
                    <p>Drag & Drop your image here</p><p>or</p>
                    <label for="filterImageFile">Click to Upload Image</label>
                    <input type="file" id="filterImageFile" accept="image/*" aria-label="Select image file for filtering">
                 </div>
            </div>
            <div class="tool-controls filter-controls">
                 <label for="filterType">Select Filter:</label>
                 <select id="filterType" disabled>
                     <option value="none">None</option><option value="grayscale">Grayscale</option>
                     <option value="sepia">Sepia</option><option value="invert">Invert</option>
                     <option value="red">Red Channel</option><option value="green">Green Channel</option><option value="blue">Blue Channel</option>
                 </select>
                 <button id="applyFilterBtn" class="btn" disabled>Apply Filter</button>
            </div>
            <p id="filterProcessingMsg" class="processing-message">Processing...</p>
            <div class="ad-container"><p>Advertisement Area (Filters Top Ad)</p></div>
            <div id="filterImagePreview" class="image-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div><span class="preview-label">Original</span><img id="filterOriginalPreview" src="" alt="Original Image Preview"></div>
                     <div><span class="preview-label">Filtered</span><img id="filteredImage" src="" alt="Filtered Image Preview"></div>
                 </div>
                 <div class="download-section">
                     <p id="filterDownloadMessage" class="preview-success-message" style="display: none;">Your filtered image is ready!</p>
                    <a id="filterDownloadLink" class="btn btn-success" style="display: none;">Download Image</a>
                </div>
            </div>
            <div id="filterImageInfo" class="image-info">
                <h3>Result Info</h3>
                <p><strong>Filename:</strong> <span id="filterOriginalFileName"></span></p>
                <p><strong>Original Dimensions:</strong> <span id="originalFilterDimensions">-</span></p>
                <p><strong>Original Size:</strong> <span id="filterOriginalSize"></span></p>
                <p><strong>New Size:</strong> <span id="newFilterSize">-</span></p>
            </div>
            <div class="ad-container"><p>Advertisement Area (Filters Bottom Ad)</p></div>
        </section>

        <!-- JPG to PDF Tool Section -->
        <section id="jpg-to-pdf-section" class="container" data-aos="fade-up">
            <h2>JPG to PDF Converter</h2>
            <p>Convert multiple JPG images into a single PDF document.</p>
            <div class="file-input-container">
                <div id="jpgToPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your JPG images here</p><p>or</p>
                    <label for="jpgToPdfFilesInput">Click to Upload JPGs</label>
                    <input type="file" id="jpgToPdfFilesInput" accept="image/jpeg,image/jpg" multiple aria-label="Select JPG files for PDF conversion">
                </div>
            </div>
            <div id="jpgToPdfFileList" class="file-list-display">
                <h4>Selected JPG Files:</h4>
                <ul id="jpgToPdfFilesListUl"></ul>
            </div>
            <div class="tool-controls">
                <button id="convertToPdfBtn" class="btn" disabled>Convert to PDF</button>
            </div>
            <p id="jpgToPdfProcessingMsg" class="processing-message">Processing... This may take a moment for many images.</p>
            <div class="ad-container"><p>Advertisement Area (JPG to PDF Top Ad)</p></div>
             <div id="jpgToPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div>
                         <span class="preview-label">Selected JPGs</span>
                         <div id="jpgThumbnailsContainer" class="pdf-thumbnails-container"></div>
                     </div>
                     <div>
                         <span class="preview-label">Resulting PDF</span>
                          <embed id="jpgToPdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                          <p class="preview-success-message"></p>
                     </div>
                 </div>
             </div>
            <div id="jpgToPdfOutputInfo" class="output-info">
                <h3>Conversion Result</h3>
                <p><span id="jpgToPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="jpgToPdfDownloadMessage" class="preview-success-message" style="display: none;">Your PDF is ready!</p>
                <a id="jpgToPdfDownloadLink" class="btn btn-success" style="display: none;">Download PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (JPG to PDF Bottom Ad)</p></div>
        </section>

        <!-- PDF to JPG Tool Section -->
        <section id="pdf-to-jpg-section" class="container" data-aos="fade-up">
            <h2>PDF to JPG Converter</h2>
            <p>Convert each page of a PDF file into individual JPG images, downloaded as a ZIP file.</p>
            <div class="file-input-container">
                <div id="pdfToJpgDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="pdfToJpgFileInput">Click to Upload PDF</label>
                    <input type="file" id="pdfToJpgFileInput" accept="application/pdf" aria-label="Select PDF file for JPG conversion">
                </div>
            </div>
             <div class="tool-controls">
                <button id="convertToJpgsBtn" class="btn" disabled>Convert to JPGs</button>
            </div>
            <p id="pdfToJpgProcessingMsg" class="processing-message">Processing PDF... This can take some time for large PDFs.</p>
             <div class="ad-container"><p>Advertisement Area (PDF to JPG Top Ad)</p></div>
             <div id="pdfToJpgPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                      <div>
                         <span class="preview-label">Original PDF (First Page)</span>
                         <img id="pdfOriginalFirstPagePreview" src="" alt="PDF First Page Preview">
                      </div>
                      <div>
                         <span class="preview-label">Resulting JPGs (Preview)</span>
                          <div id="pdfResultThumbnailsContainer" class="pdf-thumbnails-container"></div>
                          <p class="preview-success-message"></p>
                      </div>
                 </div>
             </div>
             <div id="pdfToJpgFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="pdfToJpgFileName"></span></p>
                <p><strong>Size:</strong> <span id="pdfToJpgFileSize"></span></p>
                <p><strong>Pages:</strong> <span id="pdfToJpgPageCount">?</span></p>
            </div>
            <div id="pdfToJpgOutputInfo" class="output-info">
                <h3>Conversion Result</h3>
                <p><span id="pdfToJpgResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="pdfToJpgDownloadMessage" class="preview-success-message" style="display: none;">Your JPG images (ZIP) are ready!</p>
                <a id="pdfToJpgDownloadLink" class="btn btn-success" style="display: none;">Download JPGs (ZIP)</a>
            </div>
             <div class="ad-container"><p>Advertisement Area (PDF to JPG Bottom Ad)</p></div>
        </section>

        <!-- Merge PDF Tool Section -->
        <section id="merge-pdf-section" class="container" data-aos="fade-up">
            <h2>Merge PDF Files</h2>
            <p>Combine multiple PDF documents into a single PDF file.</p>
            <div class="file-input-container">
                <div id="mergePdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF files here (2 or more)</p><p>or</p>
                    <label for="mergePdfFilesInput">Click to Upload PDFs</label>
                    <input type="file" id="mergePdfFilesInput" accept="application/pdf" multiple aria-label="Select PDF files to merge">
                </div>
            </div>
            <div id="mergePdfFileList" class="file-list-display">
                <h4>Selected PDF Files (Order determines merge order):</h4>
                <ul id="mergePdfFilesListUl"></ul>
                 <p style="font-size: 0.85em; margin-top: 0.5em;">(Note: Currently, reordering is not supported. Upload in desired merge order.)</p>
            </div>
            <div class="tool-controls">
                <button id="mergePdfsBtn" class="btn" disabled>Merge PDFs</button>
            </div>
            <p id="mergePdfProcessingMsg" class="processing-message">Processing... Merging PDFs can take time.</p>
            <div class="ad-container"><p>Advertisement Area (Merge PDF Top Ad)</p></div>
            <div id="mergePdfPreviewContainer" class="pdf-tool-preview">
                <h3>Preview</h3>
                 <div class="preview-comparison">
                     <div>
                         <span class="preview-label">Selected PDFs</span>
                         <div class="pdf-thumbnails-container" style="text-align: left; min-height:50px; display:flex; align-items:center; justify-content:center;">
                             <p><i>Files listed above will be merged in order. No individual previews shown here.</i></p>
                         </div>
                     </div>
                     <div>
                         <span class="preview-label">Merged PDF Result</span>
                          <embed id="mergePdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                          <p class="preview-success-message"></p>
                     </div>
                 </div>
            </div>
            <div id="mergePdfOutputInfo" class="output-info">
                <h3>Merge Result</h3>
                <p><span id="mergePdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="mergePdfDownloadMessage" class="preview-success-message" style="display: none;">Your merged PDF is ready!</p>
                <a id="mergePdfDownloadLink" class="btn btn-success" style="display: none;">Download Merged PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Merge PDF Bottom Ad)</p></div>
        </section>

        <!-- Split PDF Tool Section -->
        <section id="split-pdf-section" class="container" data-aos="fade-up">
            <h2>Split PDF File</h2>
            <p>Extract specific pages or ranges from a PDF document into a new PDF.</p>
            <div class="file-input-container">
                <div id="splitPdfDropZone" class="drop-zone">
                    <p>Drag & Drop your PDF file here</p><p>or</p>
                    <label for="splitPdfFileInput">Click to Upload PDF</label>
                    <input type="file" id="splitPdfFileInput" accept="application/pdf" aria-label="Select PDF file to split">
                </div>
            </div>
             <div class="tool-controls split-controls">
                <label for="splitPageRange">Pages/Ranges (e.g., 1, 3-5, 8):</label>
                <input type="text" id="splitPageRange" placeholder="1, 3-5, 8" disabled>
                <button id="splitPdfBtn" class="btn" disabled>Split PDF</button>
            </div>
            <p id="splitPdfProcessingMsg" class="processing-message">Processing... Splitting PDF.</p>
             <div class="ad-container"><p>Advertisement Area (Split PDF Top Ad)</p></div>
             <div id="splitPdfPreviewContainer" class="pdf-tool-preview">
                 <h3>Preview</h3>
                 <div class="preview-comparison">
                      <div>
                         <span class="preview-label">Original PDF (First Page)</span>
                         <img id="splitPdfOriginalPreview" src="" alt="Original PDF Preview">
                      </div>
                      <div>
                         <span class="preview-label">Split PDF Result</span>
                         <embed id="splitPdfResultPreviewEmbed" type="application/pdf" class="pdf-embed-preview">
                         <p class="preview-success-message"></p>
                      </div>
                 </div>
             </div>
             <div id="splitPdfFileInfo" class="image-info">
                <h3>Selected PDF File:</h3>
                <p><strong>Filename:</strong> <span id="splitPdfFileName"></span></p>
                <p><strong>Size:</strong> <span id="splitPdfFileSize"></span></p>
                <p><strong>Total Pages:</strong> <span id="splitPdfTotalPages">?</span></p>
            </div>
            <div id="splitPdfOutputInfo" class="output-info">
                <h3>Split Result</h3>
                <p><span id="splitPdfResultText"></span></p>
            </div>
            <div class="download-section">
                <p id="splitPdfDownloadMessage" class="preview-success-message" style="display: none;">Your split PDF is ready!</p>
                <a id="splitPdfDownloadLink" class="btn btn-success" style="display: none;">Download Split PDF</a>
            </div>
            <div class="ad-container"><p>Advertisement Area (Split PDF Bottom Ad)</p></div>
        </section>

        <!-- About, Contact, Privacy Sections -->
        <section id="about-section" class="container" data-aos="fade-up">
             <h2>About Us</h2>
            <p>Welcome to FreeImagePDFTools, your one-stop destination for free and easy-to-use online image and PDF tools. Our mission is to provide simple, fast, and effective tools to help you manage your digital files without needing to download complex software.</p>
            <p>We are constantly working on adding new tools and improving the existing ones based on your feedback. Whether you need to compress images for your website, resize a photo for social media, convert formats (JPG, PNG, WebP), crop, rotate, flip, apply filters, convert JPGs to PDF, extract JPGs from a PDF, merge multiple PDFs, or split a PDF into specific pages, we aim to make it as straightforward as possible.</p>
            <p>Thank you for using our tools!</p>
            <div class="ad-container"><p>Advertisement Area (About Page Ad)</p></div>
        </section>
        <section id="contact-section" class="container" data-aos="fade-up">
             <h2>Contact Us</h2>
            <p>Have questions, feedback, or suggestions for new tools? We'd love to hear from you!</p>
            <form id="contactForm" action="#" method="POST">
                <div><label for="name">Name:</label><input type="text" id="name" name="name" required></div>
                <div><label for="email">Email:</label><input type="email" id="email" name="email" required></div>
                <div><label for="message">Message:</label><textarea id="message" name="message" required></textarea></div>
                <button type="submit" class="btn">Send Message</button>
            </form>
            <p style="text-align: center; margin-top: 1rem; font-size: 0.9rem;">(Note: This form is a placeholder and requires server-side integration to send emails.)</p>
            <div class="ad-container"><p>Advertisement Area (Contact Page Ad)</p></div>
        </section>
        <section id="privacy-section" class="container" data-aos="fade-up">
             <h2>Privacy Policy</h2>
            <p>Your privacy is important to us. This policy explains how we handle information on our website.</p>
            <h3>What information do we collect?</h3>
            <p>We do not collect any personally identifiable information from you unless you voluntarily provide it (e.g., via the contact form). Our tools process files entirely in your browser; your files are not uploaded to our servers.</p>
            <h3>How do we use your information?</h3>
            <p>Any information you provide via the contact form is used solely to respond to your inquiry. We do not share, sell, or rent your personal information to third parties.</p>
            <h3>Cookies and Tracking</h3>
            <p>We may use standard website tracking technologies (like Google Analytics - if implemented) to understand how the site is used in aggregate, which helps us improve our services. These tools typically collect non-personally identifiable information such as browser type, pages visited, and time spent on the site.</p>
            <p>Advertisement partners (like Google AdSense) may use cookies to serve ads based on your visit to this and other sites. You can opt out of personalized advertising by visiting Ads Settings.</p>
            <h3>Third-Party Links</h3>
            <p>This website may contain links to other sites. We are not responsible for the privacy practices or the content of such other sites.</p>
            <h3>Your Consent</h3>
            <p>By using our site, you consent to our privacy policy.</p>
            <h3>Changes to our Privacy Policy</h3>
            <p>If we decide to change our privacy policy, we will post those changes on this page.</p>
            <p>This policy was last updated on May 9, 2025.</p>
            <div class="ad-container"><p>Advertisement Area (Privacy Page Ad)</p></div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023-2025 FreeImagePDFTools. All rights reserved.</p>
            <p><a href="#privacy-section">Privacy Policy</a>&nbsp;|&nbsp;<a href="#contact-section">Contact Us</a>&nbsp;|&nbsp;<a href="#about-section">About</a></p>
        </div>
    </footer>

    <!-- Libraries -->
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- Main Application Script -->
    <script>
        (function() {
            AOS.init({ duration: 800, easing: 'ease-in-out', once: true, mirror: false });

            // --- Helper function ---
            function formatBytes(bytes, decimals = 2) {
                if (!bytes || bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = bytes < 1 ? 0 : Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            // --- Global State Variables ---
            // Use objects to store state per tool ID to avoid accidental clearing
            const toolState = {}; // NEW: Object to hold state per tool
            /* Remove old individual globals:
            let originalCompressImage = new Image(); // etc...
            let originalCompressFile = null; // etc...
            */

            let finalScaledCrop = null; // Still okay for cropper-specific temporary state
            let currentRotationAngle = 0; let currentFlipH = false; let currentFlipV = false; // Okay for rotate/flip temp state

            // --- Library Instances ---
            let pdfjsLibInstance = null;
            let pdfLibInstance = null;
            let jspdfInstance = null;
            let jszipInstance = null;

            // --- Drag & Drop Prevention ---
            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            document.addEventListener('dragover', preventDefaults, false);
            document.addEventListener('drop', preventDefaults, false);

            // --- DOMContentLoaded ---
            document.addEventListener('DOMContentLoaded', () => {
                console.log("[GLOBAL] DOM fully loaded. Initializing...");
                initializeLibraries();
                setupNavigation();
                initializeAllToolListeners();
                setupContactForm();
                setupBlobCleanup(); // Needs update for toolState
            });

            // --- Library Initialization ---
            function initializeLibraries() {
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLibInstance = pdfjsLib;
                    pdfjsLibInstance.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
                    console.log("[LIB] pdf.js initialized.");
                } else { console.error("[LIB] pdfjsLib is not defined."); }

                if (typeof PDFLib !== 'undefined') {
                    pdfLibInstance = PDFLib;
                    console.log("[LIB] pdf-lib initialized.");
                } else { console.error("[LIB] PDFLib is not defined."); }

                if (typeof jspdf !== 'undefined') {
                    jspdfInstance = jspdf;
                    console.log("[LIB] jsPDF initialized.");
                } else { console.error("[LIB] jspdf is not defined."); }

                 if (typeof JSZip !== 'undefined') {
                    jszipInstance = JSZip;
                    console.log("[LIB] JSZip initialized.");
                } else { console.error("[LIB] JSZip is not defined."); }
            }

            // --- Navigation (Refined Reset Logic) ---
             function setupNavigation() {
                const sections = document.querySelectorAll('main > section');
                const navLinks = document.querySelectorAll('header nav a, #homepage-section a.tool-link, #homepage-section .tool-card h3 a, footer a[href^="#"]');
                let currentActiveSectionId = null;

                function showSection(id) {
                    const targetId = id.startsWith('#') ? id.substring(1) : id;
                    const targetSection = document.getElementById(targetId);

                    console.log(`[NAV] showSection called for targetId: ${targetId}. Current active section: ${currentActiveSectionId}`); // DEBUG

                    if (!targetSection) {
                        console.warn(`[NAV] Section "${targetId}" not found. Defaulting home.`);
                        if (targetId !== 'homepage-section') showSection('homepage-section');
                        else console.error("[NAV] Homepage section missing.");
                        return;
                    }

                    // *** REFINED RESET LOGIC ***
                    // Only reset the *old* section if it's *different* from the target and *was* a tool section
                    if (currentActiveSectionId && currentActiveSectionId !== targetId) {
                        const oldSectionElement = document.getElementById(currentActiveSectionId);
                        const isOldSectionTool = oldSectionElement?.querySelector('.tool-controls');
                        const isOldSectionStatic = ['about-section', 'contact-section', 'privacy-section', 'homepage-section'].includes(currentActiveSectionId);

                        if (isOldSectionTool && !isOldSectionStatic) {
                            console.log(`[NAV] Resetting DIFFERENT old tool section: ${currentActiveSectionId}`); // DEBUG
                            resetToolState(currentActiveSectionId.replace('-section', ''));
                        } else {
                            console.log(`[NAV] Not resetting old section ${currentActiveSectionId} (Not a different tool or is static page)`); // DEBUG
                        }
                    } else if (currentActiveSectionId && currentActiveSectionId === targetId) {
                        console.log(`[NAV] Not resetting section ${currentActiveSectionId} (target is the same as current)`); // DEBUG
                    }

                    sections.forEach(section => { section.style.display = (section.id === targetId) ? 'block' : 'none'; });

                    if (document.getElementById(targetId)?.style.display === 'block') {
                        console.log(`[NAV] Section ${targetId} is now visible. Refreshing AOS and scrolling.`); // DEBUG
                         AOS.refreshHard();
                         const headerHeight = document.querySelector('header')?.offsetHeight || 70;
                         // Only scroll if we actually changed sections
                         if (currentActiveSectionId !== targetId) {
                            setTimeout(() => window.scrollTo({ top: Math.max(0, targetSection.offsetTop - headerHeight), behavior: 'smooth'}), 50);
                         }
                    }
                    // Update the current section ID *after* potentially resetting the old one
                    currentActiveSectionId = targetId;
                }

                function handleNavigation() {
                    let hash = window.location.hash;
                    if (!hash || hash === '#' || !document.getElementById(hash.substring(1))) {
                        hash = '#homepage-section';
                    }
                    showSection(hash);
                }

                navLinks.forEach(anchor => {
                    anchor.addEventListener('click', function (e) {
                        const targetHash = this.getAttribute('href');
                        if (targetHash && targetHash.startsWith('#')) {
                            e.preventDefault();
                            const targetSectionId = targetHash.substring(1);
                            const targetSectionElement = document.getElementById(targetSectionId);

                            if (targetSectionElement) {
                                if (window.location.hash === targetHash) { // Already on page, just scroll
                                    const headerHeight = document.querySelector('header')?.offsetHeight || 70;
                                    window.scrollTo({ top: Math.max(0, targetSectionElement.offsetTop - headerHeight), behavior: 'smooth' });
                                } else {
                                    window.location.hash = targetHash; // Change hash to trigger navigation
                                }
                            } else {
                                console.warn(`[NAV CLICK] Target section ${targetHash} not found.`);
                                if (window.location.hash !== '#homepage-section') window.location.hash = '#homepage-section';
                            }
                        }
                    });
                });

                handleNavigation(); // Initial call
                window.addEventListener('hashchange', handleNavigation); // Listen for changes
            }

            // --- Tool Reset (Uses toolState object) ---
             function resetToolState(toolId) {
                 console.log(`[RESET] Resetting tool: ${toolId}`);
                 const section = document.getElementById(toolId + '-section');
                 if (!section) { console.warn(`[RESET] Section not found: ${toolId}-section`); return; }

                 // Clear the specific tool's state object
                 const state = toolState[toolId] || {};
                 if (state.imageObject?.src?.startsWith('blob:')) { try { URL.revokeObjectURL(state.imageObject.src); } catch(e) {} }
                 if (state.firstPagePreviewUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.firstPagePreviewUrl); } catch(e) {} }
                 if (state.fileUrl?.startsWith('blob:')) { try { URL.revokeObjectURL(state.fileUrl); } catch(e) {} }
                 if (state.files) { // For multi-file tools
                    state.files.forEach(fileObj => { if (fileObj.url?.startsWith('blob:')) try { URL.revokeObjectURL(fileObj.url); } catch(e){} });
                 }
                 toolState[toolId] = {}; // Reset the state object for this tool

                 // Reset specific temporary variables if needed
                 if (toolId === 'image-cropper') finalScaledCrop = null;
                 if (toolId === 'image-rotate-flip') { currentRotationAngle = 0; currentFlipH = false; currentFlipV = false; }
                 if (toolId === 'split-pdf') splitPdfDocObject = null;


                 try { // UI Reset part
                    const previewSection = section.querySelector('.image-preview, .pdf-tool-preview');
                    if (previewSection) {
                        previewSection.querySelectorAll('img').forEach(img => {
                            // No need to revoke here again, done above via state object
                            img.src = ''; img.style.display = 'none'; img.alt = '';
                            if (img.closest('.pdf-thumbnails-container')) img.remove();
                        });
                        const pdfEmbed = previewSection.querySelector('embed[type="application/pdf"]');
                        if(pdfEmbed) {
                             // No need to revoke here again
                            pdfEmbed.removeAttribute('src'); pdfEmbed.style.display = 'none';
                        }
                        previewSection.querySelectorAll('.preview-success-message').forEach(msg => msg.style.display = 'none');
                        previewSection.style.display = 'none';
                    }
                    section.querySelectorAll('#jpgThumbnailsContainer, #pdfResultThumbnailsContainer')
                        .forEach(container => { if(container) container.innerHTML = ''; });

                    const downloadSection = section.querySelector('.download-section');
                    if (downloadSection) {
                         const downloadLink = downloadSection.querySelector('a.btn');
                         if (downloadLink) {
                              if (downloadLink.href && downloadLink.href.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} } // Revoke download links specifically
                              downloadLink.href = '#'; downloadLink.style.display = 'none'; downloadLink.removeAttribute('download');
                         }
                         const dlMessage = downloadSection.querySelector('.preview-success-message');
                         if(dlMessage) dlMessage.style.display = 'none';
                    }

                    section.querySelectorAll('.image-info, .output-info, .file-list-display')
                        .forEach(div => { if(div) div.style.display = 'none'; });

                    const processingMsg = section.querySelector('.processing-message');
                    if (processingMsg) processingMsg.style.display = 'none';

                    // Reset Controls
                    switch(toolId) {
                        case 'image-compressor':
                            section.querySelector('#compressionQuality').value = '80';
                            section.querySelector('#qualityValue').textContent = '80%';
                            section.querySelector('#compressNowBtn').disabled = true;
                            break;
                        case 'image-resizer':
                            section.querySelector('#resizeWidth').value = ''; section.querySelector('#resizeHeight').value = '';
                            section.querySelector('#applyResizeBtn').disabled = true;
                            break;
                        case 'image-converter':
                             section.querySelector('#outputFormat').value = 'image/jpeg'; section.querySelector('#applyConvertBtn').disabled = true;
                             break;
                        case 'image-cropper':
                             section.querySelector('#selectCropAreaBtn').disabled = true; section.querySelector('#cropAndDownloadBtn').disabled = true;
                             section.querySelector('.cropper-container').style.display = 'block'; section.querySelector('.preview-comparison').style.display = 'none';
                             section.querySelector('.crop-selection-overlay').style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                             break;
                        case 'image-rotate-flip':
                            section.querySelectorAll('.rotate-flip-controls button').forEach(btn => btn.disabled = true);
                            const rotatedFlippedImageEl = section.querySelector('#rotatedFlippedImage');
                            if (rotatedFlippedImageEl) { // Clear result image specifically
                                 if (rotatedFlippedImageEl.src?.startsWith('blob:')) { try { URL.revokeObjectURL(rotatedFlippedImageEl.src); } catch(e) {} }
                                 rotatedFlippedImageEl.src = ''; rotatedFlippedImageEl.style.display = 'none';
                            }
                            break;
                        case 'image-filters':
                             section.querySelector('#filterType').value = 'none'; section.querySelector('#filterType').disabled = true;
                             section.querySelector('#applyFilterBtn').disabled = true;
                             break;
                        case 'jpg-to-pdf': section.querySelector('#convertToPdfBtn').disabled = true; break;
                        case 'pdf-to-jpg': section.querySelector('#convertToJpgsBtn').disabled = true; break;
                        case 'merge-pdf': section.querySelector('#mergePdfsBtn').disabled = true; break;
                        case 'split-pdf':
                              section.querySelector('#splitPageRange').value = ''; section.querySelector('#splitPageRange').disabled = true;
                              section.querySelector('#splitPdfBtn').disabled = true;
                              break;
                    }
                    const fileInput = section.querySelector('input[type="file"]');
                    if (fileInput) fileInput.value = '';
                    console.log(`[RESET] UI reset finished for ${toolId}`);

                 } catch (error) { console.error(`[RESET] Error resetting UI for ${toolId}:`, error); }
            }

            // --- Drop Zone & File Input Handling (Uses toolState object) ---
             function addDropZoneListeners(toolId, dropZoneId, fileInputId, isMultiple = false, acceptType = "image/*") {
                // ... (same listener setup)
                 const dropZone = document.getElementById(dropZoneId);
                 const fileInput = document.getElementById(fileInputId);
                 if (!dropZone || !fileInput) { console.error(`[LISTENERS] Missing elements for ${toolId}`); return; }

                 ['dragenter', 'dragover'].forEach(eName => dropZone.addEventListener(eName, e => { preventDefaults(e); dropZone.classList.add('drag-over'); }));
                 ['dragleave', 'drop'].forEach(eName => dropZone.addEventListener(eName, e => { preventDefaults(e); dropZone.classList.remove('drag-over'); }));

                 dropZone.addEventListener('drop', e => {
                     const files = e.dataTransfer.files;
                     if (!files || files.length === 0) { /* Don't reset here */ return; }
                     const acceptedFiles = filterAcceptedFiles(files, acceptType);
                     if (acceptedFiles.length === 0) { alert(`Please drop valid ${acceptType.split('/')[1]?.toUpperCase() || acceptType} files.`); /* Don't reset */ return; }
                     handleFileSelection(isMultiple ? acceptedFiles : acceptedFiles[0], toolId, isMultiple);
                 });
                 fileInput.addEventListener('change', e => {
                     const files = e.target.files;
                     if (!files || files.length === 0) { /* Don't reset */ return; }
                     handleFileSelection(isMultiple ? Array.from(files) : files[0], toolId, isMultiple);
                 });
            }
            function filterAcceptedFiles(files, acceptType) { // ... (same)
                 return Array.from(files).filter(file => {
                     if (!file.type) return false;
                     if (acceptType === "application/pdf") return file.type === "application/pdf";
                     if (acceptType === "image/jpeg" || acceptType === "image/jpg") return file.type === "image/jpeg" || file.type === "image/jpg";
                     if (acceptType === "image/*") return file.type.startsWith('image/');
                     return false;
                  });
            }
             function handleFileSelection(selected, toolId, isMultiple) {
                 // Reset UI *before* processing new file(s)
                 resetToolState(toolId); // Call reset here now to clear previous state/UI *before* loading new
                 console.log(`[HANDLE_FILE_SELECTION] Tool: ${toolId}, Selected:`, selected);
                 try {
                     // Initialize state object for the tool if it doesn't exist
                     if (!toolState[toolId]) toolState[toolId] = {};

                     if (isMultiple) {
                         const fileObjects = selected.map(file => ({ file, url: URL.createObjectURL(file) }));
                         if (fileObjects.length === 0) throw new Error("No valid files found after processing.");
                         toolState[toolId].files = fileObjects; // Store in state object
                         if (toolId === 'jpg-to-pdf') setupJpgToPdfUI(fileObjects);
                         else if (toolId === 'merge-pdf') setupMergePdfUI(fileObjects);
                         else throw new Error(`Multiple file selection not handled for tool: ${toolId}`);
                     } else {
                         const file = selected;
                         const objectUrl = URL.createObjectURL(file);
                         toolState[toolId].file = file; // Store file in state object
                         toolState[toolId].fileUrl = objectUrl; // Store URL in state object
                         if (toolId === 'pdf-to-jpg') setupPdfToJpgUI(file, objectUrl);
                         else if (toolId === 'split-pdf') setupSplitPdfUI(file, objectUrl);
                         else handleImageFile(file, toolId, objectUrl); // Pass objectUrl
                     }
                 } catch (error) {
                     console.error(`[HANDLE_FILE] Error processing selection for ${toolId}:`, error);
                     alert(`Error processing file(s): ${error.message}`);
                     resetToolState(toolId); // Reset only on error
                 }
             }
             function handleImageFile(file, toolId, objectUrl) {
                 console.log(`[HANDLE_IMG_FILE] Tool: ${toolId}, File: ${file.name}, URL: ${objectUrl}`);

                 // Get or create the image object within the tool's state
                 if (!toolState[toolId]) toolState[toolId] = {};
                 toolState[toolId].imageObject = new Image(); // Always create a new Image object for this load cycle
                 const imgObj = toolState[toolId].imageObject;

                 let setupFn;
                 switch (toolId) {
                     case 'image-compressor': setupFn = setupCompressUI; break;
                     case 'image-resizer':    setupFn = setupResizeUI; break;
                     case 'image-converter':  setupFn = setupConvertUI; break;
                     case 'image-cropper':    setupFn = setupCropUI; break;
                     case 'image-rotate-flip':setupFn = setupRotateFlipUI; break;
                     case 'image-filters':    setupFn = setupFilterUI; break;
                     default: console.error(`Unknown image toolId in handleImageFile: ${toolId}`); resetToolState(toolId); return;
                 }

                 imgObj.onload = () => {
                     console.log(`[HANDLE_IMG_FILE] ${toolId} Image loaded: ${imgObj.src}, naturalWidth: ${imgObj.naturalWidth}`);
                     if (imgObj.naturalWidth > 0) {
                         // Pass the necessary state items explicitly
                         setupFn(toolState[toolId].file, imgObj.src); // Pass file from state, and the blob URL src
                     } else {
                         alert(`Image "${file.name}" loaded but has zero dimensions. Please try a different image.`);
                         resetToolState(toolId);
                     }
                     imgObj.onerror = null; // Clear error handler
                 };
                  imgObj.onerror = () => {
                     console.error(`[HANDLE_IMG_FILE] Error loading image for ${toolId}: ${file.name}`);
                     alert(`Error loading image "${file.name}". Please ensure it's a valid image file.`);
                     resetToolState(toolId);
                     imgObj.onload = null; // Clear onload handler
                 };
                 imgObj.src = objectUrl; // Start loading
             }


            // --- Tool Logic Implementations (Adjusted to use toolState) ---

            // --- Image Compressor ---
             function setupCompressUI(file, imgUrl) { // file and imgUrl passed from handleImageFile.onload
                 console.log("[SETUP COMPRESS UI] File:", file, "imgUrl:", imgUrl);
                 const toolId = 'image-compressor';
                 const section = document.getElementById(toolId + '-section');
                 section.querySelector('#compressOriginalFileName').textContent = file.name;
                 section.querySelector('#compressOriginalSize').textContent = formatBytes(file.size);
                 section.querySelector('#compressedSize').textContent = '-';
                 section.querySelector('#sizeReduction').textContent = '-';
                 section.querySelector('#compressImageInfo').style.display = 'block';
                 section.querySelector('#originalImagePreview').src = imgUrl; // Use passed imgUrl
                 section.querySelector('#originalImagePreview').alt = `Original Image Preview (${file.name})`;
                 section.querySelector('#originalImagePreview').style.display = 'block';
                 const compressedPreview = section.querySelector('#compressedImagePreview');
                 if (compressedPreview.src?.startsWith('blob:')) { try { URL.revokeObjectURL(compressedPreview.src); } catch(e){} }
                 compressedPreview.src = ''; compressedPreview.style.display = 'none';
                 section.querySelector('#compressImagePreview').style.display = 'block';
                 section.querySelector('#compressNowBtn').disabled = false;
                 section.querySelector('#qualityValue').textContent = section.querySelector('#compressionQuality').value + '%';
             }
             function setupImageCompressorListeners() {
                 const toolId = 'image-compressor'; // Define toolId
                 const section = document.getElementById(toolId + '-section');
                 const qualitySlider = section.querySelector('#compressionQuality');
                 const qualityValueSpan = section.querySelector('#qualityValue');
                 const compressNowBtn = section.querySelector('#compressNowBtn');
                 // ... (other UI elements) ...
                 const compressedSizeSpan = section.querySelector('#compressedSize');
                 const sizeReductionSpan = section.querySelector('#sizeReduction');
                 const compressedImagePreview = section.querySelector('#compressedImagePreview');
                 const downloadLink = section.querySelector('#compressDownloadLink');
                 const downloadMessage = section.querySelector('#compressDownloadMessage');
                 const processingMsg = section.querySelector('#compressProcessingMsg');


                 qualitySlider?.addEventListener('input', (event) => { qualityValueSpan.textContent = event.target.value + '%'; });

                 compressNowBtn?.addEventListener('click', () => {
                    // Get state for this tool
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;

                    console.log(`[${toolId.toUpperCase()} CLICK] state:`, state); // DEBUG
                    console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage:`, currentImage);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.complete:`, currentImage?.complete);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);

                     if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0) {
                         processCompressImage(currentFile, currentImage, parseInt(qualitySlider.value, 10));
                     } else { alert("Please select a valid image file first."); }
                 });

                 addDropZoneListeners(toolId, 'compressDropZone', 'compressImageFile', false, "image/*");

                 function processCompressImage(file, imageObj, quality) { // This function receives the correct file/imgObj
                      console.log(`[${toolId.toUpperCase()} PROCESS] Processing...`, file, imageObj, quality); // DEBUG
                      // ... (rest of processing logic remains the same) ...
                      compressNowBtn.disabled = true; processingMsg.style.display = 'block';
                      if (compressedImagePreview.src?.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) {} }
                      compressedImagePreview.src = ''; compressedImagePreview.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight;
                      const mimeType = file.type === 'image/png' ? 'image/png' : file.type === 'image/webp' ? 'image/webp' : 'image/jpeg';

                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.drawImage(imageObj, 0, 0);

                      const outputQuality = quality / 100;
                      canvas.toBlob((blob) => {
                          if (blob) { updateCompressOutput(blob, file.name, file.size, mimeType); }
                          else { alert("Image compression failed."); compressedSizeSpan.textContent = 'Failed'; }
                          // Re-check state for enabling button
                          const currentState = toolState[toolId] || {};
                          compressNowBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                          processingMsg.style.display = 'none';
                      }, mimeType, outputQuality);
                 }
                 function updateCompressOutput(compressedBlob, originalName, originalSize, mimeType) { // ... (remains the same) ...
                     if (compressedImagePreview.src?.startsWith('blob:')) { try { URL.revokeObjectURL(compressedImagePreview.src); } catch (e) {} }
                     if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                     const objectUrl = URL.createObjectURL(compressedBlob);
                     compressedSizeSpan.textContent = formatBytes(compressedBlob.size);
                     sizeReductionSpan.textContent = originalSize > 0 ? `${(((originalSize - compressedBlob.size) / originalSize) * 100).toFixed(2)}%` : 'N/A';
                     compressedImagePreview.src = objectUrl; compressedImagePreview.alt = `Compressed Image`; compressedImagePreview.style.display = 'block';
                     downloadLink.href = objectUrl;
                     let ext = mimeType.split('/')[1] || 'jpg'; if (ext === 'jpeg') ext = 'jpg';
                     downloadLink.download = `compressed_${originalName.substring(0, originalName.lastIndexOf('.')) || originalName}.${ext}`;
                     downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Resizer (Adjusted to use toolState) ---
            function setupResizeUI(file, imgUrl) { // file, imgUrl passed from handleImageFile
                console.log("[SETUP RESIZE UI] File:", file, "imgUrl:", imgUrl);
                const toolId = 'image-resizer';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId] || {};
                const imageObj = state.imageObject; // Get the image object from state

                section.querySelector('#resizeOriginalFileName').textContent = file.name;
                // Use imageObj from state for dimensions
                section.querySelector('#originalDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                section.querySelector('#resizeOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#newDimensions').textContent = '-';
                section.querySelector('#resizedSize').textContent = '-';
                section.querySelector('#resizeImageInfo').style.display = 'block';
                section.querySelector('#resizeOriginalPreview').src = imgUrl; // Use passed URL
                section.querySelector('#resizeOriginalPreview').alt = `Original Image Preview (${file.name})`;
                section.querySelector('#resizeOriginalPreview').style.display = 'block';
                const resizedImgEl = section.querySelector('#resizedImage');
                if(resizedImgEl.src?.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImgEl.src); } catch(e){} }
                resizedImgEl.src = ''; resizedImgEl.style.display = 'none';
                section.querySelector('#resizeImagePreview').style.display = 'block';
                section.querySelector('#resizeWidth').value = imageObj ? imageObj.naturalWidth : '';
                section.querySelector('#resizeHeight').value = imageObj ? imageObj.naturalHeight : '';
                section.querySelector('#applyResizeBtn').disabled = !(imageObj && imageObj.naturalWidth > 0); // Enable if image valid
            }
            function setupImageResizerListeners() {
                const toolId = 'image-resizer';
                const section = document.getElementById(toolId + '-section');
                const widthInput = section.querySelector('#resizeWidth');
                const heightInput = section.querySelector('#resizeHeight');
                const applyBtn = section.querySelector('#applyResizeBtn');
                // ... (other UI elements) ...
                 const newDimensionsSpan = section.querySelector('#newDimensions');
                 const resizedSizeSpan = section.querySelector('#resizedSize');
                 const resizedImage = section.querySelector('#resizedImage');
                 const downloadLink = section.querySelector('#resizeDownloadLink');
                 const downloadMessage = section.querySelector('#resizeDownloadMessage');
                 const processingMsg = section.querySelector('#resizeProcessingMsg');

                const dimensionInputHandler = () => {
                   const state = toolState[toolId] || {};
                   const isReady = state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0;
                   if (!isReady) { applyBtn.disabled = true; return; }
                   const w = parseInt(widthInput.value, 10); const h = parseInt(heightInput.value, 10);
                   applyBtn.disabled = !(!isNaN(w) && w > 0 && !isNaN(h) && h > 0);
                };
                widthInput?.addEventListener('input', dimensionInputHandler);
                heightInput?.addEventListener('input', dimensionInputHandler);

                applyBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;

                    console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage:`, currentImage);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.complete:`, currentImage?.complete);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);

                   const newW = parseInt(widthInput.value, 10); const newH = parseInt(heightInput.value, 10);
                   if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && !isNaN(newW) && newW > 0 && !isNaN(newH) && newH > 0) {
                       performResize(currentFile, currentImage, newW, newH);
                   } else { alert("Please select file and enter valid positive dimensions."); }
                });

                addDropZoneListeners(toolId, 'resizeDropZone', 'resizeImageFile', false, "image/*");

                function performResize(file, imageObj, newWidth, newHeight) { // ... (remains the same) ...
                     console.log(`[${toolId.toUpperCase()} PROCESS] Processing...`, file, imageObj, newWidth, newHeight); // DEBUG
                     applyBtn.disabled = true; processingMsg.style.display = 'block';
                     if (resizedImage.src?.startsWith('blob:')) { try { URL.revokeObjectURL(resizedImage.src); } catch (e) {} }
                     resizedImage.src = ''; resizedImage.style.display = 'none';
                     if (downloadLink.href?.startsWith('blob:')) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                     newDimensionsSpan.textContent = '-'; resizedSizeSpan.textContent = '-';

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     canvas.width = newWidth; canvas.height = newHeight;
                     const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                     if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, newWidth, newHeight); }
                     else { ctx.clearRect(0, 0, newWidth, newHeight); }
                     ctx.drawImage(imageObj, 0, 0, newWidth, newHeight);

                     canvas.toBlob(blob => {
                         if (blob) { updateResizeOutput(blob, file.name, newWidth, newHeight, mimeType); }
                         else { alert("Resizing failed."); newDimensionsSpan.textContent = 'Failed'; }
                          // Re-check state for enabling button
                         const currentState = toolState[toolId] || {};
                         const w = parseInt(widthInput.value, 10); const h = parseInt(heightInput.value, 10);
                         applyBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && !isNaN(w) && w > 0 && !isNaN(h) && h > 0);
                         processingMsg.style.display = 'none';
                     }, mimeType);
                }
                function updateResizeOutput(blob, name, w, h, mime) { // ... (remains the same) ...
                     if (resizedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(resizedImage.src); } catch (e) {}
                     if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                     const url = URL.createObjectURL(blob);
                     newDimensionsSpan.textContent = `${w}x${h}`;
                     resizedSizeSpan.textContent = formatBytes(blob.size);
                     resizedImage.src = url; resizedImage.alt = 'Resized Image'; resizedImage.style.display = 'block';
                     downloadLink.href = url;
                     let ext = mime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                     downloadLink.download = `resized_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                     downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                }
            }

            // --- Image Converter (Adjusted to use toolState) ---
            // Apply similar pattern: setupUI uses passed args, listeners get state from toolState[toolId]
            function setupConvertUI(file, imgUrl) {
                 console.log("[SETUP CONVERT UI] File:", file, "imgUrl:", imgUrl);
                 const toolId = 'image-converter';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;

                 section.querySelector('#convertOriginalFileName').textContent = file.name;
                 section.querySelector('#originalFormat').textContent = file.type.split('/')[1]?.toUpperCase() || 'Unknown';
                 section.querySelector('#convertOriginalSize').textContent = formatBytes(file.size);
                 section.querySelector('#newFormat').textContent = '-';
                 section.querySelector('#convertedSize').textContent = '-';
                 section.querySelector('#convertImageInfo').style.display = 'block';
                 section.querySelector('#convertOriginalPreview').src = imgUrl;
                 section.querySelector('#convertOriginalPreview').alt = `Original Image Preview (${file.name})`;
                 section.querySelector('#convertOriginalPreview').style.display = 'block';
                 const convertedImgEl = section.querySelector('#convertedImage');
                 if(convertedImgEl.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImgEl.src); } catch(e){}
                 convertedImgEl.src = ''; convertedImgEl.style.display = 'none';
                 section.querySelector('#convertImagePreview').style.display = 'block';
                 section.querySelector('#outputFormat').value = 'image/jpeg';
                 section.querySelector('#applyConvertBtn').disabled = !(imageObj && imageObj.naturalWidth > 0);
            }
            function setupImageConverterListeners() {
                 const toolId = 'image-converter';
                 const section = document.getElementById(toolId + '-section');
                 const formatSelect = section.querySelector('#outputFormat');
                 const applyBtn = section.querySelector('#applyConvertBtn');
                 // ... other elements ...
                  const newFormatSpan = section.querySelector('#newFormat');
                  const convertedSizeSpan = section.querySelector('#convertedSize');
                  const convertedImage = section.querySelector('#convertedImage');
                  const downloadLink = section.querySelector('#convertDownloadLink');
                  const downloadMessage = section.querySelector('#convertDownloadMessage');
                  const processingMsg = section.querySelector('#convertProcessingMsg');

                 formatSelect?.addEventListener('change', () => {
                    const state = toolState[toolId] || {};
                    applyBtn.disabled = !(state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0);
                 });

                 applyBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;

                    console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage:`, currentImage);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.complete:`, currentImage?.complete);
                    console.log(`[${toolId.toUpperCase()} CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);

                    const mime = formatSelect.value;
                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && mime) {
                        performConversion(currentFile, currentImage, mime);
                    } else { alert("Select file and output format."); }
                 });

                 addDropZoneListeners(toolId, 'convertDropZone', 'convertImageFile', false, "image/*");

                 function performConversion(file, imageObj, outputMime) { // ... (remains the same) ...
                     console.log(`[${toolId.toUpperCase()} PROCESS] Processing...`, file, imageObj, outputMime); // DEBUG
                      applyBtn.disabled = true; processingMsg.style.display = 'block';
                      if (convertedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImage.src); } catch (e) {}
                      convertedImage.src = ''; convertedImage.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                      newFormatSpan.textContent = '-'; convertedSizeSpan.textContent = '-';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = imageObj.naturalWidth; canvas.height = imageObj.naturalHeight;
                      if (outputMime === 'image/jpeg' || outputMime === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.drawImage(imageObj, 0, 0);

                      canvas.toBlob(blob => {
                          if (blob) { updateConvertOutput(blob, file.name, outputMime, file.type); }
                          else { alert("Conversion failed."); newFormatSpan.textContent = 'Failed'; }
                           // Re-check state for enabling button
                          const currentState = toolState[toolId] || {};
                          applyBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && formatSelect.value);
                          processingMsg.style.display = 'none';
                      }, outputMime, 0.8);
                 }
                 function updateConvertOutput(blob, name, outMime, inMime) { // ... (remains the same) ...
                      if (convertedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(convertedImage.src); } catch (e) {}
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      const url = URL.createObjectURL(blob);
                      section.querySelector('#originalFormat').textContent = inMime.split('/')[1]?.toUpperCase() || '?';
                      newFormatSpan.textContent = outMime.split('/')[1]?.toUpperCase() || '?';
                      convertedSizeSpan.textContent = formatBytes(blob.size);
                      convertedImage.src = url; convertedImage.alt = 'Converted Image'; convertedImage.style.display = 'block';
                      downloadLink.href = url;
                      let ext = outMime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                      downloadLink.download = `converted_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                      downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Cropper (Adjusted to use toolState) ---
            function setupCropUI(file, imgUrl) {
                console.log("[SETUP CROP UI] File:", file, "imgUrl:", imgUrl);
                const toolId = 'image-cropper';
                const section = document.getElementById(toolId + '-section');
                const state = toolState[toolId] || {};
                const imageObj = state.imageObject;

                section.querySelector('#cropOriginalFileName').textContent = file.name;
                section.querySelector('#cropOriginalDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                section.querySelector('#cropOriginalSize').textContent = formatBytes(file.size);
                section.querySelector('#newCropDimensions').textContent = '-';
                section.querySelector('#croppedSize').textContent = '-';
                section.querySelector('#cropImageInfo').style.display = 'block';
                const cropOrigPrev = section.querySelector('#cropOriginalImagePreview');
                cropOrigPrev.src = imgUrl;
                cropOrigPrev.alt = `Image to Crop (${file.name})`;
                cropOrigPrev.style.display = 'block';
                section.querySelector('.cropper-container').style.display = 'block';
                section.querySelector('.cropper-container').style.cursor = 'default';
                section.querySelector('.crop-selection-overlay').style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                section.querySelector('.preview-comparison').style.display = 'none';
                const compareOrig = section.querySelector('#cropCompareOriginalPreview');
                const croppedImg = section.querySelector('#croppedImage');
                if(compareOrig.src?.startsWith('blob:')) try { URL.revokeObjectURL(compareOrig.src); } catch(e){}
                if(croppedImg.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImg.src); } catch(e){}
                compareOrig.src = ''; compareOrig.style.display = 'none';
                croppedImg.src = ''; croppedImg.style.display = 'none';
                section.querySelector('#cropImagePreview').style.display = 'block';
                section.querySelector('#selectCropAreaBtn').disabled = !(imageObj && imageObj.naturalWidth > 0);
                section.querySelector('#cropAndDownloadBtn').disabled = true;
                finalScaledCrop = null;
            }
            function setupImageCropperListeners() {
                const toolId = 'image-cropper';
                const section = document.getElementById(toolId + '-section');
                 const selectAreaBtn = section.querySelector('#selectCropAreaBtn');
                 const cropAndDownloadBtn = section.querySelector('#cropAndDownloadBtn');
                 // ... other elements ...
                  const newCropDimensionsSpan = section.querySelector('#newCropDimensions');
                  const croppedSizeSpan = section.querySelector('#croppedSize');
                  const previewSection = section.querySelector('#cropImagePreview');
                  const interactiveContainer = section.querySelector('.cropper-container');
                  const comparisonContainer = section.querySelector('.preview-comparison');
                  const cropOriginalImagePreview = section.querySelector('#cropOriginalImagePreview');
                  const cropCompareOriginalPreview = section.querySelector('#cropCompareOriginalPreview');
                  const cropSelectionOverlay = section.querySelector('.crop-selection-overlay');
                  const croppedImage = section.querySelector('#croppedImage');
                  const downloadLink = section.querySelector('#cropDownloadLink');
                  const downloadMessage = section.querySelector('#cropDownloadMessage');
                  const processingMsg = section.querySelector('#cropProcessingMsg');

                 let isSelectingCropArea = false; let isDragging = false; let startX = 0, startY = 0;

                 selectAreaBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                    console.log(`[${toolId.toUpperCase()} SELECT AREA CLICK] state:`, state);
                    console.log(`[${toolId.toUpperCase()} SELECT AREA CLICK] currentFile:`, currentFile);
                    console.log(`[${toolId.toUpperCase()} SELECT AREA CLICK] currentImage:`, currentImage);
                    console.log(`[${toolId.toUpperCase()} SELECT AREA CLICK] currentImage.complete:`, currentImage?.complete);
                    console.log(`[${toolId.toUpperCase()} SELECT AREA CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);
                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0) {
                        // ... rest of selectAreaBtn logic ...
                         isSelectingCropArea = true; isDragging = false;
                         cropSelectionOverlay.style.cssText = 'display: none; top: 0; left: 0; width: 0; height: 0;';
                         interactiveContainer.style.display = 'block'; comparisonContainer.style.display = 'none';
                         cropOriginalImagePreview.style.display = 'block';
                         if (cropCompareOriginalPreview.src?.startsWith('blob:')) try { URL.revokeObjectURL(cropCompareOriginalPreview.src); } catch (e) {}
                         cropCompareOriginalPreview.src = ''; cropCompareOriginalPreview.style.display = 'none';
                         if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                         croppedImage.src = ''; croppedImage.style.display = 'none';
                         newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                         if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                         downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                         finalScaledCrop = null; cropAndDownloadBtn.disabled = true;
                         interactiveContainer.style.cursor = 'crosshair';
                         selectAreaBtn.disabled = true; // Disable while selecting
                    } else { alert("Please select an image file first."); }
                 });
                  // Mousedown, Mousemove, Mouseup listeners remain largely the same, but ensure they use state.imageObject if needed for width/height checks
                 interactiveContainer?.addEventListener('mousedown', (e) => { // ... (event handling) ...
                     if (!isSelectingCropArea || isDragging || e.button !== 0) return; e.preventDefault();
                     isDragging = true;
                     const cRect = interactiveContainer.getBoundingClientRect();
                     startX = Math.max(0, Math.min(e.clientX - cRect.left, cRect.width));
                     startY = Math.max(0, Math.min(e.clientY - cRect.top, cRect.height));
                     cropSelectionOverlay.style.left = `${startX}px`; cropSelectionOverlay.style.top = `${startY}px`;
                     cropSelectionOverlay.style.width = '0'; cropSelectionOverlay.style.height = '0';
                     cropSelectionOverlay.style.display = 'block';
                     newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';
                     cropAndDownloadBtn.disabled = true; finalScaledCrop = null;
                 });
                 interactiveContainer?.addEventListener('mousemove', (e) => { // ... (event handling) ...
                     if (!isDragging) return; e.preventDefault();
                     const cRect = interactiveContainer.getBoundingClientRect();
                     const cx = Math.max(0, Math.min(e.clientX - cRect.left, cRect.width));
                     const cy = Math.max(0, Math.min(e.clientY - cRect.top, cRect.height));
                     const x = Math.min(cx, startX); const y = Math.min(cy, startY);
                     const w = Math.abs(cx - startX); const h = Math.abs(cy - startY);
                     cropSelectionOverlay.style.left = `${x}px`; cropSelectionOverlay.style.top = `${y}px`;
                     cropSelectionOverlay.style.width = `${w}px`; cropSelectionOverlay.style.height = `${h}px`;
                     cropAndDownloadBtn.disabled = !(w > 5 && h > 5);
                 });
                 document.addEventListener('mouseup', (e) => { // ... (event handling) ...
                     if (!isDragging || !isSelectingCropArea) return;
                     isDragging = false;
                     const state = toolState[toolId] || {}; // Get state
                     const currentImage = state.imageObject; // Get image from state
                     const fw = cropSelectionOverlay.offsetWidth || 0; const fh = cropSelectionOverlay.offsetHeight || 0;

                     if (fw > 5 && fh > 5 && cropOriginalImagePreview && currentImage?.naturalWidth > 0) { // Use currentImage
                         const oRect = cropSelectionOverlay.getBoundingClientRect();
                         const iRect = cropOriginalImagePreview.getBoundingClientRect();
                         if (!iRect.width || !iRect.height) { alert("Cannot calculate crop, image size error."); isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false; return; }
                         const scaleX = currentImage.naturalWidth / iRect.width; // Use currentImage
                         const scaleY = currentImage.naturalHeight / iRect.height; // Use currentImage
                         const selX = Math.max(0, oRect.left - iRect.left);
                         const selY = Math.max(0, oRect.top - iRect.top);
                         const selW = Math.min(fw, iRect.width - selX);
                         const selH = Math.min(fh, iRect.height - selY);
                         const finX = Math.round(selX * scaleX); const finY = Math.round(selY * scaleY);
                         const finW = Math.max(1, Math.round(selW * scaleX)); const finH = Math.max(1, Math.round(selH * scaleY));

                         if (finW > 0 && finH > 0 && (finX + finW <= currentImage.naturalWidth + 1) && (finY + finH <= currentImage.naturalHeight + 1)) { // Use currentImage
                             finalScaledCrop = { x: finX, y: finY, width: finW, height: finH };
                             newCropDimensionsSpan.textContent = `${finW}x${finH}`;
                             cropAndDownloadBtn.disabled = false;
                         } else {
                             console.warn("Invalid crop calc:", {finX, finY, finW, finH, imgW: currentImage.naturalWidth, imgH: currentImage.naturalHeight}); // Use currentImage
                             finalScaledCrop = null; cropSelectionOverlay.style.display = 'none'; cropAndDownloadBtn.disabled = true;
                             isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                             alert("Invalid selection calculated. Try again within bounds.");
                         }
                     } else {
                          finalScaledCrop = null; cropSelectionOverlay.style.display = 'none'; cropAndDownloadBtn.disabled = true;
                          isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                          if (fw > 0 || fh > 0) alert("Please select a valid crop area (min 5x5 pixels).");
                     }
                 });


                 cropAndDownloadBtn?.addEventListener('click', () => {
                    const state = toolState[toolId] || {};
                    const currentFile = state.file;
                    const currentImage = state.imageObject;
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] state:`, state);
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] currentFile:`, currentFile);
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] currentImage:`, currentImage);
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] currentImage.complete:`, currentImage?.complete);
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);
                    console.log(`[${toolId.toUpperCase()} CROP CLICK] finalScaledCrop:`, finalScaledCrop);

                    if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && finalScaledCrop) {
                        performCrop(currentFile, currentImage);
                        isSelectingCropArea = false; interactiveContainer.style.cursor = 'default'; selectAreaBtn.disabled = false;
                    } else { alert("Please select an image and define a valid crop area first."); }
                 });

                 addDropZoneListeners(toolId, 'cropDropZone', 'cropImageFile', false, "image/*");

                 function performCrop(file, imageObj) { // ... (remains the same) ...
                     console.log(`[${toolId.toUpperCase()} PROCESS] Processing...`, file, imageObj, finalScaledCrop); // DEBUG
                      const { x, y, width, height } = finalScaledCrop;
                      cropAndDownloadBtn.disabled = true; selectAreaBtn.disabled = true; processingMsg.style.display = 'block';
                      if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                      croppedImage.src = ''; croppedImage.style.display = 'none';
                      if (cropCompareOriginalPreview.src?.startsWith('blob:')) try { URL.revokeObjectURL(cropCompareOriginalPreview.src); } catch (e) {}
                      cropCompareOriginalPreview.src = ''; cropCompareOriginalPreview.style.display = 'none';
                      interactiveContainer.style.display = 'none';
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                      downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                      newCropDimensionsSpan.textContent = '-'; croppedSizeSpan.textContent = '-';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      canvas.width = width; canvas.height = height;
                      const mimeType = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height); }
                      else { ctx.clearRect(0, 0, width, height); }
                      ctx.drawImage(imageObj, x, y, width, height, 0, 0, width, height);

                      canvas.toBlob((blob) => {
                          if (blob) { updateCropOutput(blob, file.name, width, height, mimeType, imageObj.src); }
                          else { alert("Cropping failed."); newCropDimensionsSpan.textContent = 'Failed'; interactiveContainer.style.display='block'; }
                           // Re-check state for enabling button
                           const currentState = toolState[toolId] || {};
                          selectAreaBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                          cropAndDownloadBtn.disabled = true; // Always disable after crop until new selection
                          processingMsg.style.display = 'none';
                      }, mimeType);
                 }
                 function updateCropOutput(blob, name, w, h, mime, origSrc) { // ... (remains the same) ...
                     if (croppedImage.src?.startsWith('blob:')) try { URL.revokeObjectURL(croppedImage.src); } catch (e) {}
                     if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch (e) {}
                     const url = URL.createObjectURL(blob);
                     newCropDimensionsSpan.textContent = `${w}x${h}`;
                     croppedSizeSpan.textContent = formatBytes(blob.size);
                     cropCompareOriginalPreview.src = origSrc;
                     cropCompareOriginalPreview.alt = `Original Preview (${name})`;
                     cropCompareOriginalPreview.style.display = 'block';
                     croppedImage.src = url; croppedImage.alt = `Cropped Image`; croppedImage.style.display = 'block';
                     comparisonContainer.style.display = 'flex'; interactiveContainer.style.display = 'none';
                     previewSection.style.display = 'block';
                     finalScaledCrop = null;
                     downloadLink.href = url;
                     let ext = mime.split('/')[1] || 'jpg'; if(ext === 'jpeg') ext = 'jpg';
                     downloadLink.download = `cropped_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                     downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- Image Rotate/Flip (Adjusted to use toolState) ---
            function setupRotateFlipUI(file, imgUrl) {
                 console.log("[SETUP ROTATE/FLIP UI] File:", file, "imgUrl:", imgUrl);
                 const toolId = 'image-rotate-flip';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;
                 // ... rest of UI setup ...
                 const imageInfoDiv = section.querySelector('.image-info');
                 const originalFileNameSpan = section.querySelector('#rotateFlipOriginalFileName');
                 const originalDimensionsSpan = section.querySelector('#originalRotateFlipDimensions');
                 const originalSizeSpan = section.querySelector('#rotateFlipOriginalSize');
                 const newRotateFlipDimensionsSpan = section.querySelector('#newRotateFlipDimensions');
                 const newRotateFlipSizeSpan = section.querySelector('#newRotateFlipSize');
                 const previewSection = section.querySelector('.image-preview');
                 const originalPreviewImgEl = section.querySelector('#rotateFlipOriginalPreview');
                 const rotatedFlippedImageEl = section.querySelector('#rotatedFlippedImage');
                 const downloadLink = section.querySelector('#rotateFlipDownloadLink');
                 const downloadMessage = section.querySelector('#rotateFlipDownloadMessage');

                 originalFileNameSpan.textContent = file.name;
                 originalDimensionsSpan.textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                 originalSizeSpan.textContent = formatBytes(file.size);
                 newRotateFlipDimensionsSpan.textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                 newRotateFlipSizeSpan.textContent = formatBytes(file.size);
                 if (imageInfoDiv) imageInfoDiv.style.display = 'block';

                 originalPreviewImgEl.src = imgUrl;
                 originalPreviewImgEl.alt = `Original Image Preview (${file.name})`;
                 originalPreviewImgEl.style.display = 'block';

                 currentRotationAngle = 0; currentFlipH = false; currentFlipV = false;

                 if (rotatedFlippedImageEl.src?.startsWith('blob:') && rotatedFlippedImageEl.src !== imgUrl) { try { URL.revokeObjectURL(rotatedFlippedImageEl.src); } catch (e) {} }
                 rotatedFlippedImageEl.src = imgUrl; // Show original initially
                 rotatedFlippedImageEl.alt = 'Result Preview';
                 rotatedFlippedImageEl.style.display = 'block';

                 if (previewSection) previewSection.style.display = 'block';
                 section.querySelectorAll('.rotate-flip-controls button').forEach(btn => btn.disabled = !(imageObj && imageObj.naturalWidth > 0));

                 if (downloadLink.href?.startsWith('blob:') && downloadLink.href !== imgUrl) { try { URL.revokeObjectURL(downloadLink.href); } catch (e) {} }
                 downloadLink.style.display = 'none'; if(downloadMessage) downloadMessage.style.display = 'none';
                 // Don't set download link href until first transformation
            }
             function setupImageRotateFlipListeners() {
                 const toolId = 'image-rotate-flip';
                 const section = document.getElementById(toolId + '-section');
                 // ... get buttons and UI elements ...
                  const rotateLeftBtn = section.querySelector('#rotateLeftBtn');
                  const rotateRightBtn = section.querySelector('#rotateRightBtn');
                  const flipHorizontalBtn = section.querySelector('#flipHorizontalBtn');
                  const flipVerticalBtn = section.querySelector('#flipVerticalBtn');
                  const newRotateFlipDimensionsSpan = section.querySelector('#newRotateFlipDimensions');
                  const newRotateFlipSizeSpan = section.querySelector('#newRotateFlipSize');
                  const rotatedFlippedImageEl = section.querySelector('#rotatedFlippedImage');
                  const downloadLink = section.querySelector('#rotateFlipDownloadLink');
                  const downloadMessage = section.querySelector('#rotateFlipDownloadMessage');
                  const processingMsg = section.querySelector('#rotateFlipProcessingMsg');
                  const controlButtons = [rotateLeftBtn, rotateRightBtn, flipHorizontalBtn, flipVerticalBtn];

                 function applyAndRenderTransforms() {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file;
                     const currentImage = state.imageObject;

                     console.log(`[${toolId.toUpperCase()} ACTION] state:`, state);
                     console.log(`[${toolId.toUpperCase()} ACTION] currentFile:`, currentFile);
                     console.log(`[${toolId.toUpperCase()} ACTION] currentImage:`, currentImage);
                     console.log(`[${toolId.toUpperCase()} ACTION] currentImage.complete:`, currentImage?.complete);
                     console.log(`[${toolId.toUpperCase()} ACTION] currentImage.naturalWidth:`, currentImage?.naturalWidth);

                     if (!currentFile || !currentImage?.complete || currentImage.naturalWidth === 0) {
                         alert("Please select a valid image first."); return;
                      }
                     // ... rest of transform logic ...
                      controlButtons.forEach(btn => btn.disabled = true);
                      if(processingMsg) processingMsg.style.display = 'block';

                      const oldDownloadHref = downloadLink.href;
                      // Revoke only if it's a blob URL and NOT the original image URL from the state
                      if (oldDownloadHref?.startsWith('blob:') && oldDownloadHref !== state.fileUrl) {
                          try { URL.revokeObjectURL(oldDownloadHref); } catch(e) {}
                      }
                      downloadLink.style.display = 'none'; if(downloadMessage) downloadMessage.style.display = 'none';

                      const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                      const img = currentImage; // Use image from state
                      const iw = img.naturalWidth; const ih = img.naturalHeight;
                      if (currentRotationAngle === 90 || currentRotationAngle === 270) { [canvas.width, canvas.height] = [ih, iw]; }
                      else { [canvas.width, canvas.height] = [iw, ih]; }
                      const mimeType = currentFile.type.startsWith('image/') ? currentFile.type : 'image/jpeg'; // Use file from state
                      if (mimeType === 'image/jpeg' || mimeType === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                      else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
                      ctx.translate(canvas.width / 2, canvas.height / 2);
                      ctx.scale(currentFlipH ? -1 : 1, currentFlipV ? -1 : 1);
                      ctx.rotate(currentRotationAngle * Math.PI / 180);
                      ctx.drawImage(img, -iw / 2, -ih / 2, iw, ih);

                      canvas.toBlob((blob) => {
                          try {
                              if (!blob) throw new Error("Canvas toBlob failed.");
                              const newUrl = URL.createObjectURL(blob);
                              // Revoke previous *result* blob url if it exists and is different
                              const oldResultSrc = rotatedFlippedImageEl.src;
                              if (oldResultSrc?.startsWith('blob:') && oldResultSrc !== state.fileUrl && oldResultSrc !== newUrl) {
                                   try { URL.revokeObjectURL(oldResultSrc); } catch (e) {}
                               }
                              rotatedFlippedImageEl.src = newUrl; rotatedFlippedImageEl.style.display = 'block';
                              newRotateFlipDimensionsSpan.textContent = `${canvas.width}x${canvas.height}`;
                              newRotateFlipSizeSpan.textContent = formatBytes(blob.size);
                              downloadLink.href = newUrl;
                              let ext = mimeType.split('/')[1] || 'jpg'; if (ext === 'jpeg') ext = 'jpg';
                              downloadLink.download = `transformed_${currentFile.name.substring(0, currentFile.name.lastIndexOf('.')) || currentFile.name}.${ext}`;
                              downloadLink.style.display = 'inline-block'; if(downloadMessage) downloadMessage.style.display = 'block';
                          } catch(error) { console.error("Transform Error:", error); alert(`Transformation Error: ${error.message}`); }
                          finally {
                              const currentState = toolState[toolId] || {}; // Recheck state
                              controlButtons.forEach(btn => btn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0));
                              if(processingMsg) processingMsg.style.display = 'none';
                           }
                      }, mimeType);
                 }

                 rotateLeftBtn?.addEventListener('click', () => { currentRotationAngle = (currentRotationAngle - 90 + 360) % 360; applyAndRenderTransforms(); });
                 rotateRightBtn?.addEventListener('click', () => { currentRotationAngle = (currentRotationAngle + 90) % 360; applyAndRenderTransforms(); });
                 flipHorizontalBtn?.addEventListener('click', () => { currentFlipH = !currentFlipH; applyAndRenderTransforms(); });
                 flipVerticalBtn?.addEventListener('click', () => { currentFlipV = !currentFlipV; applyAndRenderTransforms(); });
                 addDropZoneListeners(toolId, 'rotateFlipDropZone', 'rotateFlipImageFile', false, "image/*");
             }

            // --- Image Filters (Adjusted to use toolState) ---
             function setupFilterUI(file, imgUrl) {
                 console.log("[SETUP FILTER UI] File:", file, "imgUrl:", imgUrl);
                 const toolId = 'image-filters';
                 const section = document.getElementById(toolId + '-section');
                 const state = toolState[toolId] || {};
                 const imageObj = state.imageObject;
                 // ... rest of UI setup ...
                  section.querySelector('#filterOriginalFileName').textContent = file.name;
                  section.querySelector('#originalFilterDimensions').textContent = imageObj ? `${imageObj.naturalWidth}x${imageObj.naturalHeight}` : '-';
                  section.querySelector('#filterOriginalSize').textContent = formatBytes(file.size);
                  section.querySelector('#newFilterSize').textContent = '-';
                  section.querySelector('#filterImageInfo').style.display = 'block';
                  section.querySelector('#filterOriginalPreview').src = imgUrl;
                  section.querySelector('#filterOriginalPreview').alt = `Original Image Preview (${file.name})`;
                  section.querySelector('#filterOriginalPreview').style.display = 'block';
                  const filteredImgEl = section.querySelector('#filteredImage');
                  if(filteredImgEl.src?.startsWith('blob:') && filteredImgEl.src !== imgUrl) try { URL.revokeObjectURL(filteredImgEl.src); } catch(e){} // Revoke old result
                  filteredImgEl.src = ''; // Don't show result until filter applied
                  filteredImgEl.style.display = 'none';
                  section.querySelector('#filterImagePreview').style.display = 'block';
                  section.querySelector('#filterType').disabled = !(imageObj && imageObj.naturalWidth > 0);
                  section.querySelector('#filterType').value = 'none';
                  section.querySelector('#applyFilterBtn').disabled = true; // Must select a filter first
             }
             function setupImageFiltersListeners() {
                 const toolId = 'image-filters';
                 const section = document.getElementById(toolId + '-section');
                 const filterTypeSelect = section.querySelector('#filterType');
                 const applyFilterBtn = section.querySelector('#applyFilterBtn');
                 // ... other elements ...
                  const newFilterSizeSpan = section.querySelector('#newFilterSize');
                  const filteredImage = section.querySelector('#filteredImage');
                  const downloadLink = section.querySelector('#filterDownloadLink');
                  const downloadMessage = section.querySelector('#filterDownloadMessage');
                  const processingMsg = section.querySelector('#filterProcessingMsg');

                 filterTypeSelect?.addEventListener('change', () => {
                    const state = toolState[toolId] || {}; // Get current state
                    const selected = filterTypeSelect.value;
                    // Check state directly here
                    const ready = state.file && state.imageObject?.complete && state.imageObject.naturalWidth > 0;

                    console.log(`[${toolId.toUpperCase()} SELECT CHANGE] state:`, state);
                    console.log(`[${toolId.toUpperCase()} SELECT CHANGE] selected:`, selected);
                    console.log(`[${toolId.toUpperCase()} SELECT CHANGE] ready variable:`, ready);

                    applyFilterBtn.disabled = !(ready && selected !== 'none');

                    // Update UI based on 'None' selection
                    if (ready && selected === 'none') {
                        const originalUrl = state.fileUrl; // Get original URL from state
                        if(filteredImage.src?.startsWith('blob:') && filteredImage.src !== originalUrl) try { URL.revokeObjectURL(filteredImage.src); } catch(e){}
                        filteredImage.src = originalUrl || ''; // Show original or nothing
                        filteredImage.style.display = originalUrl ? 'block' : 'none';
                        newFilterSizeSpan.textContent = state.file ? formatBytes(state.file.size) : '-';
                        if(downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                        downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                    }
                 });

                 applyFilterBtn?.addEventListener('click', () => {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file;
                     const currentImage = state.imageObject;
                     const selected = filterTypeSelect.value;

                     console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentImage:`, currentImage);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentImage.complete:`, currentImage?.complete);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentImage.naturalWidth:`, currentImage?.naturalWidth);
                     console.log(`[${toolId.toUpperCase()} CLICK] filterTypeSelect.value:`, selected);

                     if (currentFile && currentImage?.complete && currentImage.naturalWidth > 0 && selected !== 'none') {
                         applyFilter(selected);
                     } else { alert("Select image and filter first."); }
                 });

                 addDropZoneListeners(toolId, 'filterDropZone', 'filterImageFile', false, "image/*");

                 function applyFilter(filterType) {
                     const state = toolState[toolId] || {}; // Get current state
                     const file = state.file;
                     const imageObj = state.imageObject;
                     if (!file || !imageObj?.complete || !imageObj.naturalWidth > 0) return;
                     if (filterType === 'none') return;
                     console.log(`[${toolId.toUpperCase()} PROCESS] Processing...`, file, imageObj, filterType); // DEBUG

                     // ... (rest of filter application logic remains the same) ...
                     filterTypeSelect.disabled = true; applyFilterBtn.disabled = true; processingMsg.style.display = 'block';
                     if (filteredImage.src?.startsWith('blob:') && filteredImage.src !== state.fileUrl) try { URL.revokeObjectURL(filteredImage.src); } catch (e) {}
                     filteredImage.style.display = 'none';
                     if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';
                     newFilterSizeSpan.textContent = '-';

                     const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                     const w = imageObj.naturalWidth; const h = imageObj.naturalHeight;
                     canvas.width = w; canvas.height = h;
                     const mime = file.type.startsWith('image/') ? file.type : 'image/jpeg';
                     if (mime === 'image/jpeg' || mime === 'image/webp') { ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h); }
                     else { ctx.clearRect(0, 0, w, h); }
                     ctx.drawImage(imageObj, 0, 0, w, h);
                     let imageData; try { imageData = ctx.getImageData(0, 0, w, h); } catch (e) { alert("Cannot get image data."); filterTypeSelect.disabled = false; applyFilterBtn.disabled = filterTypeSelect.value === 'none'; processingMsg.style.display = 'none'; return; }
                     let pixels = imageData.data;

                     try {
                         for (let i = 0; i < pixels.length; i += 4) {
                             const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2]; let nr, ng, nb;
                             switch(filterType) {
                                case 'grayscale': nr = ng = nb = Math.round(0.2126*r + 0.7152*g + 0.0722*b); break;
                                case 'sepia': nr = Math.min(255, Math.round(.393*r+.769*g+.189*b)); ng = Math.min(255, Math.round(.349*r+.686*g+.168*b)); nb = Math.min(255, Math.round(.272*r+.534*g+.131*b)); break;
                                case 'invert': nr=255-r; ng=255-g; nb=255-b; break;
                                case 'red': nr=r; ng=0; nb=0; break; case 'green': nr=0; ng=g; nb=0; break; case 'blue': nr=0; ng=0; nb=b; break;
                                default: nr=r; ng=g; nb=b; break;
                             }
                             pixels[i]=nr; pixels[i+1]=ng; pixels[i+2]=nb;
                         }
                         ctx.putImageData(imageData, 0, 0);
                     } catch(error) { console.error("Filter Error:", error); alert("Error applying filter."); filterTypeSelect.disabled=false; applyFilterBtn.disabled=true; processingMsg.style.display='none'; return; }

                     canvas.toBlob((blob) => {
                         if (blob) { updateFilterOutput(blob, file.name, mime); }
                         else { alert("Filtering failed."); newFilterSizeSpan.textContent = 'Failed'; }
                           // Re-check state for enabling controls
                          const currentState = toolState[toolId] || {};
                         filterTypeSelect.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0);
                         applyFilterBtn.disabled = !(currentState.file && currentState.imageObject?.complete && currentState.imageObject.naturalWidth > 0 && filterTypeSelect.value !== 'none');
                         processingMsg.style.display = 'none';
                     }, mime, 0.85);
                 }
                 function updateFilterOutput(blob, name, mime) { // ... (remains the same) ...
                      const state = toolState[toolId] || {};
                      if (filteredImage.src?.startsWith('blob:') && filteredImage.src !== state.fileUrl) try { URL.revokeObjectURL(filteredImage.src); } catch (e) {}
                      if (downloadLink.href?.startsWith('blob:')) try { URL.revokeObjectURL(downloadLink.href); } catch(e){}
                      const url = URL.createObjectURL(blob);
                      newFilterSizeSpan.textContent = formatBytes(blob.size);
                      filteredImage.src = url; filteredImage.alt = `Filtered Image (${name})`; filteredImage.style.display = 'block';
                      downloadLink.href = url;
                      let ext = mime.split('/')[1] || 'jpg'; if(ext==='jpeg') ext='jpg';
                      downloadLink.download = `filtered_${name.substring(0, name.lastIndexOf('.')) || name}.${ext}`;
                      downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                 }
            }

            // --- PDF Tools (Adjusted to use toolState) ---
            // Only adjust where they read file info if necessary (mostly for enabling buttons)
            // setupJpgToPdfUI, setupPdfToJpgUI, setupMergePdfUI, setupSplitPdfUI remain mostly the same
            // Listeners need to check toolState[toolId].files or toolState[toolId].file
            function setupJpgToPdfUI(fileObjects) { /* ... as before ... */
                 const section = document.getElementById('jpg-to-pdf-section');
                 const fileListUl = section.querySelector('#jpgToPdfFilesListUl');
                 const thumbnailsContainer = section.querySelector('#jpgThumbnailsContainer');
                 const resultEmbed = section.querySelector('#jpgToPdfResultPreviewEmbed');
                 const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');

                 fileListUl.innerHTML = ''; thumbnailsContainer.innerHTML = '';
                 if (successMsg) successMsg.style.display = 'none';
                 if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                 resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                 if (fileObjects.length > 0) {
                     fileObjects.forEach(obj => {
                          const li = document.createElement('li'); li.textContent = `${obj.file.name} (${formatBytes(obj.file.size)})`; fileListUl.appendChild(li);
                          const img = document.createElement('img'); img.src = obj.url; img.alt = `Preview ${obj.file.name}`; img.style.display = 'inline-block'; thumbnailsContainer.appendChild(img);
                      });
                     section.querySelector('#jpgToPdfFileList').style.display = 'block';
                     section.querySelector('#jpgToPdfPreviewContainer').style.display = 'block';
                     section.querySelector('#convertToPdfBtn').disabled = false;
                 } else {
                      section.querySelector('#jpgToPdfFileList').style.display = 'none';
                      section.querySelector('#jpgToPdfPreviewContainer').style.display = 'none';
                      section.querySelector('#convertToPdfBtn').disabled = true;
                 }
                 section.querySelector('#jpgToPdfOutputInfo').style.display = 'none';
                 section.querySelector('#jpgToPdfResultText').textContent = '';
                 const dl = section.querySelector('#jpgToPdfDownloadLink');
                 const dlMsg = section.querySelector('#jpgToPdfDownloadMessage');
                 if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                 dl.style.display = 'none'; dlMsg.style.display = 'none';
             }
            function setupJpgToPdfListeners() {
                 const toolId = 'jpg-to-pdf';
                 addDropZoneListeners(toolId, 'jpgToPdfDropZone', 'jpgToPdfFilesInput', true, "image/jpeg");
                 const section = document.getElementById(toolId + '-section');
                 const convertBtn = section.querySelector('#convertToPdfBtn');
                 // ... other elements ...
                  const processingMsg = section.querySelector('#jpgToPdfProcessingMsg');
                  const downloadLink = section.querySelector('#jpgToPdfDownloadLink');
                  const downloadMessage = section.querySelector('#jpgToPdfDownloadMessage');
                  const outputInfo = section.querySelector('#jpgToPdfOutputInfo');
                  const resultText = section.querySelector('#jpgToPdfResultText');
                  const resultEmbed = section.querySelector('#jpgToPdfResultPreviewEmbed');
                  const successMsgElementJP = resultEmbed.parentNode.querySelector('.preview-success-message');

                 convertBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFiles = state.files || []; // Get files from state

                     console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentFiles count:`, currentFiles.length);

                     if (currentFiles.length === 0) { alert("Please select JPG files first."); return; }
                     if (!jspdfInstance?.jsPDF) { alert("jsPDF library not loaded."); return; }

                     // ... rest of JPG to PDF logic using currentFiles ...
                     convertBtn.disabled = true; processingMsg.style.display = 'block';
                     outputInfo.style.display = 'none';
                     if (successMsgElementJP) successMsgElementJP.style.display = 'none';
                     if(resultEmbed.src?.startsWith('blob:')) try{URL.revokeObjectURL(resultEmbed.src); }catch(e){}
                     resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                     if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     const { jsPDF } = jspdfInstance; const pdf = new jsPDF({ unit: 'pt', format: 'a4', compress: true });
                     let pdfBlob;
                     try {
                         for (let i = 0; i < currentFiles.length; i++) {
                             const fileObj = currentFiles[i];
                             processingMsg.textContent = `Processing image ${i + 1}/${currentFiles.length}...`;
                             const img = new Image(); img.src = fileObj.url;
                             await new Promise((resolve, reject) => {
                                 img.onload = () => {
                                     const iw = img.naturalWidth, ih = img.naturalHeight; if(iw === 0 || ih === 0) return reject(`Img ${i+1} bad dims`);
                                     const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
                                     const ratio = iw / ih; let nw = pw - 20, nh = nw / ratio;
                                     if (nh > ph - 20) { nh = ph - 20; nw = nh * ratio; }
                                     const x = (pw - nw) / 2, y = (ph - nh) / 2;
                                     if (i > 0) pdf.addPage();
                                     const cvs = document.createElement('canvas'); cvs.width=iw; cvs.height=ih; cvs.getContext('2d').drawImage(img,0,0);
                                     pdf.addImage(cvs.toDataURL('image/jpeg'), 'JPEG', x, y, nw, nh);
                                     resolve();
                                 };
                                 img.onerror = (err) => reject(`Could not load image ${i+1}`);
                             });
                         }
                         processingMsg.textContent = 'Generating PDF...';
                         pdfBlob = pdf.output('blob'); const pdfUrl = URL.createObjectURL(pdfBlob);
                         resultEmbed.src = pdfUrl; resultEmbed.style.display = 'block';
                         downloadLink.href = pdfUrl; downloadLink.download = 'converted_images.pdf';
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${currentFiles.length} JPG(s) converted. PDF Size: ${formatBytes(pdfBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementJP) { successMsgElementJP.textContent = `PDF generated! (${currentFiles.length} images, ${formatBytes(pdfBlob.size)})`; successMsgElementJP.style.display = 'block'; }
                     } catch (error) {
                          console.error("JPG to PDF Error:", error); alert(`Error: ${error.message || error}`);
                          resultText.textContent = `Conversion failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                     } finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                         // Re-check state
                          const currentState = toolState[toolId] || {};
                         convertBtn.disabled = (currentState.files?.length || 0) === 0;
                     }
                 });
            }
            async function setupPdfToJpgUI(file, url) { /* ... as before ... */
                  const toolId = 'pdf-to-jpg';
                  const section = document.getElementById(toolId + '-section');
                  section.querySelector('#pdfToJpgFileName').textContent = file.name;
                  section.querySelector('#pdfToJpgFileSize').textContent = formatBytes(file.size);
                  section.querySelector('#pdfToJpgPageCount').textContent = 'Loading...';
                  section.querySelector('#pdfToJpgFileInfo').style.display = 'block';
                  section.querySelector('#convertToJpgsBtn').disabled = true;
                  section.querySelector('#pdfToJpgOutputInfo').style.display = 'none';
                  section.querySelector('#pdfToJpgResultText').textContent = '';
                  section.querySelector('#pdfToJpgPreviewContainer').style.display = 'none';
                  const previewImg = section.querySelector('#pdfOriginalFirstPagePreview');
                  if(previewImg.src?.startsWith('blob:')) try{ URL.revokeObjectURL(previewImg.src); } catch(e){}
                  previewImg.src = ''; previewImg.style.display = 'none';
                  section.querySelector('#pdfResultThumbnailsContainer').innerHTML = '';
                  const dl = section.querySelector('#pdfToJpgDownloadLink');
                  const dlMsg = section.querySelector('#pdfToJpgDownloadMessage');
                   if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                  dl.style.display = 'none'; dlMsg.style.display = 'none';
                  const successMsg = section.querySelector('#pdfResultThumbnailsContainer')?.closest('.preview-comparison > div')?.querySelector('.preview-success-message');
                  if(successMsg) successMsg.style.display = 'none';

                  if (!pdfjsLibInstance) { alert("pdf.js failed to load."); return; }
                  let firstPageUrl = null;
                  try {
                     const arrayBuffer = await file.arrayBuffer();
                     const pdfDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer }).promise;
                     section.querySelector('#pdfToJpgPageCount').textContent = pdfDoc.numPages;
                     if (pdfDoc.numPages > 0) {
                          const page = await pdfDoc.getPage(1); const viewport = page.getViewport({ scale: 0.5 });
                          const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                          canvas.width = viewport.width; canvas.height = viewport.height;
                          ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                          await page.render({ canvasContext: ctx, viewport }).promise;
                          const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
                          if(blob) {
                              firstPageUrl = URL.createObjectURL(blob);
                              previewImg.src = firstPageUrl; previewImg.style.display = 'block';
                              section.querySelector('#pdfToJpgPreviewContainer').style.display = 'block';
                              // Store preview URL in state
                              if(toolState[toolId]) toolState[toolId].firstPagePreviewUrl = firstPageUrl;
                          }
                     }
                     section.querySelector('#convertToJpgsBtn').disabled = false; // Enable button after successful load
                  } catch (err) {
                     console.error("PDF Preview Error:", err); alert(`PDF Preview Error: ${err.message}`);
                     if(firstPageUrl) URL.revokeObjectURL(firstPageUrl); resetToolState(toolId);
                  }
            }
            function setupPdfToJpgListeners() {
                  const toolId = 'pdf-to-jpg';
                 addDropZoneListeners(toolId, 'pdfToJpgDropZone', 'pdfToJpgFileInput', false, "application/pdf");
                 const section = document.getElementById(toolId + '-section');
                 const convertBtn = section.querySelector('#convertToJpgsBtn');
                 // ... other elements ...
                  const processingMsg = section.querySelector('#pdfToJpgProcessingMsg');
                  const downloadLink = section.querySelector('#pdfToJpgDownloadLink');
                  const downloadMessage = section.querySelector('#pdfToJpgDownloadMessage');
                  const outputInfo = section.querySelector('#pdfToJpgOutputInfo');
                  const resultText = section.querySelector('#pdfToJpgResultText');
                  const previewContainer = section.querySelector('#pdfToJpgPreviewContainer');
                  const resultThumbnailsContainer = section.querySelector('#pdfResultThumbnailsContainer');
                  const successMsgElementPJ = resultThumbnailsContainer.closest('.preview-comparison > div')?.querySelector('.preview-success-message');
                  const maxPreviewPages = 5;

                 convertBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFile = state.file; // Get file from state

                     console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);

                     if (!currentFile) { alert("Please select a PDF file first."); return; }
                     if (!pdfjsLibInstance || !jszipInstance) { alert("Required libraries not loaded."); return; }

                     // ... rest of PDF to JPG logic using currentFile ...
                     convertBtn.disabled = true; processingMsg.style.display = 'block';
                     outputInfo.style.display = 'none'; resultThumbnailsContainer.innerHTML = '';
                     if (successMsgElementPJ) successMsgElementPJ.style.display = 'none';
                     if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     let arrayBuffer;
                     try { arrayBuffer = await currentFile.arrayBuffer(); }
                     catch (e) { alert("Error reading file."); processingMsg.style.display = 'none'; convertBtn.disabled = !toolState[toolId]?.file; return; }

                     let pdfDoc, previewBlobUrls = [], numPages = 0, zipBlob;
                     try {
                         pdfDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer }).promise;
                         numPages = pdfDoc.numPages; if (numPages === 0) throw new Error("PDF has no pages.");
                         const zip = new jszipInstance(); const quality = 0.9;

                         for (let i = 1; i <= numPages; i++) {
                             processingMsg.textContent = `Processing page ${i}/${numPages}...`;
                             const page = await pdfDoc.getPage(i); const vp = page.getViewport({ scale: 2.0 });
                             const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                             canvas.width = vp.width; canvas.height = vp.height; ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                             await page.render({ canvasContext: ctx, viewport: vp }).promise;
                             const jpgBlob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
                             if (!jpgBlob) throw new Error(`Failed JPG for page ${i}`);
                             zip.file(`page_${String(i).padStart(3, '0')}.jpg`, jpgBlob);
                             if (i <= maxPreviewPages) {
                                 const url = URL.createObjectURL(jpgBlob); previewBlobUrls.push(url);
                                 const img = document.createElement('img'); img.src = url; img.alt = `Page ${i} Preview`; img.style.display = 'inline-block';
                                 resultThumbnailsContainer.appendChild(img);
                             }
                         }
                         if(previewBlobUrls.length > 0 && previewContainer) previewContainer.style.display = 'block';
                         processingMsg.textContent = 'Zipping...';
                         zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                         const zipUrl = URL.createObjectURL(zipBlob);
                         downloadLink.href = zipUrl; downloadLink.download = `${currentFile.name.replace(/\.pdf$/i, '')}_jpgs.zip`;
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${numPages} page(s) converted. ZIP Size: ${formatBytes(zipBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementPJ) { successMsgElementPJ.textContent = `Converted to ${numPages} JPG(s)! (ZIP: ${formatBytes(zipBlob.size)})`; successMsgElementPJ.style.display = 'block'; }
                     } catch (error) {
                         console.error("PDF to JPG Error:", error); alert(`Error: ${error.message || error}`);
                         resultText.textContent = `Conversion failed: ${error.message || error}`; outputInfo.style.display = 'block';
                         section.querySelector('#pdfToJpgPageCount').textContent = pdfDoc ? pdfDoc.numPages : '?';
                     } finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                         convertBtn.disabled = !toolState[toolId]?.file; // Re-enable based on state
                         previewBlobUrls.forEach(url => { try { URL.revokeObjectURL(url); } catch(e){} });
                     }
                 });
            }
            function setupMergePdfUI(fileObjects) { /* ... as before ... */
                  const toolId = 'merge-pdf';
                  const section = document.getElementById(toolId + '-section');
                  const fileListUl = section.querySelector('#mergePdfFilesListUl');
                  const resultEmbed = section.querySelector('#mergePdfResultPreviewEmbed');
                  const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');

                  fileListUl.innerHTML = '';
                  if (successMsg) successMsg.style.display = 'none';
                  if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                  resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                  if (fileObjects.length >= 2) {
                       fileObjects.forEach(obj => {
                           const li = document.createElement('li'); li.textContent = `${obj.file.name} (${formatBytes(obj.file.size)})`; fileListUl.appendChild(li);
                       });
                      section.querySelector('#mergePdfFileList').style.display = 'block';
                      section.querySelector('#mergePdfPreviewContainer').style.display = 'block';
                      section.querySelector('#mergePdfsBtn').disabled = false;
                  } else {
                       section.querySelector('#mergePdfFileList').style.display = 'none';
                       section.querySelector('#mergePdfPreviewContainer').style.display = 'none';
                       section.querySelector('#mergePdfsBtn').disabled = true;
                       if (fileObjects.length === 1) { alert("Select at least two PDFs to merge."); /* Don't reset state here */ }
                  }
                  section.querySelector('#mergePdfOutputInfo').style.display = 'none';
                  section.querySelector('#mergePdfResultText').textContent = '';
                   const dl = section.querySelector('#mergePdfDownloadLink');
                   const dlMsg = section.querySelector('#mergePdfDownloadMessage');
                    if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                   dl.style.display = 'none'; dlMsg.style.display = 'none';
              }
            function setupMergePdfListeners() {
                  const toolId = 'merge-pdf';
                 addDropZoneListeners(toolId, 'mergePdfDropZone', 'mergePdfFilesInput', true, "application/pdf");
                 const section = document.getElementById(toolId + '-section');
                 const mergeBtn = section.querySelector('#mergePdfsBtn');
                 // ... other elements ...
                  const processingMsg = section.querySelector('#mergePdfProcessingMsg');
                  const downloadLink = section.querySelector('#mergePdfDownloadLink');
                  const downloadMessage = section.querySelector('#mergePdfDownloadMessage');
                  const outputInfo = section.querySelector('#mergePdfOutputInfo');
                  const resultText = section.querySelector('#mergePdfResultText');
                  const resultEmbed = section.querySelector('#mergePdfResultPreviewEmbed');
                  const successMsgElementMP = resultEmbed.parentNode.querySelector('.preview-success-message');

                 mergeBtn?.addEventListener('click', async () => {
                     const state = toolState[toolId] || {};
                     const currentFiles = state.files || []; // Get files from state

                     console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                     console.log(`[${toolId.toUpperCase()} CLICK] currentFiles count:`, currentFiles.length);

                     if (currentFiles.length < 2) { alert("Select at least two PDFs."); return; }
                     if (!pdfLibInstance?.PDFDocument) { alert("PDF-Lib not loaded."); return; }

                     // ... rest of merge logic using currentFiles ...
                     mergeBtn.disabled = true; processingMsg.style.display = 'block';
                     outputInfo.style.display = 'none';
                     if (successMsgElementMP) successMsgElementMP.style.display = 'none';
                     if(resultEmbed.src?.startsWith('blob:')) try{URL.revokeObjectURL(resultEmbed.src); }catch(e){}
                     resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                     if(downloadLink.href?.startsWith('blob:')) try{URL.revokeObjectURL(downloadLink.href); }catch(e){}
                     downloadLink.style.display = 'none'; downloadMessage.style.display = 'none';

                     let totalPagesMerged = 0; let mergedBlob;
                     try {
                         const mergedPdf = await pdfLibInstance.PDFDocument.create();
                         for (let i = 0; i < currentFiles.length; i++) {
                             const fileObj = currentFiles[i];
                             processingMsg.textContent = `Processing PDF ${i + 1}/${currentFiles.length}...`;
                             const pdfToMerge = await pdfLibInstance.PDFDocument.load(await fileObj.file.arrayBuffer(), { ignoreEncryption: true });
                             const indices = pdfToMerge.getPageIndices();
                             if (indices.length === 0) { console.warn(`PDF ${i+1} skipped (no pages).`); continue; }
                             const copiedPages = await mergedPdf.copyPages(pdfToMerge, indices);
                             copiedPages.forEach(page => mergedPdf.addPage(page)); totalPagesMerged += indices.length;
                         }
                         if (totalPagesMerged === 0) throw new Error("No pages merged.");
                         processingMsg.textContent = 'Saving PDF...';
                         mergedBlob = new Blob([await mergedPdf.save()], { type: 'application/pdf' });
                         const mergedUrl = URL.createObjectURL(mergedBlob);
                         resultEmbed.src = mergedUrl; resultEmbed.style.display = 'block';
                         downloadLink.href = mergedUrl; downloadLink.download = 'merged_document.pdf';
                         downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                         resultText.textContent = `${currentFiles.length} PDFs merged (${totalPagesMerged} pages). Size: ${formatBytes(mergedBlob.size)}`;
                         outputInfo.style.display = 'block';
                         if (successMsgElementMP) { successMsgElementMP.textContent = `PDFs merged! (${totalPagesMerged} pages, ${formatBytes(mergedBlob.size)})`; successMsgElementMP.style.display = 'block'; }
                     } catch (error) {
                          console.error("Merge PDF Error:", error); alert(`Merge Error: ${error.message || error}`);
                          resultText.textContent = `Merge failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                     } finally {
                         processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                           // Re-check state
                         const currentState = toolState[toolId] || {};
                         mergeBtn.disabled = (currentState.files?.length || 0) < 2;
                     }
                 });
             }
            function parsePageRanges(rangeString, totalPages) { /* ... as before ... */
                  const pages = new Set(); if (!rangeString || rangeString.trim() === '') return [];
                  const parts = rangeString.split(',');
                  for (const part of parts) {
                      const trimmed = part.trim();
                      if (/^\d+$/.test(trimmed)) { const p = parseInt(trimmed, 10); if (p > 0 && p <= totalPages) pages.add(p - 1); else throw new Error(`Page ${p} out of range (1-${totalPages})`); }
                      else if (/^\d+-\d+$/.test(trimmed)) { const [s, e] = trimmed.split('-').map(n => parseInt(n, 10)); if (s > 0 && e >= s && e <= totalPages) { for (let i = s; i <= e; i++) pages.add(i - 1); } else throw new Error(`Range ${s}-${e} invalid (max: ${totalPages})`); }
                      else if (trimmed !== '') throw new Error(`Invalid format: "${trimmed}"`);
                  }
                  if (pages.size === 0 && rangeString.trim() !== '') throw new Error("No valid pages selected.");
                  return Array.from(pages).sort((a, b) => a - b);
             }
            async function setupSplitPdfUI(file, url) { /* ... as before ... */
                  const toolId = 'split-pdf';
                  const section = document.getElementById(toolId + '-section');
                  section.querySelector('#splitPdfFileName').textContent = file.name;
                  section.querySelector('#splitPdfFileSize').textContent = formatBytes(file.size);
                  section.querySelector('#splitPdfTotalPages').textContent = 'Loading...';
                  section.querySelector('#splitPdfFileInfo').style.display = 'block';
                  section.querySelector('#splitPageRange').disabled = true; section.querySelector('#splitPageRange').value = '';
                  section.querySelector('#splitPdfBtn').disabled = true;
                  section.querySelector('#splitPdfOutputInfo').style.display = 'none';
                  section.querySelector('#splitPdfResultText').textContent = '';
                  section.querySelector('#splitPdfPreviewContainer').style.display = 'none';
                  const previewImg = section.querySelector('#splitPdfOriginalPreview');
                  if(previewImg.src?.startsWith('blob:')) try{ URL.revokeObjectURL(previewImg.src); } catch(e){}
                  previewImg.src = ''; previewImg.style.display = 'none';
                  const resultEmbed = section.querySelector('#splitPdfResultPreviewEmbed');
                  const successMsg = resultEmbed.parentNode.querySelector('.preview-success-message');
                  if(resultEmbed.src?.startsWith('blob:')) try { URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                  resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';
                  if(successMsg) successMsg.style.display = 'none';
                  const dl = section.querySelector('#splitPdfDownloadLink');
                  const dlMsg = section.querySelector('#splitPdfDownloadMessage');
                  if(dl.href?.startsWith('blob:')) try { URL.revokeObjectURL(dl.href); } catch(e){}
                  dl.style.display = 'none'; dlMsg.style.display = 'none';

                  splitPdfDocObject = null; // Reset specific variable
                  let firstPageUrl = null;
                  if (!pdfLibInstance?.PDFDocument || !pdfjsLibInstance) { alert("PDF libraries not loaded."); return; }
                  try {
                     const arrayBuffer = await file.arrayBuffer();
                     // Store the loaded PDFDocument in the global variable
                     splitPdfDocObject = await pdfLibInstance.PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
                     const numPages = splitPdfDocObject.getPageCount();
                     section.querySelector('#splitPdfTotalPages').textContent = numPages;
                     if(numPages > 0) {
                         const pdfjsDoc = await pdfjsLibInstance.getDocument({ data: arrayBuffer.slice(0) }).promise; // Use copy for pdf.js
                         const page = await pdfjsDoc.getPage(1); const viewport = page.getViewport({ scale: 0.5 });
                         const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                         canvas.width = viewport.width; canvas.height = viewport.height; ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
                         await page.render({ canvasContext: ctx, viewport }).promise;
                         const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
                         if(blob){
                             firstPageUrl = URL.createObjectURL(blob);
                             previewImg.src = firstPageUrl; previewImg.style.display = 'block';
                             section.querySelector('#splitPdfPreviewContainer').style.display = 'block';
                             // Store preview URL in state
                              if(toolState[toolId]) toolState[toolId].firstPagePreviewUrl = firstPageUrl;
                          }
                     }
                     section.querySelector('#splitPageRange').disabled = (numPages === 0);
                     // Button is enabled via input listener now
                     section.querySelector('#splitPdfBtn').disabled = (numPages === 0 || !section.querySelector('#splitPageRange').value.trim());
                     if(numPages === 0) alert("PDF has no pages.");
                  } catch(err) {
                     console.error("Split PDF Setup Error:", err); alert(`PDF Load Error: ${err.message}`);
                     if(firstPageUrl) URL.revokeObjectURL(firstPageUrl); resetToolState(toolId);
                  }
             }
            function setupSplitPdfListeners() {
                  const toolId = 'split-pdf';
                  addDropZoneListeners(toolId, 'splitPdfDropZone', 'splitPdfFileInput', false, "application/pdf");
                  const section = document.getElementById(toolId + '-section');
                  const rangeInput = section.querySelector('#splitPageRange');
                  const splitBtn = section.querySelector('#splitPdfBtn');
                  // ... other elements ...
                   const processingMsg = section.querySelector('#splitPdfProcessingMsg');
                   const downloadLink = section.querySelector('#splitPdfDownloadLink');
                   const downloadMessage = section.querySelector('#splitPdfDownloadMessage');
                   const outputInfo = section.querySelector('#splitPdfOutputInfo');
                   const resultText = section.querySelector('#splitPdfResultText');
                   const resultEmbed = section.querySelector('#splitPdfResultPreviewEmbed');
                   const successMsgElementSP = resultEmbed.parentNode.querySelector('.preview-success-message');

                  rangeInput?.addEventListener('input', () => {
                     // Enable/disable split button based on input and if PDF is loaded
                     splitBtn.disabled = !(splitPdfDocObject && rangeInput.value.trim());
                  });

                  splitBtn?.addEventListener('click', async () => {
                      const state = toolState[toolId] || {}; // Get state
                      const currentFile = state.file; // Get file from state

                      console.log(`[${toolId.toUpperCase()} CLICK] state:`, state);
                      console.log(`[${toolId.toUpperCase()} CLICK] currentFile:`, currentFile);
                      console.log(`[${toolId.toUpperCase()} CLICK] splitPdfDocObject:`, splitPdfDocObject); // Check PDF-Lib object


                      // Use the globally stored splitPdfDocObject
                      if (!currentFile || !splitPdfDocObject) { alert("Please upload a PDF file first."); return; }
                      if (!pdfLibInstance?.PDFDocument) { alert("PDF-Lib not loaded."); return; }

                      const rangeString = rangeInput.value; const totalPages = splitPdfDocObject.getPageCount();
                      let pageIndices;
                      try { pageIndices = parsePageRanges(rangeString, totalPages); if (pageIndices.length === 0) { alert("Please enter valid page numbers/ranges."); return; } }
                      catch (error) { alert(`Invalid page selection: ${error.message}`); return; }

                      // ... rest of split logic using splitPdfDocObject ...
                      splitBtn.disabled = true; rangeInput.disabled = true; processingMsg.style.display = 'block';
                      outputInfo.style.display = 'none'; if(successMsgElementSP) successMsgElementSP.style.display = 'none';
                      if(resultEmbed.src?.startsWith('blob:')) try{ URL.revokeObjectURL(resultEmbed.src); } catch(e){}
                      resultEmbed.removeAttribute('src'); resultEmbed.style.display = 'none';

                      let newPdfDoc, newBlob;
                      try {
                          processingMsg.textContent = `Extracting ${pageIndices.length} page(s)...`;
                          newPdfDoc = await pdfLibInstance.PDFDocument.create();
                          const copiedPages = await newPdfDoc.copyPages(splitPdfDocObject, pageIndices);
                          copiedPages.forEach(page => newPdfDoc.addPage(page));
                          if (newPdfDoc.getPageCount() === 0) throw new Error("No pages were extracted.");

                          processingMsg.textContent = 'Saving split PDF...';
                          newBlob = new Blob([await newPdfDoc.save()], { type: 'application/pdf' });
                          const newUrl = URL.createObjectURL(newBlob);

                          const oldDownloadHref = downloadLink.href;
                          if (oldDownloadHref?.startsWith('blob:') && oldDownloadHref !== newUrl) { try { URL.revokeObjectURL(oldDownloadHref); } catch(e) {} }

                          resultEmbed.src = newUrl; resultEmbed.style.display = 'block';
                          downloadLink.href = newUrl;
                          downloadLink.download = `split_${rangeString.replace(/[^0-9a-zA-Z-]/g, '_')}_${currentFile.name}`;
                          downloadLink.style.display = 'inline-block'; downloadMessage.style.display = 'block';
                          resultText.textContent = `Extracted ${newPdfDoc.getPageCount()} page(s). New Size: ${formatBytes(newBlob.size)}`;
                          outputInfo.style.display = 'block';
                          if (successMsgElementSP) { successMsgElementSP.textContent = `PDF split successfully! (${newPdfDoc.getPageCount()} pages, ${formatBytes(newBlob.size)})`; successMsgElementSP.style.display = 'block'; }
                      } catch (error) {
                           console.error("Split PDF Error:", error); alert(`Split Error: ${error.message || error}`);
                           resultText.textContent = `Split failed: ${error.message || error}`; outputInfo.style.display = 'block'; resultEmbed.style.display = 'none';
                      } finally {
                           processingMsg.textContent = 'Processing...'; processingMsg.style.display = 'none';
                           const canRetry = !!splitPdfDocObject; // Check if PDF object still exists
                           splitBtn.disabled = !(canRetry && rangeInput.value.trim());
                           rangeInput.disabled = !canRetry;
                      }
                  });
             }


            // --- Initialize All Tool Listeners ---
            function initializeAllToolListeners() {
                setupImageCompressorListeners();
                setupImageResizerListeners();
                setupImageConverterListeners();
                setupImageCropperListeners();
                setupImageRotateFlipListeners();
                setupImageFiltersListeners();
                setupJpgToPdfListeners();
                setupPdfToJpgListeners();
                setupMergePdfListeners();
                setupSplitPdfListeners();
            }

            // --- Contact Form ---
            function setupContactForm() { /* ... as before ... */
                 const contactForm = document.getElementById('contactForm');
                 if (contactForm) {
                     contactForm.addEventListener('submit', function(e) {
                         const formAction = contactForm.getAttribute('action');
                         if (!formAction || formAction === '#') {
                              e.preventDefault();
                              alert("Thank you! (Demo form - not sending emails)");
                              console.warn("Contact form submit blocked - no action set.");
                         }
                     });
                 }
             }

            // --- Blob Cleanup (Updated for toolState) ---
            function setupBlobCleanup() {
                window.addEventListener('beforeunload', () => {
                    console.log("[CLEANUP] Revoking Blob URLs...");
                    let revokedCount = 0;
                    const urlsToRevoke = new Set();

                    // Get URLs from visible elements
                    document.querySelectorAll('img[src^="blob:"], embed[src^="blob:"], a[href^="blob:"]')
                        .forEach(el => { if(el.src || el.href) urlsToRevoke.add(el.src || el.href); });

                    // Get URLs stored in toolState
                    Object.values(toolState).forEach(state => {
                        if (state?.imageObject?.src?.startsWith('blob:')) urlsToRevoke.add(state.imageObject.src);
                        if (state?.fileUrl?.startsWith('blob:')) urlsToRevoke.add(state.fileUrl);
                        if (state?.firstPagePreviewUrl?.startsWith('blob:')) urlsToRevoke.add(state.firstPagePreviewUrl);
                        if (state?.files) { // For multi-file tools
                            state.files.forEach(fileObj => { if(fileObj.url?.startsWith('blob:')) urlsToRevoke.add(fileObj.url); });
                        }
                    });

                    urlsToRevoke.forEach(url => {
                        if (url.startsWith('blob:')) { try { URL.revokeObjectURL(url); revokedCount++; } catch (e) {} }
                    });
                    console.log(`[CLEANUP] Attempted revoke for ${urlsToRevoke.size} URLs, ${revokedCount} successful.`);
                });
            }

        })(); // End IIFE
    </script>

</body>
</html>
